<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Binary Search</title>
    <url>/posts/fbb0c1cd/</url>
    <content><![CDATA[<h4 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="[35] Search Insert Position"></a>[35] Search Insert Position</h4><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
</blockquote>
<h6 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h6><p>我是哪里来的if-else怪物(为了边界情况, 疯狂if-else), 代码一点都不优雅, 考点应该是折半查找, 被我写成这个样子. 不说了, 我去找优雅解法去了…..</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">    end = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> mid = start + index(end - start);</span><br><span class="line">  <span class="comment">// 数组len=1</span></span><br><span class="line">  <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> start</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123; <span class="comment">// 数组len=2</span></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">      <span class="keyword">return</span> end + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == nums[start])</span><br><span class="line">      <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> end</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 数组len&gt;2</span></span><br><span class="line">    <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target:'</span> + target + <span class="string">'&lt;'</span> + <span class="string">"nums["</span> + mid + <span class="string">"]:"</span> + nums[mid]);</span><br><span class="line">        end = mid;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (target == nums[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mid = start + index(end - start);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target:'</span> + target + <span class="string">'&gt;'</span> + <span class="string">"nums["</span> + mid + <span class="string">"]:"</span> + nums[mid]);</span><br><span class="line">        start = mid;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (target == nums[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end + <span class="number">1</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mid = start + index(end - start);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(mid);</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = <span class="function">(<span class="params">gap</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (gap % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> gap / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (gap + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="solution-on-the-Internet"><a href="#solution-on-the-Internet" class="headerlink" title="solution on the Internet"></a>solution on the Internet</h6><p>参考网上的解法, 优化了一下, 感觉稍微简洁了些, 这里的mid取值是靠左的.所以一开始判断end值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">    <span class="keyword">return</span> end + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// if (target &lt; nums[start])</span></span><br><span class="line">  <span class="comment">//   return 0;</span></span><br><span class="line">  <span class="comment">// if (target == nums[start])</span></span><br><span class="line">  <span class="comment">//   return start</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">    mid = start + <span class="built_in">parseInt</span>((end - start) / <span class="number">2</span>); <span class="comment">// parseInt 直接丢弃小数部分, 保留整数部分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mid: '</span>, mid, <span class="string">' start: '</span>, start, <span class="string">' end: '</span>, end);</span><br><span class="line">    <span class="keyword">if</span> (target == nums[start])</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    <span class="keyword">if</span> (target == nums[end])</span><br><span class="line">      <span class="keyword">return</span> end;</span><br><span class="line">    <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// console.log('target &gt; mid', 'start: ', start);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      end = mid;</span><br><span class="line">      <span class="comment">// console.log('target &lt; mid', 'end: ', end);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Two Pointers</title>
    <url>/posts/b6a54014/</url>
    <content><![CDATA[<h4 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="[11] Container With Most Water"></a>[11] Container With Most Water</h4><blockquote>
<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>
</blockquote>
<h6 id="my-solution-Brute-Force"><a href="#my-solution-Brute-Force" class="headerlink" title="my solution : Brute Force"></a>my solution : Brute Force</h6><p>穷举所有面积的可能性,最后对面积进行排序,找到最大值.</p>
<p>中间一度尝试过将 <code>partArea</code> 组成数组先排序,也还是超时.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> partMaxSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> yVal = height[j] &lt; height[i] ? height[j] : height[i];</span><br><span class="line">      <span class="keyword">let</span> partArea = (j - i) * yVal;</span><br><span class="line">      partMaxSet.add(partArea);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> partMaxList = <span class="built_in">Array</span>.from(partMaxSet);</span><br><span class="line">  <span class="comment">// 数字降序排列</span></span><br><span class="line">  partMaxList.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a &#125;);</span><br><span class="line">  <span class="keyword">return</span> partMaxList[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// return Math.max.apply(null, partMaxList);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers"><a href="#Two-pointers" class="headerlink" title="Two pointers"></a>Two pointers</h6><p>采用双指针做法, 对于 S(i, j) 来说, 都是每次向里移动一步.</p>
<p>移动短板, 短板有可能变长, 面积有可能变大.</p>
<p>但是移动长板,  短板只会不变或者变小, 因为盛水的体积取决于短板, 所以面积只会不变或变小.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此算法需要证明</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> areaList = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">while</span> (j - i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">      <span class="comment">// 计算面积以短边为准</span></span><br><span class="line">      areaList.push((j - i) * height[i]);</span><br><span class="line">      <span class="comment">// 移动短边有可能获得更大面积</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      areaList.push((j - i) * height[j]);</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将可能的面积列表倒序排列,返回第一个</span></span><br><span class="line">  <span class="keyword">return</span> areaList.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Single pass.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant space is used.</li>
</ul>
<h4 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="[26] Remove Duplicates from Sorted Array"></a>[26] Remove Duplicates from Sorted Array</h4><blockquote>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
</blockquote>
<h6 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h6><p>借用 js 数组splice方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nums[j] == nums[i]) &#123;</span><br><span class="line">      nums.splice(j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers-1"><a href="#Two-pointers-1" class="headerlink" title="Two pointers"></a>Two pointers</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考双指针的方法, 优化了解法</span></span><br><span class="line"><span class="comment">// js的数组越界不会报错,只会得到 undefined 值</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="[27] Remove Element"></a>[27] Remove Element</h4><blockquote>
<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<h6 id="my-solution-1"><a href="#my-solution-1" class="headerlink" title="my solution"></a>my solution</h6><p>我自己的解法是利用了js数组操作的特性, 可以直接删除数组元素然后剩余元素位置前移的那种,比较方便,但是运行效果不咋地.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 使用 while 保证对于同一个i, 去除该位置所有与val相等的值</span></span><br><span class="line">    <span class="comment">// 不会遗漏由于删除数组元素而位置前移的新元素</span></span><br><span class="line">    <span class="keyword">while</span> (nums[i] == val) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers-2"><a href="#Two-pointers-2" class="headerlink" title="Two pointers"></a>Two pointers</h6><p>下面的解法是参考了示例解法, 双指针解法. 我觉得很精巧.</p>
<p>主要思路是, 将需要保留的元素都赋值给数组的前部分, 使用 i 标记赋值的位置.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution two pointers</span></span><br><span class="line"><span class="comment">// 只保留与val不同的元素</span></span><br><span class="line"><span class="comment">// 赋值操作比起splice的删除操作 肯定速度更快 至于额外的空间 需要看splice的实现有没有占用了</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      <span class="comment">// console.log("i=", i, " ", nums[i]);</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最差的情况应该是, 没有一个一样的, 但是遍历数组两遍而不是嵌套, 所以是 O(n).</p>
<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time complexity : O(n). Assume the array has a total of n<em>n</em> elements, both <em>i</em> and <em>j</em> traverse at most 2<em>n</em> steps.</li>
<li>Space complexity : O(1).</li>
</ul>
<h4 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="[15] 3Sum"></a>[15] 3Sum</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
</blockquote>
<p>数组排序后, 方便去除重复的元素 + 双指针移动不用嵌套且有方向可循.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 2 ：将数组排序后的双指针解法</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 将数组正序排列</span></span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 第一个数大于 0，肯定加起来和不为0了</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉重复元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> target = -nums[i];</span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">        res.push([nums[i], nums[left], nums[right]]);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 这里是否判断 left &lt; right 都没有那么重要, 因为最外面还会再判断一次</span></span><br><span class="line">        <span class="comment">// 但是加上判断可能会少做一次计算</span></span><br><span class="line">        <span class="comment">// 去掉重复元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">          right--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="[16] 3Sum Closest"></a>[16] 3Sum Closest</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
</blockquote>
<p>注意这里不是找相等, 而是保留最接近target的值, 实现方法类似.</p>
<p>与target比较, 由于一直在找最接近的, 比target小就left++, 比target大就right–, 总之就是不断靠近target.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> closest = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">let</span> diff = <span class="built_in">Math</span>.abs(closest - target);</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 由于数组是排好序的</span></span><br><span class="line">    <span class="comment">// 如果nums[i] * 3 &gt; target, 则 nums[i]+nums[i+1]+nums[i+2] 是接下来遍历的最小值</span></span><br><span class="line">    <span class="comment">// 后面差距只会越来越大</span></span><br><span class="line">    <span class="comment">// 将接下来最小值与当前最小值closest分别与target比较, 返回与target差距较小的那个值</span></span><br><span class="line">    <span class="comment">// 优化部分</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] * <span class="number">3</span> &gt; target) &#123;</span><br><span class="line">      <span class="keyword">let</span> cDiff = <span class="built_in">Math</span>.abs(closest - target);</span><br><span class="line">      <span class="keyword">let</span> tempMin = nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">let</span> tDiff = <span class="built_in">Math</span>.abs(tempMin - target);</span><br><span class="line">      <span class="keyword">return</span> cDiff &lt; tDiff ? closest : tempMin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针 遍历数组剩余元素</span></span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">      <span class="keyword">let</span> newDiff = <span class="built_in">Math</span>.abs(sum - target);</span><br><span class="line">      <span class="keyword">if</span> (newDiff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newDiff &lt; diff) &#123;</span><br><span class="line">        diff = newDiff;</span><br><span class="line">        closest = sum;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">        left++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log('closest:', closest);</span></span><br><span class="line">  <span class="keyword">return</span> closest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="[18] 4Sum"></a>[18] 4Sum</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em>in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
</blockquote>
<p>有了双指针, nSum都可解, 不过这个嵌套有点多,估计有更巧妙的解法.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> len = nums.length, res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; j &gt; i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">let</span> t = target - nums[i] - nums[j];</span><br><span class="line">      <span class="keyword">let</span> left = j + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> twoSum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (twoSum == t) &#123;</span><br><span class="line">          res.push([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">          <span class="comment">// 去重</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">            left++;</span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (twoSum &gt; t) &#123;</span><br><span class="line">          right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(res);</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="[283] Move Zeroes"></a>[283] Move Zeroes</h4><blockquote>
<p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Note</strong>:</p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
</blockquote>
<p>双指针解法, 一次成功.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution: two pointers</span></span><br><span class="line"><span class="comment">// 借鉴之前的做题经验, 这题算是完成的比较快</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> t = i; t &lt; len; t++) &#123;</span><br><span class="line">    nums[t] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(nums);</span></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="[66] Plus One"></a>[66] Plus One</h4><blockquote>
<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, increment one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
</blockquote>
<p>主要是运用数组特性.不是很难, 理解题意即可.</p>
<p>还挺多人不喜欢这道题的, 可能觉得太弱智了?…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = digits.length;</span><br><span class="line">  <span class="comment">// c 表示进位</span></span><br><span class="line">  <span class="keyword">let</span> i = len - <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有向前进位, 就 +1 结束</span></span><br><span class="line">    <span class="keyword">if</span> (digits[i] + c &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      digits[i]++;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 首位元素 +1 后有进位, 向数组头部插入 1 结束</span></span><br><span class="line">      digits[i] = <span class="number">0</span>;</span><br><span class="line">      digits.unshift(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是首位元素 +1 后有进位</span></span><br><span class="line">      <span class="comment">// 当前元素设为 0 , 继续看更高位元素</span></span><br><span class="line">      digits[i] = <span class="number">0</span>;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(digits);</span></span><br><span class="line">  <span class="keyword">return</span> digits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Permutations/Combinations/Subsets</title>
    <url>/posts/91d834a1/</url>
    <content><![CDATA[<h4 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="[78] Subsets"></a>[78] Subsets</h4><blockquote>
<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
</blockquote>
<p>观察全排列/组合/子集问题，它们比较相似，且可以使用一些通用策略解决。</p>
<p>首先，它们的解空间非常大：</p>
<ul>
<li>全排列：N!。</li>
</ul>
<ul>
<li>组合：N!。</li>
</ul>
<ul>
<li>子集：2^N, 每个元素都可能存在或不存在。</li>
</ul>
<p>在它们的指数级解法中，要确保生成的结果 <strong>完整</strong> 且 <strong>无冗余</strong>，有三种常用的方法：</p>
<ol>
<li>递归</li>
<li>回溯</li>
<li>基于二进制位掩码和对应位掩码之间的映射字典生成排列/组合/子集</li>
</ol>
<p>相比前两种方法，第三种方法将每种情况都简化为二进制数，易于实现和验证。</p>
<p>此外，第三种方法具有<strong>最优的时间复杂度</strong>，可以生成按照字典顺序的输出结果。</p>
<h5 id="solution-1-字典排序（二进制排序）-子集"><a href="#solution-1-字典排序（二进制排序）-子集" class="headerlink" title="solution 1 : 字典排序（二进制排序） 子集"></a>solution 1 : 字典排序（二进制排序） 子集</h5><p>这种解法很巧妙, 由于是全排列问题, 子集的数量与数组长度有关.</p>
<p>数组中的元素, 每个只有在或者不在子集中这两种选择. 对于每一种可能, 都能用二进制来标记.</p>
<p>因此该方法的思路如下:</p>
<p>假设数组为[1, 2, 4], 则子集数量为 2^len= 2^3 = 8</p>
<p>则从 0 - 7 的二进制对应分别为 000-111</p>
<p>每一种可能都对应一种子集详情, 比如 101 对应 [1,4],  001 对应 [4].</p>
<img src="/posts/91d834a1/bitmask4.png" class="" title="bitmask4">

<p>需要注意的点是, 在将十进制转换为二进制时, 需要将二进制的位数扩充至与nums的长度相等.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> subSets = [];</span><br><span class="line">  <span class="comment">// 根据数组长度计算器其子集数量</span></span><br><span class="line">  <span class="keyword">let</span> subSetsNum = <span class="built_in">Math</span>.pow(<span class="number">2</span>, len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subSetsNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 十进制转换为二进制</span></span><br><span class="line">    <span class="comment">// 每一个二进制都唯一对应一个子集</span></span><br><span class="line">    <span class="keyword">let</span> setNoStr = i.toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (setNoStr.length &lt; len) &#123;</span><br><span class="line">      <span class="comment">//如果长度不足 len，前面添加 0</span></span><br><span class="line">      setNoStr = <span class="string">'0'</span> + setNoStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> setNoList = setNoStr.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> subSet = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (setNoList[j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        subSet.push(nums[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    subSets.push(subSet);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subSets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N×2^N)，生成所有的子集，并复制到输出列表中。</li>
<li>空间复杂度：O(N×2^N)，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。</li>
</ul>
<h5 id="solution-2-递归法"><a href="#solution-2-递归法" class="headerlink" title="solution 2 : 递归法"></a>solution 2 : 递归法</h5><p>这个解法挺巧妙的, 每次都把新元素加进已有的所有子集, 生成新的子集, 因为每个元素只有在和不在两种情况.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> subSets = [[]];</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> subSets</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = subSets.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> ele = subSets[j].concat([nums[i]]);</span><br><span class="line">      subSets.push(ele);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subSets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Greedy Algorithm</title>
    <url>/posts/9adfc48b/</url>
    <content><![CDATA[<h4 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="[45] Jump Game II"></a>[45] Jump Game II</h4><blockquote>
<p> Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p> Each element in the array represents your maximum jump length at that position.</p>
<p> Your goal is to reach the last index in the minimum number of jumps.</p>
</blockquote>
<p>贪心算法, 局部解得到最优解.</p>
<p>解题思路: 每次查找当前位置能够到达的位置中, 能跳到最远位置的位置A, 下次就跳到位置A, 然后再从位置A能到达的位置中, 再找能跳到最远位置的位置, 如此循环.</p>
<p>但是官方解答虽然简洁, 但是我不是看的很明白, 还是暂时先贴自己的直白解法吧.</p>
<img src="/posts/9adfc48b/45_fig1.png" class="" title="45_fig1">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于当前index, 每次在能跳到的范围内</span></span><br><span class="line"><span class="comment">// 跳到能跳到更远地方的index</span></span><br><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt;= len - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> nextPosMap = &#123; <span class="string">'index'</span>: <span class="number">0</span>, <span class="string">'maxIndex'</span>: <span class="number">0</span> + nums[<span class="number">0</span>] &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len;) &#123;</span><br><span class="line">    <span class="keyword">let</span> indexLimit = i + nums[i];</span><br><span class="line">    <span class="comment">// 在寻找下一步跳的位置时, 步数加一</span></span><br><span class="line">    step++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= indexLimit &amp;&amp; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j + nums[j] &gt; nextPosMap.maxIndex) &#123;</span><br><span class="line">        nextPosMap.index = j;</span><br><span class="line">        nextPosMap.maxIndex = j + nums[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index != i, 说明能跳到更远距离的index更新了, 这时才需要将当前节点 i 移到index</span></span><br><span class="line">    <span class="comment">// 其实肯定更新, 题目已经说了能跳到最后</span></span><br><span class="line">    <span class="comment">// 移动才算跳了一步</span></span><br><span class="line">    <span class="comment">// 同时能跳到的最远位置不要超过数组边界</span></span><br><span class="line">    <span class="comment">// 超过数组边界则表示步数已经能计算出来了 return</span></span><br><span class="line">    <span class="keyword">if</span> (nextPosMap.maxIndex &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">      i = nextPosMap.index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当最大位置能到达最后时, 返回step+1</span></span><br><span class="line">      <span class="comment">// 把跳到最后位置的一步也加上</span></span><br><span class="line">      <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="[55] Jump Game"></a>[55] Jump Game</h4><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
</blockquote>
<p>一开始尝试使用递归做法, 计算所有的可能性, 但是想也不是最好的解法, 最后很可能超时, 果不其然超时.</p>
<p>于是就去看网上解法, 这里的考点是<strong>贪心算法</strong>.</p>
<blockquote>
<p>贪心算法（又称贪婪算法）是指，在对<a href="https://baike.baidu.com/item/问题求解/6693186" target="_blank" rel="noopener">问题求解</a>时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解</p>
</blockquote>
<p>该题的大概思路是:</p>
<p>数组的第一个元素的值为 reach, 从数组的第一个元素开始, 每次计算在reach范围内的元素们所能到达的最远距离, 是否超过reach, 如果超过了, 就更新reach值为较大值. 直至reach的值超过lastIndex 返回 true.</p>
<img src="/posts/9adfc48b/largen-reach.png" class="" title="largen-reach">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 递归超时 使用贪心算法求解</span></span><br><span class="line"><span class="comment">// 局部能够到达的最大范围, 也是全局能够到达的最大范围</span></span><br><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reach = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 需要注意的点是,这里reach的值不一定就&gt;1, 所以i不一定就从1开始</span></span><br><span class="line">  <span class="comment">// 还是从0开始能够包含所有情况, 这么写因为有个特例 [0]</span></span><br><span class="line">  <span class="comment">// 同时注意限制 i 的范围, i 是指 reach 能够到达的位置范围, 不能超过 reach</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length &amp;&amp; i &lt;= reach; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + i &gt; reach) &#123;</span><br><span class="line">      reach = nums[i] + i;</span><br><span class="line">      <span class="comment">// console.log(reach);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当能到达的范围超过数组的最后 index 时, 返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (reach &gt;= nums.length - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 能到达的元素位置都尝试了, 但是没有一个位置可以到达最后一个元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Learning</title>
    <url>/posts/c1889358/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
