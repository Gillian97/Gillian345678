<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Backtracking</title>
    <url>/2020/08/18/Backtracking/</url>
    <content><![CDATA[<h4 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="[22] Generate Parentheses"></a>[22] Generate Parentheses</h4><blockquote>
<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 思路: 2*n 是括号总数, 对括号进行排列组合, 再除去不合题意的部分</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> level = <span class="number">0</span>, <span class="comment">// 实时记录字符串的长度</span></span><br><span class="line">    sum = <span class="number">2</span> * n, <span class="comment">// 括号总数</span></span><br><span class="line">    str = <span class="string">''</span>, <span class="comment">// 括号累加的字符串</span></span><br><span class="line">    left = <span class="number">0</span>, <span class="comment">// 记录左括号数目</span></span><br><span class="line">    right = <span class="number">0</span>; <span class="comment">// 记录右括号数目</span></span><br><span class="line">  <span class="comment">// recur1(level, sum, str, arr);</span></span><br><span class="line">  recur2(sum, str, arr, left, right);</span><br><span class="line">  <span class="comment">// console.log('arr: ', arr);</span></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution 1: 暴力法</span></span><br><span class="line"><span class="keyword">var</span> recur1 = <span class="function">(<span class="params">level, sum, str, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (level == sum &amp;&amp; str.length == sum) &#123;</span><br><span class="line">    <span class="comment">// 将合法的组合放进结果数组</span></span><br><span class="line">    <span class="keyword">if</span> (isValid(str)) &#123;</span><br><span class="line">      arr.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过递归生成所有的可能的组合</span></span><br><span class="line">  recur(level + <span class="number">1</span>, sum, str + <span class="string">'('</span>, arr);</span><br><span class="line">  recur(level + <span class="number">1</span>, sum, str + <span class="string">')'</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (s.indexOf(<span class="string">'()'</span>) &gt;= <span class="number">0</span> || s.indexOf(<span class="string">'&#123;&#125;'</span>) &gt;= <span class="number">0</span> || s.indexOf(<span class="string">'[]'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    s = s.replace(<span class="regexp">/\(\)/g</span>, <span class="string">''</span>)</span><br><span class="line">    s = s.replace(<span class="regexp">/\[\]/g</span>, <span class="string">''</span>)</span><br><span class="line">    s = s.replace(<span class="regexp">/\&#123;\&#125;/g</span>, <span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="string">''</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以进行优化</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这四个条件确保放进结果数组里的字符串一定都是合法的</span></span><br><span class="line"><span class="comment"> * (感觉需要证明下)</span></span><br><span class="line"><span class="comment"> * 1. 左右括号一一对应</span></span><br><span class="line"><span class="comment"> * 2. 左右括号分别均为 n 个</span></span><br><span class="line"><span class="comment"> * 3. 当左括号数量大于右括号时，才加右括号</span></span><br><span class="line"><span class="comment"> * 4. 开头第一个一定是左括号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> recur2 = <span class="function">(<span class="params">sum, str, arr, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length == sum &amp;&amp; left == right) &#123;</span><br><span class="line">    <span class="comment">// 将合法的组合放进结果数组</span></span><br><span class="line">    arr.push(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过递归生成所有的可能的组合</span></span><br><span class="line">  <span class="comment">// 添加左括号, left + 1</span></span><br><span class="line">  <span class="comment">// 添加右括号, right + 1</span></span><br><span class="line">  <span class="comment">// 左括号的数量少于一半, 则加左括号</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt;= <span class="built_in">parseInt</span>(sum / <span class="number">2</span>)) &#123;</span><br><span class="line">    recur2(sum, str + <span class="string">'('</span>, arr, left + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 左括号数量大于右括号时, 才加右括号</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">    recur2(sum, str + <span class="string">')'</span>, arr, left, right + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="[46] Permutations"></a>[46] Permutations</h4><blockquote>
<p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>
</blockquote>
<p>时间复杂度: O(N*N!)</p>
<p>全排列一共有 N! 种可能, 实现每一种可能需要遍历整个数组即O(N)时间, 所以可得.</p>
<p>这个算法思路非常巧妙, 实现起来很清楚.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 算法思路是: 用一个数组维护每个数组元素的状态, true/false, 状态变量</span></span><br><span class="line"><span class="comment"> * 每次将未被放入的元素放入,每次放入一个元素后就再次dfs,再将没有放入的元素放入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">let</span> path = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> used = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化状态变量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    used.push(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(resArr, nums, len, path, <span class="number">0</span>, used);</span><br><span class="line">  <span class="keyword">return</span> resArr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs = <span class="function">(<span class="params">resArr, nums, len, path, depth, used</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth === len) &#123;</span><br><span class="line">    <span class="comment">// 注意不能resArr.push(path) 后面path改变会影响res里的值</span></span><br><span class="line">    <span class="comment">// js 值传递 传的是变量的地址</span></span><br><span class="line">    resArr.push(path.slice()); <span class="comment">// 需要将path的深拷贝放入</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">      path.push(nums[i]);</span><br><span class="line">      used[i] = <span class="literal">true</span>;</span><br><span class="line">      dfs(resArr, nums, len, path, depth + <span class="number">1</span>, used);</span><br><span class="line">      used[i] = <span class="literal">false</span>; <span class="comment">// 由于重新开始放入元素, 将已经放入的元素的状态置false</span></span><br><span class="line">      path.pop(); <span class="comment">// 弹出最后一个元素 路径回到上一个状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="[78] Subsets"></a>[78] Subsets</h4><blockquote>
<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
</blockquote>
<p>观察全排列/组合/子集问题，它们比较相似，且可以使用一些通用策略解决。</p>
<p>首先，它们的解空间非常大：</p>
<ul>
<li>全排列：N!。</li>
</ul>
<ul>
<li>组合：N!。</li>
</ul>
<ul>
<li>子集：2^N, 每个元素都可能存在或不存在。</li>
</ul>
<p>在它们的指数级解法中，要确保生成的结果 <strong>完整</strong> 且 <strong>无冗余</strong>，有三种常用的方法：</p>
<ol>
<li>递归</li>
<li>回溯</li>
<li>基于二进制位掩码和对应位掩码之间的映射字典生成排列/组合/子集</li>
</ol>
<p>相比前两种方法，第三种方法将每种情况都简化为二进制数，易于实现和验证。</p>
<p>此外，第三种方法具有<strong>最优的时间复杂度</strong>，可以生成按照字典顺序的输出结果。</p>
<h5 id="solution-1-字典排序（二进制排序）-子集"><a href="#solution-1-字典排序（二进制排序）-子集" class="headerlink" title="solution 1 : 字典排序（二进制排序） 子集"></a>solution 1 : 字典排序（二进制排序） 子集</h5><p>这种解法很巧妙, 由于是全排列问题, 子集的数量与数组长度有关.</p>
<p>数组中的元素, 每个只有在或者不在子集中这两种选择. 对于每一种可能, 都能用二进制来标记.</p>
<p>因此该方法的思路如下:</p>
<p>假设数组为[1, 2, 4], 则子集数量为 2^len= 2^3 = 8</p>
<p>则从 0 - 7 的二进制对应分别为 000-111</p>
<p>每一种可能都对应一种子集详情, 比如 101 对应 [1,4],  001 对应 [4].</p>
<img src="/2020/08/18/Backtracking/bitmask4.png" class="" title="bitmask4">

<p>需要注意的点是, 在将十进制转换为二进制时, 需要将二进制的位数扩充至与nums的长度相等.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> subSets = [];</span><br><span class="line">  <span class="comment">// 根据数组长度计算器其子集数量</span></span><br><span class="line">  <span class="keyword">let</span> subSetsNum = <span class="built_in">Math</span>.pow(<span class="number">2</span>, len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subSetsNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 十进制转换为二进制</span></span><br><span class="line">    <span class="comment">// 每一个二进制都唯一对应一个子集</span></span><br><span class="line">    <span class="keyword">let</span> setNoStr = i.toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (setNoStr.length &lt; len) &#123;</span><br><span class="line">      <span class="comment">//如果长度不足 len，前面添加 0</span></span><br><span class="line">      setNoStr = <span class="string">'0'</span> + setNoStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> setNoList = setNoStr.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> subSet = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (setNoList[j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        subSet.push(nums[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    subSets.push(subSet);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subSets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N×2^N)，生成所有的子集，并复制到输出列表中。</li>
<li>空间复杂度：O(N×2^N)，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。</li>
</ul>
<h5 id="solution-2-递归法"><a href="#solution-2-递归法" class="headerlink" title="solution 2 : 递归法"></a>solution 2 : 递归法</h5><p>这个解法挺巧妙的, 每次都把新元素加进已有的所有子集, 生成新的子集, 因为每个元素只有在和不在两种情况.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> subSets = [[]];</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> subSets</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = subSets.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> ele = subSets[j].concat([nums[i]]);</span><br><span class="line">      subSets.push(ele);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subSets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h5><p>回溯解法, 每次递归获得相同长度的子集</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    recur(i, <span class="number">0</span>, len, [], res, nums);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recur = <span class="function">(<span class="params">depth, first, len, curr, res, nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (curr.length == depth) &#123;</span><br><span class="line">    res.push(curr.slice()); <span class="comment">// 将当前子集的深拷贝加入结果数组</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = first; i &lt; len; i++) &#123;</span><br><span class="line">    curr.push(nums[i]);</span><br><span class="line">    recur(depth, i + <span class="number">1</span>, len, curr, res, nums);</span><br><span class="line">    curr.pop(); <span class="comment">// 回溯 回到初始状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="[90] Subsets II"></a>[90] Subsets II</h4><blockquote>
<p>Given a collection of integers that might contain duplicates, <strong><em>nums\</em></strong>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
</blockquote>
<p>思路与子集时类似, 只是需要剪枝操作, <strong>将同一层其余相同的元素除去</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsetsWithDup = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(); <span class="comment">// 排序操作 使得相同元素相邻</span></span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    recur(i, <span class="number">0</span>, len, [], res, nums);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recur = <span class="function">(<span class="params">depth, first, len, curr, res, nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (curr.length == depth) &#123;</span><br><span class="line">    res.push(curr.slice()); <span class="comment">// 将当前子集的深拷贝加入结果数组</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = first; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; first &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 一开始写成了 i&gt;0 结果总是不对 后来知道每次加元素是从 first 开始 不是 0 开始</span></span><br><span class="line">      <span class="comment">// 每次当作为起始点往数组加入元素时,不能加入与上一个元素相同的元素</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curr.push(nums[i]);</span><br><span class="line">    recur(depth, i + <span class="number">1</span>, len, curr, res, nums);</span><br><span class="line">    curr.pop(); <span class="comment">// 回溯 回到初始状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="[93] Restore IP Addresses"></a>[93] Restore IP Addresses</h4><blockquote>
<p>Given a string <code>s</code> containing only digits. Return all possible valid IP addresses that can be obtained from <code>s</code>. You can return them in <strong>any</strong> order.</p>
<p>A <strong>valid IP address</strong> consists of exactly four integers, each integer is between <code>0</code> and <code>255</code>, separated by single points and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are <strong>valid</strong> IP addresses and “0.011.255.245”, “192.168.1.312” and “<a href="mailto:192.168@1.1">192.168@1.1</a>“ are <strong>invalid</strong> IP addresses. </p>
</blockquote>
<p>就是大概有想法但是却实现不出来, 说明思路还不是很清楚, 需要画树状图帮助自己理解.</p>
<p>多画树状图, 理解回溯过程. 被这道题折磨好久.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 合法的url的条件:</span></span><br><span class="line"><span class="comment"> * 将字符串分为四个部分, 每个部分的数字[0,255], 不超过3位</span></span><br><span class="line"><span class="comment"> * 中间的数字不能以0开头</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="comment">// 字符串长度不够则直接返回空数组</span></span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">12</span> || len &lt; <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> ip = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  dfs(res, ip, start, s);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>res 存储合法ip</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>ip 存储ip的每一段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>start 剩余需要继续递归的子串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>s </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dfs = <span class="function">(<span class="params">res, ip, start, s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在开始切割子串之前, 判断ip是否符合题意</span></span><br><span class="line">  <span class="comment">// s 已经遍历完毕且ip是四段的话, 该ip可以进结果数组了</span></span><br><span class="line">  <span class="keyword">if</span> (ip.length == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.length) &#123;</span><br><span class="line">      res.push(ip.join(<span class="string">'.'</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未遍历完s ip已经4段 该ip不合题意</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; s.length) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// s 已经遍历完了,但是ip不到四段,返回</span></span><br><span class="line">  <span class="keyword">if</span> (ip.length &lt; <span class="number">4</span> &amp;&amp; start == s.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从每个起始位置开始切割都是三个长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> l = <span class="number">1</span>; l &lt;= <span class="number">3</span>; l++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start + l &gt; s.length) <span class="keyword">return</span>; <span class="comment">// 索引超过边界</span></span><br><span class="line">    <span class="keyword">if</span> ((l == <span class="number">2</span> || l == <span class="number">3</span>) &amp;&amp; s[start] == <span class="string">'0'</span>) <span class="keyword">return</span>; <span class="comment">// 2/3子串以0开头</span></span><br><span class="line">    <span class="keyword">let</span> part = s.substring(start, start + l); <span class="comment">// 切割子串</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>(part) &gt; <span class="number">255</span>) <span class="keyword">return</span>; <span class="comment">// 子串不符合条件 这里已经l==3了 continue和return是一样的效果</span></span><br><span class="line">    <span class="comment">// part符合条件</span></span><br><span class="line">    ip.push(part.slice());</span><br><span class="line">    <span class="comment">// 下次递归的子串的起始位置是start+l</span></span><br><span class="line">    dfs(res, ip, start + l, s);</span><br><span class="line">    ip.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="[77] Combinations"></a>[77] Combinations</h4><blockquote>
<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p>You may return the answer in <strong>any order</strong>.</p>
</blockquote>
<p>经过93题的经历, 这题要思路清晰很多.</p>
<p>大体思路是: 构造数组, 然后找子集的思路, 但是将不符合长度k的子集都剪枝了.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全排列的另一种形式, 除去长度不合适的组合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="comment">// 初始化数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    arr.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 目标:找到长度为k的子集</span></span><br><span class="line">  <span class="comment">// 约束:长度为k即停止</span></span><br><span class="line">  <span class="comment">// 选择:每次选择当前元素的下一个元素</span></span><br><span class="line">  <span class="comment">// 如何定义dfs start depth</span></span><br><span class="line">  <span class="keyword">let</span> res = [], curr = [], start = <span class="number">0</span>, depth = <span class="number">0</span>;</span><br><span class="line">  dfs(arr, depth, k, res, curr, start, n);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs = <span class="function">(<span class="params">arr, depth, k, res, curr, start, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth === k) &#123;</span><br><span class="line">    res.push(curr.slice());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; n; i++) &#123;</span><br><span class="line">    curr.push(arr[i]);</span><br><span class="line">    dfs(arr, depth + <span class="number">1</span>, k, res, curr, i + <span class="number">1</span>, n);</span><br><span class="line">    curr.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic-Programming</title>
    <url>/2020/08/04/Dynamic-Programming/</url>
    <content><![CDATA[<h4 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="[62] Unique Paths"></a>[62] Unique Paths</h4><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
</blockquote>
<h5 id="Solution-1-排列组合"><a href="#Solution-1-排列组合" class="headerlink" title="Solution 1: 排列组合"></a>Solution 1: 排列组合</h5><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p>
<p>比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。</p>
<p>所以结果= (m+n−2)!/((m−1)!*(n-1)!).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1 : 排列组合</span></span><br><span class="line"><span class="comment">// 使用数学上的排列组合计算公式</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths1 = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 起点到终点一共需要走 m-1+n-1 = m+n-2 步</span></span><br><span class="line">  <span class="comment">// 其中从总步数中选出向右的 m-1 步</span></span><br><span class="line">  <span class="keyword">return</span> jc(m + n - <span class="number">2</span>) / (jc(m - <span class="number">1</span>) * jc(n - <span class="number">1</span>))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jc = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    res = res * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Solution-2-动态规划"><a href="#Solution-2-动态规划" class="headerlink" title="Solution 2: 动态规划"></a>Solution 2: 动态规划</h5><p>关键在于写出状态转移方程.很多解法用的是数组,我这里用的是对象存储.</p>
<p>数组的空间O(mn)可优化为O(n).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 2 : 动态规划</span></span><br><span class="line"><span class="comment">// 假设到点(i,j)的所有路径数表示为 dp(i,j)</span></span><br><span class="line"><span class="comment">// 状态转移方程</span></span><br><span class="line"><span class="comment">// dp(i,j) = dp(i-1,j) + dp(i,j-1)</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths2 = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 只能向右或向下</span></span><br><span class="line">  <span class="comment">// 所以到达边界的点的方法数=1</span></span><br><span class="line">  dp[key(<span class="number">0</span>, <span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dp[key(i, <span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    dp[key(<span class="number">0</span>, j)] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 时间复杂度O(mn)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      dp[key(i, j)] = dp[key(i - <span class="number">1</span>, j)] + dp[key(i, j - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[key(m - <span class="number">1</span>, n - <span class="number">1</span>)]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key = <span class="function">(<span class="params">i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="string">'/'</span> + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="[63] Unique Paths II"></a>[63] Unique Paths II</h4><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
</blockquote>
<p>这里需要修改状态转移方程, 就是, 在计算某一点可到达的路径数时, 如果这一点有障碍, 则为0, 否则按照原来的等式计算.</p>
<p>在初始化到达边缘点的路径数时, 也要考虑障碍的情况.</p>
<p>感觉动态规划主要有两个过程, 重点还是<strong>分析清楚过程</strong>:</p>
<ol>
<li><strong>初始化数据</strong></li>
<li><strong>正确的动态规划方程</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span> (<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rowNum = obstacleGrid.length;</span><br><span class="line">  <span class="keyword">let</span> colNum = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">let</span> dp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> flag1 = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 考虑障碍的情况</span></span><br><span class="line">    <span class="comment">// 边缘一有障碍, 则后面所有点的可到达路径数均为0</span></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> t = i; t &lt; rowNum; t++) &#123;</span><br><span class="line">        dp[key(t, <span class="number">0</span>)] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flag1 = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[key(i, <span class="number">0</span>)] = (flag1 == <span class="literal">true</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> flag2 = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> t = j; t &lt; colNum; t++) &#123;</span><br><span class="line">        dp[key(<span class="number">0</span>, t)] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flag2 = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[key(<span class="number">0</span>, j)] = (flag2 == <span class="literal">true</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">      <span class="comment">// 考虑障碍的动态规划方程</span></span><br><span class="line">      <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">        dp[key(i, j)] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        dp[key(i, j)] = dp[key(i - <span class="number">1</span>, j)] + dp[key(i, j - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(dp[key(rowNum - 1, colNum - 1)]);</span></span><br><span class="line">  <span class="keyword">return</span> dp[key(rowNum - <span class="number">1</span>, colNum - <span class="number">1</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key = <span class="function">(<span class="params">i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="string">'/'</span> + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Search</title>
    <url>/2020/08/03/Binary-Search/</url>
    <content><![CDATA[<h4 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="[35] Search Insert Position"></a>[35] Search Insert Position</h4><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
</blockquote>
<h6 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h6><p>我是哪里来的if-else怪物(为了边界情况, 疯狂if-else), 代码一点都不优雅, 考点应该是折半查找, 被我写成这个样子. 不说了, 我去找优雅解法去了…..</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">    end = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> mid = start + index(end - start);</span><br><span class="line">  <span class="comment">// 数组len=1</span></span><br><span class="line">  <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> start</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123; <span class="comment">// 数组len=2</span></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">      <span class="keyword">return</span> end + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == nums[start])</span><br><span class="line">      <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> end</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 数组len&gt;2</span></span><br><span class="line">    <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target:'</span> + target + <span class="string">'&lt;'</span> + <span class="string">"nums["</span> + mid + <span class="string">"]:"</span> + nums[mid]);</span><br><span class="line">        end = mid;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (target == nums[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mid = start + index(end - start);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target:'</span> + target + <span class="string">'&gt;'</span> + <span class="string">"nums["</span> + mid + <span class="string">"]:"</span> + nums[mid]);</span><br><span class="line">        start = mid;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (target == nums[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end + <span class="number">1</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mid = start + index(end - start);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(mid);</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = <span class="function">(<span class="params">gap</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (gap % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> gap / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (gap + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="solution-on-the-Internet"><a href="#solution-on-the-Internet" class="headerlink" title="solution on the Internet"></a>solution on the Internet</h6><p>参考网上的解法, 优化了一下, 感觉稍微简洁了些, 这里的mid取值是靠左的.所以一开始判断end值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">    <span class="keyword">return</span> end + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// if (target &lt; nums[start])</span></span><br><span class="line">  <span class="comment">//   return 0;</span></span><br><span class="line">  <span class="comment">// if (target == nums[start])</span></span><br><span class="line">  <span class="comment">//   return start</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">    mid = start + <span class="built_in">parseInt</span>((end - start) / <span class="number">2</span>); <span class="comment">// parseInt 直接丢弃小数部分, 保留整数部分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mid: '</span>, mid, <span class="string">' start: '</span>, start, <span class="string">' end: '</span>, end);</span><br><span class="line">    <span class="keyword">if</span> (target == nums[start])</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    <span class="keyword">if</span> (target == nums[end])</span><br><span class="line">      <span class="keyword">return</span> end;</span><br><span class="line">    <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// console.log('target &gt; mid', 'start: ', start);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      end = mid;</span><br><span class="line">      <span class="comment">// console.log('target &lt; mid', 'end: ', end);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Notes</title>
    <url>/2020/09/01/JavaScript-Notes/</url>
    <content><![CDATA[<h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h3><h4 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">'hello'</span>; <span class="comment">// 字面量创建</span></span><br><span class="line"><span class="keyword">let</span> thing = <span class="number">98</span>; <span class="comment">// 任何可以转换成字符串的值</span></span><br><span class="line"><span class="comment">/* String 函数 生成或者将值转换为字符串 */</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>(thing); <span class="comment">// 将thing转换为原始字符串</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="keyword">new</span> <span class="built_in">String</span>(thing); <span class="comment">// 新建String对象, 并存储thing的字符串表示</span></span><br><span class="line"><span class="built_in">console</span>.log(s1, <span class="keyword">typeof</span> s1); <span class="comment">// hello string</span></span><br><span class="line"><span class="built_in">console</span>.log(s2, <span class="keyword">typeof</span> s2); <span class="comment">// 98 string</span></span><br><span class="line"><span class="built_in">console</span>.log(s3, <span class="keyword">typeof</span> s3); <span class="comment">// [String: '98'] object</span></span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>length</code></p>
<p>字符串长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><code>constructor</code></p>
<p>对创建该对象的函数的引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.constructor); <span class="comment">// [Function: String]</span></span><br></pre></td></tr></table></figure>



<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>toUpperCase</code>  </p>
<p>字符串变大写</p>
<p><code>toLowerCase</code>  </p>
<p>字符串变小写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hello'</span>, t = <span class="string">'JINLING'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.toUpperCase()); <span class="comment">// HELLO</span></span><br><span class="line"><span class="built_in">console</span>.log(t.toLowerCase()); <span class="comment">// jinling</span></span><br></pre></td></tr></table></figure>

<p><code>split</code> </p>
<p>根据分隔符将字符串分割为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hel,l,o'</span>;</span><br><span class="line"><span class="comment">// 不切割 整个字符串视作数组的一个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split());  <span class="comment">// [ 'hel,l,o' ]</span></span><br><span class="line"><span class="comment">// 每个字符都是数组中的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split(<span class="string">''</span>));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"> 'h', 'e', 'l',</span></span><br><span class="line"><span class="comment"> ',', 'l', ',',</span></span><br><span class="line"><span class="comment"> 'o'</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 以逗号分割</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split(<span class="string">','</span>)); <span class="comment">// [ 'hel', 'l', 'o' ]</span></span><br></pre></td></tr></table></figure>



<h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h3><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = []; <span class="comment">// 字面</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 不固定长度</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// 固定长度</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr0, arr1, arr2, arr3); <span class="comment">// [] [] [ &lt;5 empty items&gt; ] [ 1, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p><code>length</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">// 字面</span></span><br><span class="line"><span class="built_in">console</span>.log(arr0.length); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><code>constructor</code></p>
<p>返回创建该对象的函数的引用, 因为js的一切变量都是对象, 是对象就有其构造函数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">if</span> (test.constructor==<span class="built_in">Array</span>)&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(test.constructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: function Array() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><code>sort</code></p>
<p>对数组元素进行排序, 默认是字符串顺序.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照字母顺序排序 默认</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'good'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'google'</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<p>添加比值函数, 使得能对<strong>数字进行排序</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用比值函数</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">76</span>, <span class="number">91</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr); </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  0,  1, 12,  3, 34,</span></span><br><span class="line"><span class="comment">  7, 76,  9, 91</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比值函数 倒序</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">76</span>, <span class="number">91</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  91, 76, 34, 12, 9,</span></span><br><span class="line"><span class="comment">   7,  3,  1,  0</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比值函数 正序</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">76</span>, <span class="number">91</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(arr); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">   0,  1,  3,  7, 9,</span></span><br><span class="line"><span class="comment">  12, 34, 76, 91</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>join</code> </p>
<p><code>toString</code> 所有 JavaScript 对象都拥有<code>toString()</code>方法</p>
<p>数组所有元素组成字符串, 可以指定分隔符.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr0.join(), arr0.toString()); <span class="comment">// 1,2,3,4  1,2,3,4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr0.join(<span class="string">'*'</span>)); <span class="comment">// 1*2*3*4</span></span><br></pre></td></tr></table></figure>

<p><code>slice</code></p>
<p>根据下标获取数组的一部分, 不改变原有数组, 返回新数组.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.slice(<span class="number">3</span>), arr1.slice(<span class="number">2</span>,<span class="number">4</span>), arr1);</span><br><span class="line"><span class="comment">// output: [ 4, 5 ] [ 3, 4 ] [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p><code>concat</code></p>
<p>拼接数组成一个新数组, 不改变原来的数组.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr0.concat(arr1), arr0, arr1);</span><br><span class="line"><span class="comment">// output: [ 1, 2, 3, 4, 5, 6 ] [ 1, 2, 3, 4 ] [ 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<p><code>pop</code></p>
<p>删除数组的最后一个元素并返回该元素. 空数组返回<code>undefined</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr0.pop(), arr0);</span><br><span class="line"><span class="comment">// output: 4 [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.pop(), arr1);</span><br><span class="line"><span class="comment">// output: undefined []</span></span><br></pre></td></tr></table></figure>

<p><code>shift</code></p>
<p>删除并返回数组的第一个元素, 改变原有数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.shift(), arr1);</span><br><span class="line"><span class="comment">// 1 [ 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><code>unshift</code></p>
<p>向数组的开头添加元素并返回现有长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.unshift(<span class="number">9</span>), arr1);</span><br><span class="line"><span class="comment">// 6 [ 9, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p><code>push</code></p>
<p>向数组末尾添加元素并返回数组现有长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.push(<span class="number">4</span>), arr1);</span><br><span class="line"><span class="comment">// output: 4 [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<p><code>reverse</code></p>
<p>颠倒数组中元素顺序, 改变原有数组.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.reverse(), arr1);</span><br><span class="line"><span class="comment">// output: [ 3, 2, 1 ] [ 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure>

<p><code>splice</code> 推荐使用该方法删除数组元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">1</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>); <span class="comment">// 从数组下标为2的位置开始删除1个元素,再插入2个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 'ok', 'fine', 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不留空洞地删除元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line">arr.splice(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 从下标为3的位置开始, 删除2个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 'ok', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p><code>delete</code>  JS运算符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr); <span class="comment">// 留下了空洞</span></span><br><span class="line"><span class="comment">// undefined [ &lt;1 empty item&gt;, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>





<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>Array.forEach()</p>
<blockquote>
<p>对数组的每个元素均执行一次函数(回调函数)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 该函数的参数1为数组元素,参数2为数组元素下标,参数3为该数组本身</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  s += (val + <span class="string">'/'</span> + index + <span class="string">' '</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// 1/0 2/1 ok/2 fine/3 you/4 bye/5</span></span><br></pre></td></tr></table></figure>

<p>Array.map()</p>
<blockquote>
<p>对数组的每个元素均执行函数, 对其做一些处理, 来生成新数组. <strong>不改变原数组</strong>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.map(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> val + <span class="string">'*'</span> + index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 原数组不变</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2, arr);</span><br><span class="line"><span class="comment">// [ '1*0', '2*1', 'ok*2', 'fine*3', 'you*4', 'bye*5' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p>Array.filter()</p>
<blockquote>
<p>对数组的每个元素均执行函数, 筛选符合条件的元素来生成新数组.<strong>不改变原数组</strong>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.filter(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2, arr);</span><br><span class="line"><span class="comment">// [ 'ok', 'fine', 'you', 'bye' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p>Array.reduce()</p>
<blockquote>
<p>参数<code>total</code> 默认是数组的第一个元素, 可以设置初始值.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'bye'</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"total="</span>, total, val, index); <span class="comment">// 从index=1开始打印</span></span><br><span class="line">  <span class="keyword">return</span> total + <span class="string">'*'</span> + val;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">total= bye hi 1</span></span><br><span class="line"><span class="comment">total= bye*hi ok 2</span></span><br><span class="line"><span class="comment">total= bye*hi*ok fine 3</span></span><br><span class="line"><span class="comment">total= bye*hi*ok*fine you 4</span></span><br><span class="line"><span class="comment">total= bye*hi*ok*fine*you bye 5</span></span><br><span class="line"><span class="comment">bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置total初始值</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'bye'</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + <span class="string">'*'</span> + val;</span><br><span class="line">&#125;, <span class="string">"this is :"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// this is :*bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p>Array.reduceRight()</p>
<blockquote>
<p>类似于<code>Array.reduce()</code>, 只不过是从右往左遍历元素.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'bye1'</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye2'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduceRight(<span class="function">(<span class="params">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + <span class="string">'*'</span> + val;</span><br><span class="line">&#125;, <span class="string">"this is res:"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// this is res:*bye2*you*fine*ok*hi*bye1 [ 'bye1', 'hi', 'ok', 'fine', 'you', 'bye2' ]</span></span><br></pre></td></tr></table></figure>

<p>Array.every()</p>
<blockquote>
<p>检查数组中的元素是否都符合条件, 都符合才返回true, 否则返回false.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有元素不符合条件 false</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.every(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// false [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有元素均符合条件 true</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.every(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'number'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// true [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>Array.some()</p>
<blockquote>
<p>检查是否有元素符合条件, 有则返回true, 没有则返回false.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有元素符合条件 true</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.some(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// true [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有元素均不符合条件 false</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.some(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// false [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>Array.indexOf()</p>
<blockquote>
<p>找到给定元素在数组中的位置, 没有则返回-1, 找到则返回元素下标.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找不到 -1, 找到就下标</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.indexOf(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> res2 = arr.indexOf(<span class="string">'how'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1, res2); <span class="comment">// -1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素多次出现 返回第一次出现的位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>];</span><br><span class="line"><span class="keyword">let</span> res2 = arr.indexOf(<span class="string">'Bob'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定搜索位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>];</span><br><span class="line"><span class="keyword">let</span> res2 = arr.indexOf(<span class="string">'Bob'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索起始位置可以是负值</span></span><br><span class="line"><span class="comment">// 负值是从数组末尾给定位置开始搜索, 直至末尾.</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.indexOf(<span class="string">'Bob'</span>, <span class="number">-1</span>), <span class="comment">// 从倒数第一个位置开始, 搜索不到</span></span><br><span class="line">    res2 = arr.indexOf(<span class="string">'Bob'</span>, <span class="number">-2</span>); <span class="comment">// 从倒数第二个位置开始搜索, 是可以检索到的, 返回正数下标</span></span><br><span class="line"><span class="built_in">console</span>.log(res1, res2); <span class="comment">// -1 5</span></span><br></pre></td></tr></table></figure>

<p>Array.lastIndexOf()</p>
<blockquote>
<p>与上一个类似, 只是从数组末尾开始检索.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出现两次Bob, 但是返回了从右往左的第一个.</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.lastIndexOf(<span class="string">'Bob'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定搜索起始位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.lastIndexOf(<span class="string">'Bob'</span>, <span class="number">-3</span>); <span class="comment">// 从倒数第三个元素开始往左搜索, 返回匹配的第一个元素的下标</span></span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>Array.find()</p>
<blockquote>
<p>返回符合条件的第一个元素</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'good'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.find(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> val.length &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// good</span></span><br></pre></td></tr></table></figure>

<p>Array.findIndex()</p>
<blockquote>
<p>返回符合条件的第一个元素<strong>下标</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'good'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.findIndex(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> val.length &gt; <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h3 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象 Object"></a>对象 Object</h3><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><blockquote>
<p>部署在object对象自身的方法</p>
</blockquote>
<p><code>Object.values</code> 获取对象的所有key, 输出类型为数组</p>
<p><code>Object.keys</code> 获取对象的所有value, 输出类型为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">key1</span>:<span class="string">'val1'</span>, <span class="attr">key2</span>:<span class="string">'val2'</span>, <span class="attr">key3</span>:<span class="string">'val3'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// [ 'val1', 'val2', 'val3' ]</span></span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyNames</code> 也是返回对象的所有属性名, 但是还会返回不可枚举的属性; 可枚举属性方面, 与<code>Object.keys</code>相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可枚举属性 二者不同</span></span><br><span class="line"><span class="keyword">let</span> obj1 = [<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'jinling'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj1)); <span class="comment">// [ '0', '1', '2' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj1)); <span class="comment">// [ '0', '1', '2', 'length' ] 包含不可枚举属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可枚举属性 二者相同</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">key1</span>:<span class="string">'val1'</span>, <span class="attr">key2</span>:<span class="string">'val2'</span>, <span class="attr">key3</span>:<span class="string">'val3'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">// [ 'key1', 'key2', 'key3' ]</span></span><br></pre></td></tr></table></figure>



<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p><code>Object.hasOwnProperty</code>判断对象是否拥有某项属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">key1</span>:<span class="string">'val1'</span>, <span class="attr">key2</span>:<span class="string">'val2'</span>, <span class="attr">key3</span>:<span class="string">'val3'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'key2'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>特殊的函数, 由<strong>类表达式</strong>和<strong>类声明</strong>组成</p>
<h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><ol>
<li><p>类声明 带有<code>class</code>关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类需要先声明 再使用 不像函数声明会提升</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类表达式 可以具名或者匿名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello.name); <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名类</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="class"><span class="keyword">class</span> <span class="title">hello2</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello.name); <span class="comment">// hello2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传统的基于函数的类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  speak()&#123;</span><br><span class="line">    <span class="keyword">super</span>.speak();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' barks.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog(<span class="string">'cookie'</span>)</span><br><span class="line">d.speak(); </span><br><span class="line"><span class="comment">// cookie makes a noise.</span></span><br><span class="line"><span class="comment">// cookie barks.</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="类体和方法定义"><a href="#类体和方法定义" class="headerlink" title="类体和方法定义"></a>类体和方法定义</h4><p><code>constructor</code> </p>
<p>构造函数, 一种特殊方法, 创建和初始化一个由class创建的对象. </p>
<p>构造函数可以使用<code>super</code>调用父类的构造函数.</p>
<h4 id="extends创建子类"><a href="#extends创建子类" class="headerlink" title="extends创建子类"></a><code>extends</code>创建子类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  speak () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> make a noise`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, sex) &#123;</span><br><span class="line">    <span class="comment">// 调用超类构造函数并传入name参数</span></span><br><span class="line">    <span class="comment">// 必须先super 然后才能使用this</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  speak () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span> and barks`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog1(<span class="string">'cookie'</span>, <span class="string">'girl'</span>);</span><br><span class="line">d.speak(); <span class="comment">// cookie is girl and barks</span></span><br></pre></td></tr></table></figure>



<h3 id="操作符-typeof"><a href="#操作符-typeof" class="headerlink" title="操作符 typeof"></a>操作符 typeof</h3><h4 id="判断变量数据类型"><a href="#判断变量数据类型" class="headerlink" title="判断变量数据类型"></a>判断变量数据类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="comment">// 通用数据类型</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="string">'jinling'</span> + <span class="string">'\n'</span> +  <span class="comment">// string</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="number">23</span> + <span class="string">'\n'</span> + <span class="comment">// number</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="literal">true</span> + <span class="string">'\n'</span> +  <span class="comment">// boolean</span></span><br><span class="line">	<span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] + <span class="string">'\n'</span> + <span class="comment">// object</span></span><br><span class="line">	<span class="keyword">typeof</span> &#123;<span class="attr">k1</span>:<span class="string">'v1'</span>, <span class="attr">k2</span>:<span class="string">'v2'</span>&#125; + <span class="string">'\n'</span> <span class="comment">// object</span></span><br><span class="line">  <span class="comment">// 特殊字符类型</span></span><br><span class="line">  <span class="keyword">typeof</span> <span class="literal">null</span> + <span class="string">'\n'</span> + <span class="comment">// object</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="literal">undefined</span> + <span class="string">'\n'</span> + <span class="comment">// undefined</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="literal">NaN</span> + <span class="string">'\n'</span> <span class="comment">// number</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined与null值相同,但类型不同</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>===<span class="literal">null</span>, <span class="literal">undefined</span>==<span class="literal">null</span>); <span class="comment">// false true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数组可以用 Array.isArray</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(&#123;<span class="attr">k1</span>:<span class="string">'v1'</span>, <span class="attr">k2</span>:<span class="string">'v2'</span>&#125;)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="undefined-与-null-区别"><a href="#undefined-与-null-区别" class="headerlink" title="undefined 与 null 区别"></a>undefined 与 null 区别</h4><p><code>undefined</code>  : 一般表示某个变量被声明过, 但从未被赋过值, 则默认赋值<code>undefined</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">// undefined undefined</span></span><br></pre></td></tr></table></figure>

<p><code>null</code> : 表示主动释放指向对象的引用.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 释放指向数组的引用</span></span><br></pre></td></tr></table></figure>



<h3 id="关键字-this"><a href="#关键字-this" class="headerlink" title="关键字 this"></a>关键字 this</h3><blockquote>
<p>js中this随着执行环境的变化而变化</p>
</blockquote>
<h4 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的<code>this</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	size : <span class="number">14</span>,</span><br><span class="line">	color: <span class="string">'red'</span>,</span><br><span class="line">	getColor: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'颜色是'</span> + <span class="keyword">this</span>.color</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该实例中, this指向getColor方法所在的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getColor) <span class="comment">// [Function: getColor]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getColor()) <span class="comment">// 颜色是red (加括号表示调用方法)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法中的this单独打印, 会打印出所属对象的内容</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName  : <span class="string">"John"</span>,</span><br><span class="line">  lastName   : <span class="string">"Doe"</span>,</span><br><span class="line">  id         : <span class="number">5566</span>,</span><br><span class="line">  myFunction : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.myFunction()); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  firstName: 'John',</span></span><br><span class="line"><span class="comment">  lastName: 'Doe',</span></span><br><span class="line"><span class="comment">  id: 5566,</span></span><br><span class="line"><span class="comment">  myFunction: [Function: myFunction]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="单独使用this"><a href="#单独使用this" class="headerlink" title="单独使用this"></a>单独使用<code>this</code></h4><p>无论有无严格模式, <code>this</code>始终指向全局对象. 浏览器中, 全局对象为<code>[object Window]</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 'use strict'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="函数中使用this"><a href="#函数中使用this" class="headerlink" title="函数中使用this"></a>函数中使用<code>this</code></h4><p>函数中, 默认<code>this</code>指向全局对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>严格模式下不允许默认绑定, 所以函数中的<code>this</code>为<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFunction()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li><p>避免使用 全局变量 <code>new</code> <code>===</code> <code>eval()</code></p>
</li>
<li><p>所有声明放在脚本或者函数的顶部, <strong>顶部声明, 稍后使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在顶部声明</span></span><br><span class="line"><span class="keyword">var</span> firstName, lastName, price, discount, fullPrice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍后使用</span></span><br><span class="line">firstName = <span class="string">"Bill"</span>;</span><br><span class="line">lastName = <span class="string">"Gates"</span>;</span><br><span class="line"></span><br><span class="line">price = <span class="number">19.90</span>;</span><br><span class="line">discount = <span class="number">0.10</span>;</span><br><span class="line"></span><br><span class="line">fullPrice = price * <span class="number">100</span> / discount;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明变量时同时初始化</p>
</li>
<li><p>将数值/字符串/布尔值声明为原始值而非对象, 否则会拖慢速度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">'bill'</span> <span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'bill'</span>) <span class="comment">// 对象</span></span><br><span class="line"><span class="built_in">console</span>.log(x===y); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请勿使用 new Object()</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">推荐使用</th>
<th align="center">不建议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{}</td>
<td align="center">new Object()</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">new Array()</td>
</tr>
<tr>
<td align="center">function (){}</td>
<td align="center">new Function()</td>
</tr>
<tr>
<td align="center">“”</td>
<td align="center">new String()</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">new Number()</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">new Boolean()</td>
</tr>
<tr>
<td align="center">/()/</td>
<td align="center">new RegExp()</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>意识到自动类型转换, 变量可以通过赋值改变其数据类型, 变量可包含不同的数据类型.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'hello'</span></span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为函数中的参数设置默认值, <code>undefined</code> 会破坏代码</p>
</li>
<li><p>用<code>default</code>来结束<code>switch</code>.</p>
</li>
</ol>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><blockquote>
<p>原因</p>
</blockquote>
<p>js代码中会出现错误, 由于编写代码/编译/用户输入等各种各样的原因.</p>
<blockquote>
<p>处理</p>
</blockquote>
<p>发生错误时, js引擎会停止并生成一个错误消息.</p>
<p>try与catch成对出现, finally是最后一定会执行的语句(可以没有).</p>
<p>throw抛出错误, 实际上就是抛出一个表示错误信息的字符串s, 因此可以自定义错误.</p>
<p>在catch中可以捕获s,实际上就是可以获得s的值并打印出来.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="string">''</span>) <span class="keyword">throw</span> <span class="string">'is kong'</span></span><br><span class="line">    <span class="keyword">if</span> (x === <span class="string">'1'</span>) <span class="keyword">throw</span> <span class="string">'is 1'</span></span><br><span class="line">    <span class="keyword">if</span> (x === <span class="string">'2'</span>) <span class="keyword">throw</span> <span class="string">'is 2'</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'1'</span>); <span class="comment">// is 1</span></span><br><span class="line">test(<span class="string">''</span>); <span class="comment">// is kong</span></span><br></pre></td></tr></table></figure>



<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><blockquote>
<p>操作</p>
</blockquote>
<p>设置断点, 检查变量值, 浏览器内置调试器(按下F12, 选择<code>console</code>)</p>
<blockquote>
<p><code>debugger</code>关键字</p>
</blockquote>
<p>代码会在<code>debugger</code>行停下, 并执行调试函数. 没有调试函数则不起作用.</p>
<p>与在调试工具中设置断点效果一样.</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><blockquote>
<p>原因</p>
</blockquote>
<p><code>use strict</code> </p>
<p>消除js语法的不合理之处, 保证代码安全; 增加编译效率;</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>只能放在脚本或者函数的开头</p>
<blockquote>
<p>具体内容</p>
</blockquote>
<ul>
<li>禁止使用未定义/声明的变量</li>
<li>禁止删除变量/函数</li>
<li>禁止变量重名</li>
<li>禁止使用八进制/转义字符</li>
<li>禁止对只读属性赋值</li>
<li>禁止删除不能删除的属性, 比如prototype</li>
<li>禁止变量名为eval/arguments</li>
<li>禁止使用右侧类似语句 with (Math){x = cos(2)};</li>
<li>禁止在作用域eval创建的变量被使用</li>
<li>禁止this指向全局对象</li>
</ul>
]]></content>
      <tags>
        <tag>-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linked-list</title>
    <url>/2020/09/11/Linked-list/</url>
    <content><![CDATA[<h4 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="[2] Add Two Numbers"></a>[2] Add Two Numbers</h4><blockquote>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
</blockquote>
<p>复杂的数据结构是我的超级短板. 但是也算勉强看懂了js是如何表示链表的.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 这个链表的存储结构是嵌套的, 即next指向的是嵌套的.</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义存储想关节点的变量</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> lastNode = result;</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">  <span class="keyword">let</span> val = <span class="number">0</span>; <span class="comment">// 相加之后赋给当前位置的值</span></span><br><span class="line">  <span class="comment">// 当l1或者l2任何一方有值时, 都需要进行相加</span></span><br><span class="line">  <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">    <span class="comment">// 获取两个链表的初始值</span></span><br><span class="line">    <span class="keyword">let</span> x = l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">    <span class="keyword">let</span> y = l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">    <span class="comment">// 两者相加</span></span><br><span class="line">    <span class="keyword">let</span> num = x + y + carry;</span><br><span class="line">    carry = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>); <span class="comment">// 商</span></span><br><span class="line">    val = num % <span class="number">10</span>; <span class="comment">// 相加之后赋给当前位置的值</span></span><br><span class="line">    <span class="comment">// 新建节点添加到链表末尾</span></span><br><span class="line">    lastNode.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    <span class="comment">// 最后节点位置更新</span></span><br><span class="line">    lastNode = lastNode.next;</span><br><span class="line">    <span class="comment">// 进行下一位置的加法</span></span><br><span class="line">    <span class="keyword">if</span> (l1 !== <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">    <span class="keyword">if</span> (l2 !== <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当两个加数位数都加完了</span></span><br><span class="line">  <span class="comment">// 但是仍然可能会有进位的可能</span></span><br><span class="line">  <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">    lastNode.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">示例结果</span></span><br><span class="line"><span class="comment">====result.next</span></span><br><span class="line"><span class="comment">ListNode &#123;</span></span><br><span class="line"><span class="comment">  val: 7,</span></span><br><span class="line"><span class="comment">  next: ListNode &#123;</span></span><br><span class="line"><span class="comment">    val: 0,</span></span><br><span class="line"><span class="comment">    next: ListNode &#123;</span></span><br><span class="line"><span class="comment">      val: 8,</span></span><br><span class="line"><span class="comment">      next: null</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="[21] Merge Two Sorted Lists"></a>[21] Merge Two Sorted Lists</h4><blockquote>
<p>Merge two sorted linked lists and return it as a new <strong>sorted</strong> list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<p>解题的重点在于, 一直将l1和l2的链表头作比较, 不断将较小的node加入结果链表, 直至l1或者l2为空, 说明遍历结束. 把不为空的链表剩余的部分直接接入结果列表.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理有链表为空的情况</span></span><br><span class="line">  <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> curr = res;</span><br><span class="line">  <span class="comment">// 网上的做法好简洁</span></span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">      curr.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curr.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  curr.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="[24] Swap Nodes in Pairs"></a>[24] Swap Nodes in Pairs</h4><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
</blockquote>
<p>在交换链表的时候, 第一次交换需要记住链表头.</p>
<p>确定 <code>curr</code> 之后, 只有 <code>curr.next!=null</code> 时才有交换的必要, 否则说明交换到头了, 返回 <code>head</code> 即可.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 第一次交换的时候 需要记住链表头 后面就不需要了</span></span><br><span class="line">  <span class="comment">// 只有当 curr.next 也有值的时候, 才交换</span></span><br><span class="line">  <span class="comment">// 否则就直接返回</span></span><br><span class="line">  <span class="keyword">while</span> (curr &amp;&amp; curr.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = curr.next.next;</span><br><span class="line">    <span class="keyword">let</span> nextNode = curr.next;</span><br><span class="line">    nextNode.next = curr;</span><br><span class="line">    left.next = nextNode;</span><br><span class="line">    curr.next = temp;</span><br><span class="line">    left = curr;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">      head = nextNode;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="[61] Rotate List"></a>[61] Rotate List</h4><blockquote>
<p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> * 大体思路是: </span></span><br><span class="line"><span class="comment"> * 先计算出链表的长度len, 再将k与len进行比较, </span></span><br><span class="line"><span class="comment"> * k&gt;len的话, 将k中len的整数倍减去之后, 就是最后需要移动的元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rotateRight = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算链表长度</span></span><br><span class="line">  <span class="comment">// 此时right指向最后一个元素</span></span><br><span class="line">  <span class="keyword">let</span> left = head, right = head, len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (right.next) &#123;</span><br><span class="line">    right = right.next;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span> || k == len) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取余之后是实际上需要移动的元素</span></span><br><span class="line">  <span class="keyword">let</span> num = k % len;</span><br><span class="line">  <span class="comment">// 由于在计算链表长度的时候, right已经指向链表尾部</span></span><br><span class="line">  <span class="comment">// 左右指针间隔k-1个元素</span></span><br><span class="line">  <span class="comment">// 所以左指针需要向右移动len-num-1个位置</span></span><br><span class="line">  <span class="comment">// 具体的边界条件可以在测试中验证是否正确</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - num - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    left = left.next;</span><br><span class="line">  &#125;</span><br><span class="line">  right.next = head;</span><br><span class="line">  head = left.next;</span><br><span class="line">  left.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Greedy Algorithm</title>
    <url>/2020/08/03/Greedy-Algorithm/</url>
    <content><![CDATA[<h4 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="[45] Jump Game II"></a>[45] Jump Game II</h4><blockquote>
<p> Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p> Each element in the array represents your maximum jump length at that position.</p>
<p> Your goal is to reach the last index in the minimum number of jumps.</p>
</blockquote>
<p>贪心算法, 局部解得到最优解.</p>
<p>解题思路: 每次查找当前位置能够到达的位置中, 能跳到最远位置的位置A, 下次就跳到位置A, 然后再从位置A能到达的位置中, 再找能跳到最远位置的位置, 如此循环.</p>
<p>但是官方解答虽然简洁, 但是我不是看的很明白, 还是暂时先贴自己的直白解法吧.</p>
<img src="/2020/08/03/Greedy-Algorithm/45_fig1.png" class="" title="45_fig1">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于当前index, 每次在能跳到的范围内</span></span><br><span class="line"><span class="comment">// 跳到能跳到更远地方的index</span></span><br><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt;= len - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> nextPosMap = &#123; <span class="string">'index'</span>: <span class="number">0</span>, <span class="string">'maxIndex'</span>: <span class="number">0</span> + nums[<span class="number">0</span>] &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len;) &#123;</span><br><span class="line">    <span class="keyword">let</span> indexLimit = i + nums[i];</span><br><span class="line">    <span class="comment">// 在寻找下一步跳的位置时, 步数加一</span></span><br><span class="line">    step++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= indexLimit &amp;&amp; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j + nums[j] &gt; nextPosMap.maxIndex) &#123;</span><br><span class="line">        nextPosMap.index = j;</span><br><span class="line">        nextPosMap.maxIndex = j + nums[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index != i, 说明能跳到更远距离的index更新了, 这时才需要将当前节点 i 移到index</span></span><br><span class="line">    <span class="comment">// 其实肯定更新, 题目已经说了能跳到最后</span></span><br><span class="line">    <span class="comment">// 移动才算跳了一步</span></span><br><span class="line">    <span class="comment">// 同时能跳到的最远位置不要超过数组边界</span></span><br><span class="line">    <span class="comment">// 超过数组边界则表示步数已经能计算出来了 return</span></span><br><span class="line">    <span class="keyword">if</span> (nextPosMap.maxIndex &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">      i = nextPosMap.index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当最大位置能到达最后时, 返回step+1</span></span><br><span class="line">      <span class="comment">// 把跳到最后位置的一步也加上</span></span><br><span class="line">      <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="[55] Jump Game"></a>[55] Jump Game</h4><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
</blockquote>
<p>一开始尝试使用递归做法, 计算所有的可能性, 但是想也不是最好的解法, 最后很可能超时, 果不其然超时.</p>
<p>于是就去看网上解法, 这里的考点是<strong>贪心算法</strong>.</p>
<blockquote>
<p>贪心算法（又称贪婪算法）是指，在对<a href="https://baike.baidu.com/item/问题求解/6693186" target="_blank" rel="noopener">问题求解</a>时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解</p>
</blockquote>
<p>该题的大概思路是:</p>
<p>数组的第一个元素的值为 reach, 从数组的第一个元素开始, 每次计算在reach范围内的元素们所能到达的最远距离, 是否超过reach, 如果超过了, 就更新reach值为较大值. 直至reach的值超过lastIndex 返回 true.</p>
<img src="/2020/08/03/Greedy-Algorithm/largen-reach.png" class="" title="largen-reach">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 递归超时 使用贪心算法求解</span></span><br><span class="line"><span class="comment">// 局部能够到达的最大范围, 也是全局能够到达的最大范围</span></span><br><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reach = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 需要注意的点是,这里reach的值不一定就&gt;1, 所以i不一定就从1开始</span></span><br><span class="line">  <span class="comment">// 还是从0开始能够包含所有情况, 这么写因为有个特例 [0]</span></span><br><span class="line">  <span class="comment">// 同时注意限制 i 的范围, i 是指 reach 能够到达的位置范围, 不能超过 reach</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length &amp;&amp; i &lt;= reach; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + i &gt; reach) &#123;</span><br><span class="line">      reach = nums[i] + i;</span><br><span class="line">      <span class="comment">// console.log(reach);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当能到达的范围超过数组的最后 index 时, 返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (reach &gt;= nums.length - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 能到达的元素位置都尝试了, 但是没有一个位置可以到达最后一个元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Vue Learning</title>
    <url>/2020/07/29/Vue-Learning/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>String</title>
    <url>/2020/08/17/String/</url>
    <content><![CDATA[<h4 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="[43] Multiply Strings"></a>[43] Multiply Strings</h4><blockquote>
<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
</blockquote>
<p>算法答题思路就是模拟乘法累加的过程. </p>
<p>需要注意的是, js大数相加会丢失精度, 所以谨慎使用.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// js大数相加容易丢失精度, 有安全范围, 不行</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 整个算法的过程模拟乘法的计算过程</span></span><br><span class="line"><span class="comment"> * 用一个数组来存储每一步计算的结果</span></span><br><span class="line"><span class="comment"> * 时间复杂度: n^2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> multiply = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 有一个参数为0,则结果为0</span></span><br><span class="line">  <span class="keyword">if</span> (num1 == <span class="string">'0'</span> || num2 == <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">let</span> len1 = num1.length,</span><br><span class="line">    len2 = num2.length,</span><br><span class="line">    len = len1 + len2;</span><br><span class="line">  <span class="comment">// 数组存储计算结果 长度暂时为两个字符串长度之和</span></span><br><span class="line">  <span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="comment">// 初始化结果数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    resArr[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环反过来的原因是: 每次都是先拿因数1的每一位与因数2的同一位相乘</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">let</span> n2 = <span class="built_in">parseInt</span>(num2[j]);</span><br><span class="line">    <span class="comment">// 计算结果放置的位置</span></span><br><span class="line">    <span class="keyword">let</span> pos = len - len2 + j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> n1 = <span class="built_in">parseInt</span>(num1[i]);</span><br><span class="line">      <span class="keyword">let</span> res = n1 * n2;</span><br><span class="line">      addNext(res, resArr, pos, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 数位升高一位, 结果放置也要对应往左一位</span></span><br><span class="line">      pos--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 去除结果数组最左边的 0</span></span><br><span class="line">  <span class="keyword">while</span> (resArr[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">    resArr.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resArr.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag 为 1 表示要与当前位置数值相加</span></span><br><span class="line"><span class="comment">// 为 0 则表示不用相加</span></span><br><span class="line"><span class="keyword">var</span> addNext = <span class="function">(<span class="params">num, resArr, pos, flag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> posNum = num % <span class="number">10</span>, <span class="comment">// 取余数 置于当前位置</span></span><br><span class="line">    addNum = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>); <span class="comment">// floor 向下取整</span></span><br><span class="line"></span><br><span class="line">  resArr[pos] = (flag == <span class="number">1</span>) ? resArr[pos] + posNum : posNum;</span><br><span class="line">  resArr[pos - <span class="number">1</span>] += addNum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (resArr[pos] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 与当前数值相加之后, 数值大于10, 则当前仍然需要进位</span></span><br><span class="line">    <span class="comment">// 但是不需要再与当前位置数值相加了</span></span><br><span class="line">    addNext(resArr[pos], resArr, pos, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进位最多只会等于 10</span></span><br><span class="line">  <span class="keyword">if</span> (resArr[pos - <span class="number">1</span>] == <span class="number">10</span>) &#123;</span><br><span class="line">    addNext(resArr[pos - <span class="number">1</span>], resArr, pos - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Two Pointers</title>
    <url>/2020/07/30/Two-Pointers/</url>
    <content><![CDATA[<h4 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="[11] Container With Most Water"></a>[11] Container With Most Water</h4><blockquote>
<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>
</blockquote>
<h6 id="my-solution-Brute-Force"><a href="#my-solution-Brute-Force" class="headerlink" title="my solution : Brute Force"></a>my solution : Brute Force</h6><p>穷举所有面积的可能性,最后对面积进行排序,找到最大值.</p>
<p>中间一度尝试过将 <code>partArea</code> 组成数组先排序,也还是超时.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> partMaxSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> yVal = height[j] &lt; height[i] ? height[j] : height[i];</span><br><span class="line">      <span class="keyword">let</span> partArea = (j - i) * yVal;</span><br><span class="line">      partMaxSet.add(partArea);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> partMaxList = <span class="built_in">Array</span>.from(partMaxSet);</span><br><span class="line">  <span class="comment">// 数字降序排列</span></span><br><span class="line">  partMaxList.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a &#125;);</span><br><span class="line">  <span class="keyword">return</span> partMaxList[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// return Math.max.apply(null, partMaxList);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers"><a href="#Two-pointers" class="headerlink" title="Two pointers"></a>Two pointers</h6><p>采用双指针做法, 对于 S(i, j) 来说, 都是每次向里移动一步.</p>
<p>移动短板, 短板有可能变长, 面积有可能变大.</p>
<p>但是移动长板,  短板只会不变或者变小, 因为盛水的体积取决于短板, 所以面积只会不变或变小.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此算法需要证明</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> areaList = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">while</span> (j - i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">      <span class="comment">// 计算面积以短边为准</span></span><br><span class="line">      areaList.push((j - i) * height[i]);</span><br><span class="line">      <span class="comment">// 移动短边有可能获得更大面积</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      areaList.push((j - i) * height[j]);</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将可能的面积列表倒序排列,返回第一个</span></span><br><span class="line">  <span class="keyword">return</span> areaList.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Single pass.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant space is used.</li>
</ul>
<h4 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="[26] Remove Duplicates from Sorted Array"></a>[26] Remove Duplicates from Sorted Array</h4><blockquote>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
</blockquote>
<h6 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h6><p>借用 js 数组splice方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nums[j] == nums[i]) &#123;</span><br><span class="line">      nums.splice(j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers-1"><a href="#Two-pointers-1" class="headerlink" title="Two pointers"></a>Two pointers</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考双指针的方法, 优化了解法</span></span><br><span class="line"><span class="comment">// js的数组越界不会报错,只会得到 undefined 值</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="[27] Remove Element"></a>[27] Remove Element</h4><blockquote>
<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<h6 id="my-solution-1"><a href="#my-solution-1" class="headerlink" title="my solution"></a>my solution</h6><p>我自己的解法是利用了js数组操作的特性, 可以直接删除数组元素然后剩余元素位置前移的那种,比较方便,但是运行效果不咋地.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 使用 while 保证对于同一个i, 去除该位置所有与val相等的值</span></span><br><span class="line">    <span class="comment">// 不会遗漏由于删除数组元素而位置前移的新元素</span></span><br><span class="line">    <span class="keyword">while</span> (nums[i] == val) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers-2"><a href="#Two-pointers-2" class="headerlink" title="Two pointers"></a>Two pointers</h6><p>下面的解法是参考了示例解法, 双指针解法. 我觉得很精巧.</p>
<p>主要思路是, 将需要保留的元素都赋值给数组的前部分, 使用 i 标记赋值的位置.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution two pointers</span></span><br><span class="line"><span class="comment">// 只保留与val不同的元素</span></span><br><span class="line"><span class="comment">// 赋值操作比起splice的删除操作 肯定速度更快 至于额外的空间 需要看splice的实现有没有占用了</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      <span class="comment">// console.log("i=", i, " ", nums[i]);</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最差的情况应该是, 没有一个一样的, 但是遍历数组两遍而不是嵌套, 所以是 O(n).</p>
<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time complexity : O(n). Assume the array has a total of n<em>n</em> elements, both <em>i</em> and <em>j</em> traverse at most 2<em>n</em> steps.</li>
<li>Space complexity : O(1).</li>
</ul>
<h4 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="[15] 3Sum"></a>[15] 3Sum</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
</blockquote>
<p>数组排序后, 方便去除重复的元素 + 双指针移动不用嵌套且有方向可循.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 2 ：将数组排序后的双指针解法</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 将数组正序排列</span></span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 第一个数大于 0，肯定加起来和不为0了</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉重复元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> target = -nums[i];</span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">        res.push([nums[i], nums[left], nums[right]]);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 这里是否判断 left &lt; right 都没有那么重要, 因为最外面还会再判断一次</span></span><br><span class="line">        <span class="comment">// 但是加上判断可能会少做一次计算</span></span><br><span class="line">        <span class="comment">// 去掉重复元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">          right--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="[16] 3Sum Closest"></a>[16] 3Sum Closest</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
</blockquote>
<p>注意这里不是找相等, 而是保留最接近target的值, 实现方法类似.</p>
<p>与target比较, 由于一直在找最接近的, 比target小就left++, 比target大就right–, 总之就是不断靠近target.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> closest = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">let</span> diff = <span class="built_in">Math</span>.abs(closest - target);</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 由于数组是排好序的</span></span><br><span class="line">    <span class="comment">// 如果nums[i] * 3 &gt; target, 则 nums[i]+nums[i+1]+nums[i+2] 是接下来遍历的最小值</span></span><br><span class="line">    <span class="comment">// 后面差距只会越来越大</span></span><br><span class="line">    <span class="comment">// 将接下来最小值与当前最小值closest分别与target比较, 返回与target差距较小的那个值</span></span><br><span class="line">    <span class="comment">// 优化部分</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] * <span class="number">3</span> &gt; target) &#123;</span><br><span class="line">      <span class="keyword">let</span> cDiff = <span class="built_in">Math</span>.abs(closest - target);</span><br><span class="line">      <span class="keyword">let</span> tempMin = nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">let</span> tDiff = <span class="built_in">Math</span>.abs(tempMin - target);</span><br><span class="line">      <span class="keyword">return</span> cDiff &lt; tDiff ? closest : tempMin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针 遍历数组剩余元素</span></span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">      <span class="keyword">let</span> newDiff = <span class="built_in">Math</span>.abs(sum - target);</span><br><span class="line">      <span class="keyword">if</span> (newDiff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newDiff &lt; diff) &#123;</span><br><span class="line">        diff = newDiff;</span><br><span class="line">        closest = sum;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">        left++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log('closest:', closest);</span></span><br><span class="line">  <span class="keyword">return</span> closest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="[18] 4Sum"></a>[18] 4Sum</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em>in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
</blockquote>
<p>有了双指针, nSum都可解, 不过这个嵌套有点多,估计有更巧妙的解法.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> len = nums.length, res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; j &gt; i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">let</span> t = target - nums[i] - nums[j];</span><br><span class="line">      <span class="keyword">let</span> left = j + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> twoSum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (twoSum == t) &#123;</span><br><span class="line">          res.push([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">          <span class="comment">// 去重</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">            left++;</span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (twoSum &gt; t) &#123;</span><br><span class="line">          right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(res);</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="[283] Move Zeroes"></a>[283] Move Zeroes</h4><blockquote>
<p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Note</strong>:</p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
</blockquote>
<p>双指针解法, 一次成功.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution: two pointers</span></span><br><span class="line"><span class="comment">// 借鉴之前的做题经验, 这题算是完成的比较快</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> t = i; t &lt; len; t++) &#123;</span><br><span class="line">    nums[t] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(nums);</span></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="[66] Plus One"></a>[66] Plus One</h4><blockquote>
<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, increment one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
</blockquote>
<p>主要是运用数组特性.不是很难, 理解题意即可.</p>
<p>还挺多人不喜欢这道题的, 可能觉得太弱智了?…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = digits.length;</span><br><span class="line">  <span class="comment">// c 表示进位</span></span><br><span class="line">  <span class="keyword">let</span> i = len - <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有向前进位, 就 +1 结束</span></span><br><span class="line">    <span class="keyword">if</span> (digits[i] + c &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      digits[i]++;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 首位元素 +1 后有进位, 向数组头部插入 1 结束</span></span><br><span class="line">      digits[i] = <span class="number">0</span>;</span><br><span class="line">      digits.unshift(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是首位元素 +1 后有进位</span></span><br><span class="line">      <span class="comment">// 当前元素设为 0 , 继续看更高位元素</span></span><br><span class="line">      digits[i] = <span class="number">0</span>;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(digits);</span></span><br><span class="line">  <span class="keyword">return</span> digits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="[88] Merge Sorted Array"></a>[88] Merge Sorted Array</h4><blockquote>
<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em>and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is <strong>equal</strong> to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
</blockquote>
<p>我用的方法比较死板, 感觉没有什么难度. 就是分情况讨论. </p>
<p>不过用到了 js 里 Array 的特性.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 说明没有自己的元素</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums1[i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> len = nums1.length;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> j = m;</span><br><span class="line">        <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; k &lt; n) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums2[k] &gt;= nums1[i] &amp;&amp; nums2[k] &lt; nums1[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                nums1.splice(i + <span class="number">1</span>, <span class="number">0</span>, nums2[k]);</span><br><span class="line">                nums1.pop();</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums2[k] &gt;= nums1[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums1[j] = nums2[k];</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums2[k] &lt;= nums1[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums1.unshift(nums2[k]);</span><br><span class="line">                nums1.pop();</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
</search>
