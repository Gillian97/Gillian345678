<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Array</title>
    <url>/2020/09/21/Array/</url>
    <content><![CDATA[<h4 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="[56] Merge Intervals"></a>[56] Merge Intervals</h4><blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
</blockquote>
<p><strong>时间复杂度</strong>:</p>
<p>排序时间($O(NlogN)$) + 遍历数组($O(N)$)</p>
<p><strong>空间复杂度</strong>: 直接借用js数组特性splice对原数组进行修改, 没有使用额外的空间. 因此为$O(1)$.</p>
<p><strong>数组的sort方法</strong>:</p>
<p>当数组长度&lt;=10的时候，采用插入排序($O(N^2)$)，&gt;10的时候，采用快排($O(NlogN)$)。</p>
<p>对于长度&gt;1000的数组，采用的是快排与插入排序混合的方式进行排序.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并有交集的若干个区间</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = intervals.length</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">  <span class="comment">// 首先对区间进行排序 根据数组的第一列进行排序</span></span><br><span class="line">  <span class="comment">// 如果不排序 后面在合并区间时也会两两交换 等于排序</span></span><br><span class="line">  intervals.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 将数组中的区间进行两两合并</span></span><br><span class="line">  <span class="comment">// 如果某两个邻近区间a1 a2没有合并完成</span></span><br><span class="line">  <span class="comment">// 那么由于排序的原因 a1更不会和a3合并</span></span><br><span class="line">  <span class="keyword">let</span> preIndex = <span class="number">0</span>, currIndex = <span class="number">1</span>, mergeRes;</span><br><span class="line">  <span class="keyword">while</span> (currIndex &lt; len) &#123;</span><br><span class="line">    <span class="comment">// 判断两个区间是否能合并</span></span><br><span class="line">    <span class="comment">// 不能返回false 能则返回合并后的结果</span></span><br><span class="line">    mergeRes = isMerge(intervals[preIndex], intervals[currIndex]);</span><br><span class="line">    <span class="comment">// 不能合并</span></span><br><span class="line">    <span class="keyword">if</span> (mergeRes == <span class="literal">false</span>) &#123;</span><br><span class="line">      preIndex = currIndex;</span><br><span class="line">      currIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 进行合并</span></span><br><span class="line">      intervals[preIndex] = mergeRes;</span><br><span class="line">      intervals.splice(currIndex, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// currIndex 此时不变</span></span><br><span class="line">      len = intervals.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intervals;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isMerge = <span class="function">(<span class="params">inter1, inter2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 两个区间能合并的前提条件是 有交集</span></span><br><span class="line">  <span class="keyword">let</span> num0 = inter1[<span class="number">0</span>], num1 = inter1[<span class="number">1</span>], num2 = inter2[<span class="number">0</span>], num3 = inter2[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &gt;= num2 &amp;&amp; num1 &lt;= num3) &#123; <span class="comment">// 不是包含关系的交集</span></span><br><span class="line">    <span class="keyword">return</span> [num0, num3];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 前一个区间包含后一个区间</span></span><br><span class="line">    <span class="keyword">return</span> inter1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="[57] Insert Interval"></a>[57] Insert Interval</h4><blockquote>
<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
</blockquote>
<p><strong>时间复杂度</strong>:</p>
<p>遍历了一遍数组, 后面的判断部分时间是常数级, 因此  $O(N)$.</p>
<p>不得不说, 思路很好耶, 很巧妙利用了题目所给的条件. 比如有序, 比如区间合并, 这里的区间合并显得尤其简单.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// intervals 本身是已经排好序的</span></span><br><span class="line"><span class="keyword">var</span> insert = <span class="function"><span class="keyword">function</span> (<span class="params">intervals, newInterval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = [], right = [];</span><br><span class="line">  <span class="comment">// 逐步比较 将完全不能与当前区间合并的区间分成左右两半部分</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item[<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">      left.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (item[<span class="number">0</span>] &gt; newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">      right.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 说明剩余有可以合并的区间</span></span><br><span class="line">  <span class="comment">// 剩余的每个区间都是可以和 newInterval 合并的</span></span><br><span class="line">  <span class="comment">// 剩余的所有区间和 newInterval 最后会合并成一个区间</span></span><br><span class="line">  <span class="keyword">let</span> ll = left.length, rl = right.length, len = intervals.length;</span><br><span class="line">  <span class="keyword">let</span> s = newInterval[<span class="number">0</span>], b = newInterval[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (ll + rl != len) &#123;</span><br><span class="line">    <span class="comment">// 可以合并的区间的序号范围是 [ll, len-rl-1]</span></span><br><span class="line">    <span class="comment">// 由于中间的每一个元素均和 newInterval 有交集</span></span><br><span class="line">    <span class="comment">// 则最后会合并成一个区间 找到最后这个合并区间的最大值与最小值(即其范围)</span></span><br><span class="line">    s = <span class="built_in">Math</span>.min(intervals[ll][<span class="number">0</span>], s);</span><br><span class="line">    b = <span class="built_in">Math</span>.max(intervals[len - rl - <span class="number">1</span>][<span class="number">1</span>], b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将合并部分的区间置于左右中间</span></span><br><span class="line">  <span class="comment">// 拼接形成结果</span></span><br><span class="line">  <span class="keyword">let</span> res = left.concat([[s, b]]).concat(right);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Dynamic-Programming</title>
    <url>/2020/08/04/Dynamic-Programming/</url>
    <content><![CDATA[<h4 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="[62] Unique Paths"></a>[62] Unique Paths</h4><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
</blockquote>
<h5 id="Solution-1-排列组合"><a href="#Solution-1-排列组合" class="headerlink" title="Solution 1: 排列组合"></a>Solution 1: 排列组合</h5><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p>
<p>比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。</p>
<p>所以结果= (m+n−2)!/((m−1)!*(n-1)!).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1 : 排列组合</span></span><br><span class="line"><span class="comment">// 使用数学上的排列组合计算公式</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths1 = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 起点到终点一共需要走 m-1+n-1 = m+n-2 步</span></span><br><span class="line">  <span class="comment">// 其中从总步数中选出向右的 m-1 步</span></span><br><span class="line">  <span class="keyword">return</span> jc(m + n - <span class="number">2</span>) / (jc(m - <span class="number">1</span>) * jc(n - <span class="number">1</span>))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jc = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    res = res * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Solution-2-动态规划"><a href="#Solution-2-动态规划" class="headerlink" title="Solution 2: 动态规划"></a>Solution 2: 动态规划</h5><p>关键在于写出状态转移方程.很多解法用的是数组,我这里用的是对象存储.</p>
<p>数组的空间O(mn)可优化为O(n).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 2 : 动态规划</span></span><br><span class="line"><span class="comment">// 假设到点(i,j)的所有路径数表示为 dp(i,j)</span></span><br><span class="line"><span class="comment">// 状态转移方程</span></span><br><span class="line"><span class="comment">// dp(i,j) = dp(i-1,j) + dp(i,j-1)</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths2 = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 只能向右或向下</span></span><br><span class="line">  <span class="comment">// 所以到达边界的点的方法数=1</span></span><br><span class="line">  dp[key(<span class="number">0</span>, <span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dp[key(i, <span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    dp[key(<span class="number">0</span>, j)] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 时间复杂度O(mn)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      dp[key(i, j)] = dp[key(i - <span class="number">1</span>, j)] + dp[key(i, j - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[key(m - <span class="number">1</span>, n - <span class="number">1</span>)]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key = <span class="function">(<span class="params">i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="string">'/'</span> + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="[63] Unique Paths II"></a>[63] Unique Paths II</h4><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
</blockquote>
<p>这里需要修改状态转移方程, 就是, 在计算某一点可到达的路径数时, 如果这一点有障碍, 则为0, 否则按照原来的等式计算.</p>
<p>在初始化到达边缘点的路径数时, 也要考虑障碍的情况.</p>
<p>感觉动态规划主要有两个过程, 重点还是<strong>分析清楚过程</strong>:</p>
<ol>
<li><strong>初始化数据</strong></li>
<li><strong>正确的动态规划方程</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span> (<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rowNum = obstacleGrid.length;</span><br><span class="line">  <span class="keyword">let</span> colNum = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">let</span> dp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> flag1 = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 考虑障碍的情况</span></span><br><span class="line">    <span class="comment">// 边缘一有障碍, 则后面所有点的可到达路径数均为0</span></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> t = i; t &lt; rowNum; t++) &#123;</span><br><span class="line">        dp[key(t, <span class="number">0</span>)] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flag1 = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[key(i, <span class="number">0</span>)] = (flag1 == <span class="literal">true</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> flag2 = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> t = j; t &lt; colNum; t++) &#123;</span><br><span class="line">        dp[key(<span class="number">0</span>, t)] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flag2 = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[key(<span class="number">0</span>, j)] = (flag2 == <span class="literal">true</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">      <span class="comment">// 考虑障碍的动态规划方程</span></span><br><span class="line">      <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">        dp[key(i, j)] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        dp[key(i, j)] = dp[key(i - <span class="number">1</span>, j)] + dp[key(i, j - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(dp[key(rowNum - 1, colNum - 1)]);</span></span><br><span class="line">  <span class="keyword">return</span> dp[key(rowNum - <span class="number">1</span>, colNum - <span class="number">1</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key = <span class="function">(<span class="params">i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="string">'/'</span> + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="[300] Longest Increasing Subsequence"></a>[300] Longest Increasing Subsequence</h4><blockquote>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
</blockquote>
<p><strong>动态规划</strong></p>
<p>时间复杂度:</p>
<p>遍历数组, 遍历到每个元素时, 再次遍历该元素之前的所有元素. $O(N^2)$.</p>
<p>空间复杂度:</p>
<p>使用额外数组保存每个元素的最长子串的长度. $O(N)$ .</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1: 使用动态规划 时间复杂度 O(N^2)</span></span><br><span class="line"><span class="comment">// 后一个元素的递增子串长度最大值依赖于前面每个元素的递增子串长度最大值</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="comment">// 不存在递增的子串</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// 初始化数组 保存到达每个位置的所有递增子串长度的最大值(以每个位置为终点)</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  dp.fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="number">1</span>, val = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 计算每一个位置的最长子串长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 计算过程中, 每次查找i之前的元素, 看有无比nums[i]还小的</span></span><br><span class="line">    <span class="comment">// 小的话就是dp[j]+1</span></span><br><span class="line">    <span class="comment">// 但是还要将 dp[i] 与 dp[j]+1 进行比较, 保留较大值</span></span><br><span class="line">    <span class="comment">// 则最后dp[i]是所有递增子串中最长子串的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">        val = dp[j] + <span class="number">1</span>;</span><br><span class="line">        dp[i] = val &gt; dp[i] ? val : dp[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保留dp[i]中的最大值</span></span><br><span class="line">    maxLen = maxLen &gt; dp[i] ? maxLen : dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回的是 最长的递增子串的长度</span></span><br><span class="line">  <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="[70] Climbing Stairs"></a>[70] Climbing Stairs</h4><blockquote>
<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
</blockquote>
<p><strong>时间复杂度</strong>:</p>
<p>计算每一层的方法数, $O(N)$</p>
<p><strong>空间复杂度</strong>:</p>
<p>使用数组保存到达每一层的方法数, $O(N)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 楼梯一共有n层</span></span><br><span class="line"><span class="comment">// 需要返回达到n层总共的路径数</span></span><br><span class="line"><span class="comment">// 到达每一层都有两种方式, 要不跨一步, 要不跨两步</span></span><br><span class="line"><span class="comment">// 假设到达i层的方法数为dp[i], 则dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> way = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  way.fill(<span class="number">0</span>);</span><br><span class="line">  way[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  way[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    way[i] = way[i - <span class="number">1</span>] + way[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> way[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Search</title>
    <url>/2020/08/03/Binary-Search/</url>
    <content><![CDATA[<h4 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="[35] Search Insert Position"></a>[35] Search Insert Position</h4><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
</blockquote>
<h6 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h6><p>我是哪里来的if-else怪物(为了边界情况, 疯狂if-else), 代码一点都不优雅, 考点应该是折半查找, 被我写成这个样子. 不说了, 我去找优雅解法去了…..</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">    end = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> mid = start + index(end - start);</span><br><span class="line">  <span class="comment">// 数组len=1</span></span><br><span class="line">  <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> start</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123; <span class="comment">// 数组len=2</span></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">      <span class="keyword">return</span> end + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == nums[start])</span><br><span class="line">      <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> end</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 数组len&gt;2</span></span><br><span class="line">    <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target:'</span> + target + <span class="string">'&lt;'</span> + <span class="string">"nums["</span> + mid + <span class="string">"]:"</span> + nums[mid]);</span><br><span class="line">        end = mid;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (target == nums[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mid = start + index(end - start);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target:'</span> + target + <span class="string">'&gt;'</span> + <span class="string">"nums["</span> + mid + <span class="string">"]:"</span> + nums[mid]);</span><br><span class="line">        start = mid;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (target == nums[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end + <span class="number">1</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mid = start + index(end - start);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(mid);</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = <span class="function">(<span class="params">gap</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (gap % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> gap / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (gap + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="solution-on-the-Internet"><a href="#solution-on-the-Internet" class="headerlink" title="solution on the Internet"></a>solution on the Internet</h6><p>参考网上的解法, 优化了一下, 感觉稍微简洁了些, 这里的mid取值是靠左的.所以一开始判断end值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">    <span class="keyword">return</span> end + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// if (target &lt; nums[start])</span></span><br><span class="line">  <span class="comment">//   return 0;</span></span><br><span class="line">  <span class="comment">// if (target == nums[start])</span></span><br><span class="line">  <span class="comment">//   return start</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">    mid = start + <span class="built_in">parseInt</span>((end - start) / <span class="number">2</span>); <span class="comment">// parseInt 直接丢弃小数部分, 保留整数部分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mid: '</span>, mid, <span class="string">' start: '</span>, start, <span class="string">' end: '</span>, end);</span><br><span class="line">    <span class="keyword">if</span> (target == nums[start])</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    <span class="keyword">if</span> (target == nums[end])</span><br><span class="line">      <span class="keyword">return</span> end;</span><br><span class="line">    <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// console.log('target &gt; mid', 'start: ', start);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      end = mid;</span><br><span class="line">      <span class="comment">// console.log('target &lt; mid', 'end: ', end);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Backtracking</title>
    <url>/2020/08/18/Backtracking/</url>
    <content><![CDATA[<h4 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="[22] Generate Parentheses"></a>[22] Generate Parentheses</h4><blockquote>
<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 思路: 2*n 是括号总数, 对括号进行排列组合, 再除去不合题意的部分</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> level = <span class="number">0</span>, <span class="comment">// 实时记录字符串的长度</span></span><br><span class="line">    sum = <span class="number">2</span> * n, <span class="comment">// 括号总数</span></span><br><span class="line">    str = <span class="string">''</span>, <span class="comment">// 括号累加的字符串</span></span><br><span class="line">    left = <span class="number">0</span>, <span class="comment">// 记录左括号数目</span></span><br><span class="line">    right = <span class="number">0</span>; <span class="comment">// 记录右括号数目</span></span><br><span class="line">  <span class="comment">// recur1(level, sum, str, arr);</span></span><br><span class="line">  recur2(sum, str, arr, left, right);</span><br><span class="line">  <span class="comment">// console.log('arr: ', arr);</span></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution 1: 暴力法</span></span><br><span class="line"><span class="keyword">var</span> recur1 = <span class="function">(<span class="params">level, sum, str, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (level == sum &amp;&amp; str.length == sum) &#123;</span><br><span class="line">    <span class="comment">// 将合法的组合放进结果数组</span></span><br><span class="line">    <span class="keyword">if</span> (isValid(str)) &#123;</span><br><span class="line">      arr.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过递归生成所有的可能的组合</span></span><br><span class="line">  recur(level + <span class="number">1</span>, sum, str + <span class="string">'('</span>, arr);</span><br><span class="line">  recur(level + <span class="number">1</span>, sum, str + <span class="string">')'</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (s.indexOf(<span class="string">'()'</span>) &gt;= <span class="number">0</span> || s.indexOf(<span class="string">'&#123;&#125;'</span>) &gt;= <span class="number">0</span> || s.indexOf(<span class="string">'[]'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    s = s.replace(<span class="regexp">/\(\)/g</span>, <span class="string">''</span>)</span><br><span class="line">    s = s.replace(<span class="regexp">/\[\]/g</span>, <span class="string">''</span>)</span><br><span class="line">    s = s.replace(<span class="regexp">/\&#123;\&#125;/g</span>, <span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="string">''</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以进行优化</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这四个条件确保放进结果数组里的字符串一定都是合法的</span></span><br><span class="line"><span class="comment"> * (感觉需要证明下)</span></span><br><span class="line"><span class="comment"> * 1. 左右括号一一对应</span></span><br><span class="line"><span class="comment"> * 2. 左右括号分别均为 n 个</span></span><br><span class="line"><span class="comment"> * 3. 当左括号数量大于右括号时，才加右括号</span></span><br><span class="line"><span class="comment"> * 4. 开头第一个一定是左括号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> recur2 = <span class="function">(<span class="params">sum, str, arr, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length == sum &amp;&amp; left == right) &#123;</span><br><span class="line">    <span class="comment">// 将合法的组合放进结果数组</span></span><br><span class="line">    arr.push(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过递归生成所有的可能的组合</span></span><br><span class="line">  <span class="comment">// 添加左括号, left + 1</span></span><br><span class="line">  <span class="comment">// 添加右括号, right + 1</span></span><br><span class="line">  <span class="comment">// 左括号的数量少于一半, 则加左括号</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt;= <span class="built_in">parseInt</span>(sum / <span class="number">2</span>)) &#123;</span><br><span class="line">    recur2(sum, str + <span class="string">'('</span>, arr, left + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 左括号数量大于右括号时, 才加右括号</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">    recur2(sum, str + <span class="string">')'</span>, arr, left, right + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="[46] Permutations"></a>[46] Permutations</h4><blockquote>
<p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>
</blockquote>
<p>时间复杂度: O(N*N!)</p>
<p>全排列一共有 N! 种可能, 实现每一种可能需要遍历整个数组即O(N)时间, 所以可得.</p>
<p>这个算法思路非常巧妙, 实现起来很清楚.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 算法思路是: 用一个数组维护每个数组元素的状态, true/false, 状态变量</span></span><br><span class="line"><span class="comment"> * 每次将未被放入的元素放入,每次放入一个元素后就再次dfs,再将没有放入的元素放入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">let</span> path = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> used = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化状态变量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    used.push(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(resArr, nums, len, path, <span class="number">0</span>, used);</span><br><span class="line">  <span class="keyword">return</span> resArr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs = <span class="function">(<span class="params">resArr, nums, len, path, depth, used</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth === len) &#123;</span><br><span class="line">    <span class="comment">// 注意不能resArr.push(path) 后面path改变会影响res里的值</span></span><br><span class="line">    <span class="comment">// js 值传递 传的是变量的地址</span></span><br><span class="line">    resArr.push(path.slice()); <span class="comment">// 需要将path的深拷贝放入</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">      path.push(nums[i]);</span><br><span class="line">      used[i] = <span class="literal">true</span>;</span><br><span class="line">      dfs(resArr, nums, len, path, depth + <span class="number">1</span>, used);</span><br><span class="line">      used[i] = <span class="literal">false</span>; <span class="comment">// 由于重新开始放入元素, 将已经放入的元素的状态置false</span></span><br><span class="line">      path.pop(); <span class="comment">// 弹出最后一个元素 路径回到上一个状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="[78] Subsets"></a>[78] Subsets</h4><blockquote>
<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
</blockquote>
<p>观察全排列/组合/子集问题，它们比较相似，且可以使用一些通用策略解决。</p>
<p>首先，它们的解空间非常大：</p>
<ul>
<li>全排列：N!。</li>
</ul>
<ul>
<li>组合：N!。</li>
</ul>
<ul>
<li>子集：2^N, 每个元素都可能存在或不存在。</li>
</ul>
<p>在它们的指数级解法中，要确保生成的结果 <strong>完整</strong> 且 <strong>无冗余</strong>，有三种常用的方法：</p>
<ol>
<li>递归</li>
<li>回溯</li>
<li>基于二进制位掩码和对应位掩码之间的映射字典生成排列/组合/子集</li>
</ol>
<p>相比前两种方法，第三种方法将每种情况都简化为二进制数，易于实现和验证。</p>
<p>此外，第三种方法具有<strong>最优的时间复杂度</strong>，可以生成按照字典顺序的输出结果。</p>
<h5 id="solution-1-字典排序（二进制排序）-子集"><a href="#solution-1-字典排序（二进制排序）-子集" class="headerlink" title="solution 1 : 字典排序（二进制排序） 子集"></a>solution 1 : 字典排序（二进制排序） 子集</h5><p>这种解法很巧妙, 由于是全排列问题, 子集的数量与数组长度有关.</p>
<p>数组中的元素, 每个只有在或者不在子集中这两种选择. 对于每一种可能, 都能用二进制来标记.</p>
<p>因此该方法的思路如下:</p>
<p>假设数组为[1, 2, 4], 则子集数量为 2^len= 2^3 = 8</p>
<p>则从 0 - 7 的二进制对应分别为 000-111</p>
<p>每一种可能都对应一种子集详情, 比如 101 对应 [1,4],  001 对应 [4].</p>
<img src="/2020/08/18/Backtracking/bitmask4.png" class="" title="bitmask4">

<p>需要注意的点是, 在将十进制转换为二进制时, 需要将二进制的位数扩充至与nums的长度相等.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> subSets = [];</span><br><span class="line">  <span class="comment">// 根据数组长度计算器其子集数量</span></span><br><span class="line">  <span class="keyword">let</span> subSetsNum = <span class="built_in">Math</span>.pow(<span class="number">2</span>, len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subSetsNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 十进制转换为二进制</span></span><br><span class="line">    <span class="comment">// 每一个二进制都唯一对应一个子集</span></span><br><span class="line">    <span class="keyword">let</span> setNoStr = i.toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (setNoStr.length &lt; len) &#123;</span><br><span class="line">      <span class="comment">//如果长度不足 len，前面添加 0</span></span><br><span class="line">      setNoStr = <span class="string">'0'</span> + setNoStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> setNoList = setNoStr.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> subSet = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (setNoList[j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        subSet.push(nums[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    subSets.push(subSet);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subSets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N×2^N)，生成所有的子集，并复制到输出列表中。</li>
<li>空间复杂度：O(N×2^N)，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。</li>
</ul>
<h5 id="solution-2-递归法"><a href="#solution-2-递归法" class="headerlink" title="solution 2 : 递归法"></a>solution 2 : 递归法</h5><p>这个解法挺巧妙的, 每次都把新元素加进已有的所有子集, 生成新的子集, 因为每个元素只有在和不在两种情况.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> subSets = [[]];</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> subSets</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = subSets.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> ele = subSets[j].concat([nums[i]]);</span><br><span class="line">      subSets.push(ele);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subSets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h5><p>回溯解法, 每次递归获得相同长度的子集</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    recur(i, <span class="number">0</span>, len, [], res, nums);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recur = <span class="function">(<span class="params">depth, first, len, curr, res, nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (curr.length == depth) &#123;</span><br><span class="line">    res.push(curr.slice()); <span class="comment">// 将当前子集的深拷贝加入结果数组</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = first; i &lt; len; i++) &#123;</span><br><span class="line">    curr.push(nums[i]);</span><br><span class="line">    recur(depth, i + <span class="number">1</span>, len, curr, res, nums);</span><br><span class="line">    curr.pop(); <span class="comment">// 回溯 回到初始状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="[90] Subsets II"></a>[90] Subsets II</h4><blockquote>
<p>Given a collection of integers that might contain duplicates, <strong><em>nums\</em></strong>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
</blockquote>
<p>思路与子集时类似, 只是需要剪枝操作, <strong>将同一层其余相同的元素除去</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsetsWithDup = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(); <span class="comment">// 排序操作 使得相同元素相邻</span></span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    recur(i, <span class="number">0</span>, len, [], res, nums);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recur = <span class="function">(<span class="params">depth, first, len, curr, res, nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (curr.length == depth) &#123;</span><br><span class="line">    res.push(curr.slice()); <span class="comment">// 将当前子集的深拷贝加入结果数组</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = first; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; first &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 一开始写成了 i&gt;0 结果总是不对 后来知道每次加元素是从 first 开始 不是 0 开始</span></span><br><span class="line">      <span class="comment">// 每次当作为起始点往数组加入元素时,不能加入与上一个元素相同的元素</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curr.push(nums[i]);</span><br><span class="line">    recur(depth, i + <span class="number">1</span>, len, curr, res, nums);</span><br><span class="line">    curr.pop(); <span class="comment">// 回溯 回到初始状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="[93] Restore IP Addresses"></a>[93] Restore IP Addresses</h4><blockquote>
<p>Given a string <code>s</code> containing only digits. Return all possible valid IP addresses that can be obtained from <code>s</code>. You can return them in <strong>any</strong> order.</p>
<p>A <strong>valid IP address</strong> consists of exactly four integers, each integer is between <code>0</code> and <code>255</code>, separated by single points and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are <strong>valid</strong> IP addresses and “0.011.255.245”, “192.168.1.312” and “<a href="mailto:192.168@1.1">192.168@1.1</a>“ are <strong>invalid</strong> IP addresses. </p>
</blockquote>
<p>就是大概有想法但是却实现不出来, 说明思路还不是很清楚, 需要画树状图帮助自己理解.</p>
<p>多画树状图, 理解回溯过程. 被这道题折磨好久.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 合法的url的条件:</span></span><br><span class="line"><span class="comment"> * 将字符串分为四个部分, 每个部分的数字[0,255], 不超过3位</span></span><br><span class="line"><span class="comment"> * 中间的数字不能以0开头</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="comment">// 字符串长度不够则直接返回空数组</span></span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">12</span> || len &lt; <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> ip = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  dfs(res, ip, start, s);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>res 存储合法ip</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>ip 存储ip的每一段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>start 剩余需要继续递归的子串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>s </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dfs = <span class="function">(<span class="params">res, ip, start, s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在开始切割子串之前, 判断ip是否符合题意</span></span><br><span class="line">  <span class="comment">// s 已经遍历完毕且ip是四段的话, 该ip可以进结果数组了</span></span><br><span class="line">  <span class="keyword">if</span> (ip.length == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.length) &#123;</span><br><span class="line">      res.push(ip.join(<span class="string">'.'</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未遍历完s ip已经4段 该ip不合题意</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; s.length) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// s 已经遍历完了,但是ip不到四段,返回</span></span><br><span class="line">  <span class="keyword">if</span> (ip.length &lt; <span class="number">4</span> &amp;&amp; start == s.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从每个起始位置开始切割都是三个长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> l = <span class="number">1</span>; l &lt;= <span class="number">3</span>; l++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start + l &gt; s.length) <span class="keyword">return</span>; <span class="comment">// 索引超过边界</span></span><br><span class="line">    <span class="keyword">if</span> ((l == <span class="number">2</span> || l == <span class="number">3</span>) &amp;&amp; s[start] == <span class="string">'0'</span>) <span class="keyword">return</span>; <span class="comment">// 2/3子串以0开头</span></span><br><span class="line">    <span class="keyword">let</span> part = s.substring(start, start + l); <span class="comment">// 切割子串</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>(part) &gt; <span class="number">255</span>) <span class="keyword">return</span>; <span class="comment">// 子串不符合条件 这里已经l==3了 continue和return是一样的效果</span></span><br><span class="line">    <span class="comment">// part符合条件</span></span><br><span class="line">    ip.push(part.slice());</span><br><span class="line">    <span class="comment">// 下次递归的子串的起始位置是start+l</span></span><br><span class="line">    dfs(res, ip, start + l, s);</span><br><span class="line">    ip.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="[77] Combinations"></a>[77] Combinations</h4><blockquote>
<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p>You may return the answer in <strong>any order</strong>.</p>
</blockquote>
<p>经过93题的经历, 这题要思路清晰很多.</p>
<p>大体思路是: 构造数组, 然后找子集的思路, 但是将不符合长度k的子集都剪枝了.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全排列的另一种形式, 除去长度不合适的组合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="comment">// 初始化数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    arr.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 目标:找到长度为k的子集</span></span><br><span class="line">  <span class="comment">// 约束:长度为k即停止</span></span><br><span class="line">  <span class="comment">// 选择:每次选择当前元素的下一个元素</span></span><br><span class="line">  <span class="comment">// 如何定义dfs start depth</span></span><br><span class="line">  <span class="keyword">let</span> res = [], curr = [], start = <span class="number">0</span>, depth = <span class="number">0</span>;</span><br><span class="line">  dfs(arr, depth, k, res, curr, start, n);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs = <span class="function">(<span class="params">arr, depth, k, res, curr, start, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth === k) &#123;</span><br><span class="line">    res.push(curr.slice());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; n; i++) &#123;</span><br><span class="line">    curr.push(arr[i]);</span><br><span class="line">    dfs(arr, depth + <span class="number">1</span>, k, res, curr, i + <span class="number">1</span>, n);</span><br><span class="line">    curr.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Greedy Algorithm</title>
    <url>/2020/08/03/Greedy-Algorithm/</url>
    <content><![CDATA[<h4 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="[45] Jump Game II"></a>[45] Jump Game II</h4><blockquote>
<p> Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p> Each element in the array represents your maximum jump length at that position.</p>
<p> Your goal is to reach the last index in the minimum number of jumps.</p>
</blockquote>
<p>贪心算法, 局部解得到最优解.</p>
<p>解题思路: 每次查找当前位置能够到达的位置中, 能跳到最远位置的位置A, 下次就跳到位置A, 然后再从位置A能到达的位置中, 再找能跳到最远位置的位置, 如此循环.</p>
<p>但是官方解答虽然简洁, 但是我不是看的很明白, 还是暂时先贴自己的直白解法吧.</p>
<img src="/2020/08/03/Greedy-Algorithm/45_fig1.png" class="" title="45_fig1">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于当前index, 每次在能跳到的范围内</span></span><br><span class="line"><span class="comment">// 跳到能跳到更远地方的index</span></span><br><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt;= len - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> nextPosMap = &#123; <span class="string">'index'</span>: <span class="number">0</span>, <span class="string">'maxIndex'</span>: <span class="number">0</span> + nums[<span class="number">0</span>] &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len;) &#123;</span><br><span class="line">    <span class="keyword">let</span> indexLimit = i + nums[i];</span><br><span class="line">    <span class="comment">// 在寻找下一步跳的位置时, 步数加一</span></span><br><span class="line">    step++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= indexLimit &amp;&amp; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j + nums[j] &gt; nextPosMap.maxIndex) &#123;</span><br><span class="line">        nextPosMap.index = j;</span><br><span class="line">        nextPosMap.maxIndex = j + nums[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index != i, 说明能跳到更远距离的index更新了, 这时才需要将当前节点 i 移到index</span></span><br><span class="line">    <span class="comment">// 其实肯定更新, 题目已经说了能跳到最后</span></span><br><span class="line">    <span class="comment">// 移动才算跳了一步</span></span><br><span class="line">    <span class="comment">// 同时能跳到的最远位置不要超过数组边界</span></span><br><span class="line">    <span class="comment">// 超过数组边界则表示步数已经能计算出来了 return</span></span><br><span class="line">    <span class="keyword">if</span> (nextPosMap.maxIndex &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">      i = nextPosMap.index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当最大位置能到达最后时, 返回step+1</span></span><br><span class="line">      <span class="comment">// 把跳到最后位置的一步也加上</span></span><br><span class="line">      <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="[55] Jump Game"></a>[55] Jump Game</h4><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
</blockquote>
<p>一开始尝试使用递归做法, 计算所有的可能性, 但是想也不是最好的解法, 最后很可能超时, 果不其然超时.</p>
<p>于是就去看网上解法, 这里的考点是<strong>贪心算法</strong>.</p>
<blockquote>
<p>贪心算法（又称贪婪算法）是指，在对<a href="https://baike.baidu.com/item/问题求解/6693186" target="_blank" rel="noopener">问题求解</a>时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解</p>
</blockquote>
<p>该题的大概思路是:</p>
<p>数组的第一个元素的值为 reach, 从数组的第一个元素开始, 每次计算在reach范围内的元素们所能到达的最远距离, 是否超过reach, 如果超过了, 就更新reach值为较大值. 直至reach的值超过lastIndex 返回 true.</p>
<img src="/2020/08/03/Greedy-Algorithm/largen-reach.png" class="" title="largen-reach">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 递归超时 使用贪心算法求解</span></span><br><span class="line"><span class="comment">// 局部能够到达的最大范围, 也是全局能够到达的最大范围</span></span><br><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reach = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 需要注意的点是,这里reach的值不一定就&gt;1, 所以i不一定就从1开始</span></span><br><span class="line">  <span class="comment">// 还是从0开始能够包含所有情况, 这么写因为有个特例 [0]</span></span><br><span class="line">  <span class="comment">// 同时注意限制 i 的范围, i 是指 reach 能够到达的位置范围, 不能超过 reach</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length &amp;&amp; i &lt;= reach; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + i &gt; reach) &#123;</span><br><span class="line">      reach = nums[i] + i;</span><br><span class="line">      <span class="comment">// console.log(reach);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当能到达的范围超过数组的最后 index 时, 返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (reach &gt;= nums.length - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 能到达的元素位置都尝试了, 但是没有一个位置可以到达最后一个元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>String</title>
    <url>/2020/08/17/String/</url>
    <content><![CDATA[<h4 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="[43] Multiply Strings"></a>[43] Multiply Strings</h4><blockquote>
<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
</blockquote>
<p>算法答题思路就是模拟乘法累加的过程. </p>
<p>需要注意的是, js大数相加会丢失精度, 所以谨慎使用.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// js大数相加容易丢失精度, 有安全范围, 不行</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 整个算法的过程模拟乘法的计算过程</span></span><br><span class="line"><span class="comment"> * 用一个数组来存储每一步计算的结果</span></span><br><span class="line"><span class="comment"> * 时间复杂度: n^2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> multiply = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 有一个参数为0,则结果为0</span></span><br><span class="line">  <span class="keyword">if</span> (num1 == <span class="string">'0'</span> || num2 == <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">let</span> len1 = num1.length,</span><br><span class="line">    len2 = num2.length,</span><br><span class="line">    len = len1 + len2;</span><br><span class="line">  <span class="comment">// 数组存储计算结果 长度暂时为两个字符串长度之和</span></span><br><span class="line">  <span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="comment">// 初始化结果数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    resArr[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环反过来的原因是: 每次都是先拿因数1的每一位与因数2的同一位相乘</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">let</span> n2 = <span class="built_in">parseInt</span>(num2[j]);</span><br><span class="line">    <span class="comment">// 计算结果放置的位置</span></span><br><span class="line">    <span class="keyword">let</span> pos = len - len2 + j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> n1 = <span class="built_in">parseInt</span>(num1[i]);</span><br><span class="line">      <span class="keyword">let</span> res = n1 * n2;</span><br><span class="line">      addNext(res, resArr, pos, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 数位升高一位, 结果放置也要对应往左一位</span></span><br><span class="line">      pos--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 去除结果数组最左边的 0</span></span><br><span class="line">  <span class="keyword">while</span> (resArr[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">    resArr.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resArr.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag 为 1 表示要与当前位置数值相加</span></span><br><span class="line"><span class="comment">// 为 0 则表示不用相加</span></span><br><span class="line"><span class="keyword">var</span> addNext = <span class="function">(<span class="params">num, resArr, pos, flag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> posNum = num % <span class="number">10</span>, <span class="comment">// 取余数 置于当前位置</span></span><br><span class="line">    addNum = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>); <span class="comment">// floor 向下取整</span></span><br><span class="line"></span><br><span class="line">  resArr[pos] = (flag == <span class="number">1</span>) ? resArr[pos] + posNum : posNum;</span><br><span class="line">  resArr[pos - <span class="number">1</span>] += addNum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (resArr[pos] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 与当前数值相加之后, 数值大于10, 则当前仍然需要进位</span></span><br><span class="line">    <span class="comment">// 但是不需要再与当前位置数值相加了</span></span><br><span class="line">    addNext(resArr[pos], resArr, pos, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进位最多只会等于 10</span></span><br><span class="line">  <span class="keyword">if</span> (resArr[pos - <span class="number">1</span>] == <span class="number">10</span>) &#123;</span><br><span class="line">    addNext(resArr[pos - <span class="number">1</span>], resArr, pos - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="[13] Roman to Integer"></a>[13] Roman to Integer</h4><blockquote>
<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>
<p>时间复杂度: 遍历整个字符串, $O(N)$</p>
<p>空间复杂度: 常数级别.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 罗马数字一共三种情况</span></span><br><span class="line"><span class="comment">// 百位数字&gt;十位数字&gt;个位数字</span></span><br><span class="line"><span class="comment">// 出现左侧数字比右侧数字小, 只会在某一个数位内部</span></span><br><span class="line"><span class="keyword">var</span> romanToInt = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从左往右遍历</span></span><br><span class="line">  <span class="keyword">let</span> pre = getVal(s[<span class="number">0</span>]), sum = <span class="number">0</span>, num;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    num = getVal(s[i]);</span><br><span class="line">    <span class="comment">// 前一个数字不小于后一个数字, 加上pre</span></span><br><span class="line">    <span class="comment">// 反之, 说明pre是某一数位内部的需要减去的数字, 则减去pre</span></span><br><span class="line">    <span class="comment">// 左侧的被减去的数字只出现一次或者不出现, 不会出现两次</span></span><br><span class="line">    <span class="keyword">if</span> (pre &gt;= num) &#123;</span><br><span class="line">      sum += pre;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sum -= pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新pre的值</span></span><br><span class="line">    pre = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一位不会再比右边哪个元素小了</span></span><br><span class="line">  <span class="comment">// 所以需要将最后一位加上</span></span><br><span class="line">  sum += getVal(s[len - <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getVal = <span class="function">(<span class="params">ch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="[12] Integer to Roman"></a>[12] Integer to Roman</h4><blockquote>
<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
</blockquote>
<p>主要是不同数位的数字转换, 需要对数位进行分情况讨论. 不同数位的相同数字, 对应使用的罗马字符也不同.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要思路就是, 逐步整除, 然后对商进行对应数位的转换</span></span><br><span class="line"><span class="keyword">var</span> intToRoman = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = [<span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> n, res = <span class="string">''</span>; <span class="comment">// res需要初始化 否则res+=操作时, 由于res的值为udefined, 会在结果头部留一个udefined</span></span><br><span class="line">  <span class="comment">// 从千位除到个位</span></span><br><span class="line">  <span class="comment">// 注意 用let i in items时, typeof i = string</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 得到商</span></span><br><span class="line">    n = <span class="built_in">Math</span>.floor(num / items[i]);</span><br><span class="line">    <span class="comment">// 根据数位以及商的大小确定对应的罗马数字</span></span><br><span class="line">    <span class="comment">// 并对每一步得到的罗马数字进行拼接</span></span><br><span class="line">    <span class="comment">// 使用索引顺便标记数位</span></span><br><span class="line">    res += toRoman(i, n);</span><br><span class="line">    <span class="comment">// 后一轮需要被整除的数是当前一轮整除后得到的余数</span></span><br><span class="line">    num = num % items[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toRoman = <span class="function">(<span class="params">type, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sma = <span class="string">''</span>, mid = <span class="string">''</span>, top = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 数位不同 相同数字的表达方法不同</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 千位</span></span><br><span class="line">      sma = <span class="string">'M'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 百位</span></span><br><span class="line">      sma = <span class="string">'C'</span>; mid = <span class="string">'D'</span>; top = <span class="string">'M'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 十位</span></span><br><span class="line">      sma = <span class="string">'X'</span>; mid = <span class="string">'L'</span>; top = <span class="string">'C'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 个位</span></span><br><span class="line">      sma = <span class="string">'I'</span>; mid = <span class="string">'V'</span>; top = <span class="string">'X'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> roman = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 根据 n 的大小, 转换成对应的罗马数字</span></span><br><span class="line">  <span class="comment">// 千位不会超过3</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">3</span>) &#123; <span class="comment">// [0,3]</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">      roman += sma;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">4</span> || n == <span class="number">9</span>) &#123; <span class="comment">// 4/9</span></span><br><span class="line">    roman = n == <span class="number">4</span> ? sma + mid : sma + top;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// [5, 8]</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    roman = mid;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; n - <span class="number">5</span>) &#123;</span><br><span class="line">      roman += sma;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> roman;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="[49] Group Anagrams"></a>[49] Group Anagrams</h4><blockquote>
<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串按照构成分组</span></span><br><span class="line"><span class="comment">// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为字典的key</span></span><br><span class="line"><span class="comment">// 相同key的就将元素index加入key对应的数组[]</span></span><br><span class="line"><span class="comment">// 将字符串按照构成分组</span></span><br><span class="line"><span class="comment">// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为map的key</span></span><br><span class="line"><span class="comment">// 相同key的就将元素index加入key对应的数组[]</span></span><br><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = strs.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> [strs];</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;, key;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 对每个字符串的字符拆分-排序-重组为string</span></span><br><span class="line">    <span class="comment">// 以至于相同字母组成的str的key会一致</span></span><br><span class="line">    key = strs[i].split(<span class="string">''</span>).sort().toString();</span><br><span class="line">    <span class="comment">// 看map是否存在</span></span><br><span class="line">    <span class="comment">// 不存在生成[]</span></span><br><span class="line">    <span class="comment">// 存在往[]里push元素</span></span><br><span class="line">    <span class="keyword">if</span> (map[key] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      map[key] = [i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map[key].push(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// map中value是数组, 包含字母组成相同的一组字符串的index</span></span><br><span class="line">  <span class="comment">// 遍历每一个数组, 将index替换为strs里对应的str</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> map) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; map[k].length; i++) &#123;</span><br><span class="line">      map[k][i] = strs[map[k][i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直接返回对象的values, 所有value被添加进[]并返回</span></span><br><span class="line">  <span class="comment">// 本来是又新创建了个数组来存储结果, 这样直接返回values更节省空间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.values(map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="[67] Add Binary"></a>[67] Add Binary</h4><blockquote>
<p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p>
</blockquote>
<p>时间复杂度:</p>
<p>假设两个串的长度分别为M/N, 则时间复杂度为 $O(max(M, N))$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addBinary = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = a.length - <span class="number">1</span>, j = b.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> num, carry = <span class="literal">false</span>, sum = <span class="string">''</span>, charA, charB;</span><br><span class="line">  <span class="keyword">while</span> (a[i] || b[j]) &#123;</span><br><span class="line">    <span class="comment">// 考虑到两个串长度不一致时的处理</span></span><br><span class="line">    charA = (a[i] == <span class="literal">undefined</span>) ? <span class="string">'0'</span> : a[i];</span><br><span class="line">    charB = (b[j] == <span class="literal">undefined</span>) ? <span class="string">'0'</span> : b[j];</span><br><span class="line">    <span class="comment">// 由于二进制不是十进制加法, 所以需要对相加结果进行分类讨论</span></span><br><span class="line">    <span class="keyword">if</span> (charA == charB) &#123;</span><br><span class="line">      num = carry ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">      carry = charA == <span class="string">'1'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      num = carry ? <span class="string">'0'</span> : <span class="string">'1'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = num + sum;</span><br><span class="line">    i--;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果两数的每一位均已对应相加完成, 但是还有进位, 需要把进位也加入结果中</span></span><br><span class="line">  sum = carry ? <span class="string">'1'</span> + sum : sum;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Notes</title>
    <url>/2020/09/01/JavaScript-Notes/</url>
    <content><![CDATA[<h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h3><h4 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">'hello'</span>; <span class="comment">// 字面量创建</span></span><br><span class="line"><span class="keyword">let</span> thing = <span class="number">98</span>; <span class="comment">// 任何可以转换成字符串的值</span></span><br><span class="line"><span class="comment">/* String 函数 生成或者将值转换为字符串 */</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>(thing); <span class="comment">// 将thing转换为原始字符串</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="keyword">new</span> <span class="built_in">String</span>(thing); <span class="comment">// 新建String对象, 并存储thing的字符串表示</span></span><br><span class="line"><span class="built_in">console</span>.log(s1, <span class="keyword">typeof</span> s1); <span class="comment">// hello string</span></span><br><span class="line"><span class="built_in">console</span>.log(s2, <span class="keyword">typeof</span> s2); <span class="comment">// 98 string</span></span><br><span class="line"><span class="built_in">console</span>.log(s3, <span class="keyword">typeof</span> s3); <span class="comment">// [String: '98'] object</span></span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>length</code></p>
<p>字符串长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><code>constructor</code></p>
<p>对创建该对象的函数的引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.constructor); <span class="comment">// [Function: String]</span></span><br></pre></td></tr></table></figure>



<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>toUpperCase</code>  </p>
<p>字符串变大写</p>
<p><code>toLowerCase</code>  </p>
<p>字符串变小写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hello'</span>, t = <span class="string">'JINLING'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.toUpperCase()); <span class="comment">// HELLO</span></span><br><span class="line"><span class="built_in">console</span>.log(t.toLowerCase()); <span class="comment">// jinling</span></span><br></pre></td></tr></table></figure>

<p><code>split</code> </p>
<p>根据分隔符将字符串分割为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hel,l,o'</span>;</span><br><span class="line"><span class="comment">// 不切割 整个字符串视作数组的一个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split());  <span class="comment">// [ 'hel,l,o' ]</span></span><br><span class="line"><span class="comment">// 每个字符都是数组中的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split(<span class="string">''</span>));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"> 'h', 'e', 'l',</span></span><br><span class="line"><span class="comment"> ',', 'l', ',',</span></span><br><span class="line"><span class="comment"> 'o'</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 以逗号分割</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split(<span class="string">','</span>)); <span class="comment">// [ 'hel', 'l', 'o' ]</span></span><br></pre></td></tr></table></figure>



<h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h3><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = []; <span class="comment">// 字面</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 不固定长度</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// 固定长度</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr0, arr1, arr2, arr3); <span class="comment">// [] [] [ &lt;5 empty items&gt; ] [ 1, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p><code>length</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">// 字面</span></span><br><span class="line"><span class="built_in">console</span>.log(arr0.length); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><code>constructor</code></p>
<p>返回创建该对象的函数的引用, 因为js的一切变量都是对象, 是对象就有其构造函数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">if</span> (test.constructor==<span class="built_in">Array</span>)&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(test.constructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: function Array() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><code>sort</code></p>
<p>对数组元素进行排序, 默认是字符串顺序.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照字母顺序排序 默认</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'good'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'google'</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<p>添加比值函数, 使得能对<strong>数字进行排序</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用比值函数</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">76</span>, <span class="number">91</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr); </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  0,  1, 12,  3, 34,</span></span><br><span class="line"><span class="comment">  7, 76,  9, 91</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比值函数 倒序</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">76</span>, <span class="number">91</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  91, 76, 34, 12, 9,</span></span><br><span class="line"><span class="comment">   7,  3,  1,  0</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比值函数 正序</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">76</span>, <span class="number">91</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(arr); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">   0,  1,  3,  7, 9,</span></span><br><span class="line"><span class="comment">  12, 34, 76, 91</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>join</code> </p>
<p><code>toString</code> 所有 JavaScript 对象都拥有<code>toString()</code>方法</p>
<p>数组所有元素组成字符串, 可以指定分隔符.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr0.join(), arr0.toString()); <span class="comment">// 1,2,3,4  1,2,3,4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr0.join(<span class="string">'*'</span>)); <span class="comment">// 1*2*3*4</span></span><br></pre></td></tr></table></figure>

<p><code>slice</code></p>
<p>根据下标获取数组的一部分, 不改变原有数组, 返回新数组.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.slice(<span class="number">3</span>), arr1.slice(<span class="number">2</span>,<span class="number">4</span>), arr1);</span><br><span class="line"><span class="comment">// output: [ 4, 5 ] [ 3, 4 ] [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p><code>concat</code></p>
<p>拼接数组成一个新数组, 不改变原来的数组.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr0.concat(arr1), arr0, arr1);</span><br><span class="line"><span class="comment">// output: [ 1, 2, 3, 4, 5, 6 ] [ 1, 2, 3, 4 ] [ 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<p><code>pop</code></p>
<p>删除数组的最后一个元素并返回该元素. 空数组返回<code>undefined</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr0.pop(), arr0);</span><br><span class="line"><span class="comment">// output: 4 [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.pop(), arr1);</span><br><span class="line"><span class="comment">// output: undefined []</span></span><br></pre></td></tr></table></figure>

<p><code>shift</code></p>
<p>删除并返回数组的第一个元素, 改变原有数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.shift(), arr1);</span><br><span class="line"><span class="comment">// 1 [ 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><code>unshift</code></p>
<p>向数组的开头添加元素并返回现有长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.unshift(<span class="number">9</span>), arr1);</span><br><span class="line"><span class="comment">// 6 [ 9, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p><code>push</code></p>
<p>向数组末尾添加元素并返回数组现有长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.push(<span class="number">4</span>), arr1);</span><br><span class="line"><span class="comment">// output: 4 [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<p><code>reverse</code></p>
<p>颠倒数组中元素顺序, 改变原有数组.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.reverse(), arr1);</span><br><span class="line"><span class="comment">// output: [ 3, 2, 1 ] [ 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure>

<p><code>splice</code> 推荐使用该方法删除数组元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">1</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>); <span class="comment">// 从数组下标为2的位置开始删除1个元素,再插入2个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 'ok', 'fine', 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不留空洞地删除元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line">arr.splice(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 从下标为3的位置开始, 删除2个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 'ok', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p><code>delete</code>  JS运算符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr); <span class="comment">// 留下了空洞</span></span><br><span class="line"><span class="comment">// undefined [ &lt;1 empty item&gt;, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>





<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>Array.forEach()</p>
<blockquote>
<p>对数组的每个元素均执行一次函数(回调函数)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 该函数的参数1为数组元素,参数2为数组元素下标,参数3为该数组本身</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  s += (val + <span class="string">'/'</span> + index + <span class="string">' '</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// 1/0 2/1 ok/2 fine/3 you/4 bye/5</span></span><br></pre></td></tr></table></figure>

<p>Array.map()</p>
<blockquote>
<p>对数组的每个元素均执行函数, 对其做一些处理, 来生成新数组. <strong>不改变原数组</strong>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.map(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> val + <span class="string">'*'</span> + index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 原数组不变</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2, arr);</span><br><span class="line"><span class="comment">// [ '1*0', '2*1', 'ok*2', 'fine*3', 'you*4', 'bye*5' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p>Array.filter()</p>
<blockquote>
<p>对数组的每个元素均执行函数, 筛选符合条件的元素来生成新数组.<strong>不改变原数组</strong>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.filter(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2, arr);</span><br><span class="line"><span class="comment">// [ 'ok', 'fine', 'you', 'bye' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p>Array.reduce()</p>
<blockquote>
<p>参数<code>total</code> 默认是数组的第一个元素, 可以设置初始值.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'bye'</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"total="</span>, total, val, index); <span class="comment">// 从index=1开始打印</span></span><br><span class="line">  <span class="keyword">return</span> total + <span class="string">'*'</span> + val;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">total= bye hi 1</span></span><br><span class="line"><span class="comment">total= bye*hi ok 2</span></span><br><span class="line"><span class="comment">total= bye*hi*ok fine 3</span></span><br><span class="line"><span class="comment">total= bye*hi*ok*fine you 4</span></span><br><span class="line"><span class="comment">total= bye*hi*ok*fine*you bye 5</span></span><br><span class="line"><span class="comment">bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置total初始值</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'bye'</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + <span class="string">'*'</span> + val;</span><br><span class="line">&#125;, <span class="string">"this is :"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// this is :*bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p>Array.reduceRight()</p>
<blockquote>
<p>类似于<code>Array.reduce()</code>, 只不过是从右往左遍历元素.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'bye1'</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye2'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduceRight(<span class="function">(<span class="params">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + <span class="string">'*'</span> + val;</span><br><span class="line">&#125;, <span class="string">"this is res:"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// this is res:*bye2*you*fine*ok*hi*bye1 [ 'bye1', 'hi', 'ok', 'fine', 'you', 'bye2' ]</span></span><br></pre></td></tr></table></figure>

<p>Array.every()</p>
<blockquote>
<p>检查数组中的元素是否都符合条件, 都符合才返回true, 否则返回false.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有元素不符合条件 false</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.every(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// false [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有元素均符合条件 true</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.every(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'number'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// true [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>Array.some()</p>
<blockquote>
<p>检查是否有元素符合条件, 有则返回true, 没有则返回false.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有元素符合条件 true</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.some(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// true [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有元素均不符合条件 false</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.some(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// false [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>Array.indexOf()</p>
<blockquote>
<p>找到给定元素在数组中的位置, 没有则返回-1, 找到则返回元素下标.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找不到 -1, 找到就下标</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.indexOf(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> res2 = arr.indexOf(<span class="string">'how'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1, res2); <span class="comment">// -1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素多次出现 返回第一次出现的位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>];</span><br><span class="line"><span class="keyword">let</span> res2 = arr.indexOf(<span class="string">'Bob'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定搜索位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>];</span><br><span class="line"><span class="keyword">let</span> res2 = arr.indexOf(<span class="string">'Bob'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索起始位置可以是负值</span></span><br><span class="line"><span class="comment">// 负值是从数组末尾给定位置开始搜索, 直至末尾.</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.indexOf(<span class="string">'Bob'</span>, <span class="number">-1</span>), <span class="comment">// 从倒数第一个位置开始, 搜索不到</span></span><br><span class="line">    res2 = arr.indexOf(<span class="string">'Bob'</span>, <span class="number">-2</span>); <span class="comment">// 从倒数第二个位置开始搜索, 是可以检索到的, 返回正数下标</span></span><br><span class="line"><span class="built_in">console</span>.log(res1, res2); <span class="comment">// -1 5</span></span><br></pre></td></tr></table></figure>

<p>Array.lastIndexOf()</p>
<blockquote>
<p>与上一个类似, 只是从数组末尾开始检索.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出现两次Bob, 但是返回了从右往左的第一个.</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.lastIndexOf(<span class="string">'Bob'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定搜索起始位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.lastIndexOf(<span class="string">'Bob'</span>, <span class="number">-3</span>); <span class="comment">// 从倒数第三个元素开始往左搜索, 返回匹配的第一个元素的下标</span></span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>Array.find()</p>
<blockquote>
<p>返回符合条件的第一个元素</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'good'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.find(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> val.length &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// good</span></span><br></pre></td></tr></table></figure>

<p>Array.findIndex()</p>
<blockquote>
<p>返回符合条件的第一个元素<strong>下标</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'good'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.findIndex(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> val.length &gt; <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h3 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象 Object"></a>对象 Object</h3><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><blockquote>
<p>部署在object对象自身的方法</p>
</blockquote>
<p><code>Object.values</code> 获取对象的所有key, 输出类型为数组</p>
<p><code>Object.keys</code> 获取对象的所有value, 输出类型为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">key1</span>:<span class="string">'val1'</span>, <span class="attr">key2</span>:<span class="string">'val2'</span>, <span class="attr">key3</span>:<span class="string">'val3'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// [ 'val1', 'val2', 'val3' ]</span></span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyNames</code> 也是返回对象的所有属性名, 但是还会返回不可枚举的属性; 可枚举属性方面, 与<code>Object.keys</code>相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可枚举属性 二者不同</span></span><br><span class="line"><span class="keyword">let</span> obj1 = [<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'jinling'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj1)); <span class="comment">// [ '0', '1', '2' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj1)); <span class="comment">// [ '0', '1', '2', 'length' ] 包含不可枚举属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可枚举属性 二者相同</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">key1</span>:<span class="string">'val1'</span>, <span class="attr">key2</span>:<span class="string">'val2'</span>, <span class="attr">key3</span>:<span class="string">'val3'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">// [ 'key1', 'key2', 'key3' ]</span></span><br></pre></td></tr></table></figure>



<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p><code>Object.hasOwnProperty</code>判断对象是否拥有某项属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">key1</span>:<span class="string">'val1'</span>, <span class="attr">key2</span>:<span class="string">'val2'</span>, <span class="attr">key3</span>:<span class="string">'val3'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'key2'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>特殊的函数, 由<strong>类表达式</strong>和<strong>类声明</strong>组成</p>
<h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><ol>
<li><p>类声明 带有<code>class</code>关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类需要先声明 再使用 不像函数声明会提升</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类表达式 可以具名或者匿名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello.name); <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名类</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="class"><span class="keyword">class</span> <span class="title">hello2</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello.name); <span class="comment">// hello2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传统的基于函数的类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  speak()&#123;</span><br><span class="line">    <span class="keyword">super</span>.speak();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' barks.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog(<span class="string">'cookie'</span>)</span><br><span class="line">d.speak(); </span><br><span class="line"><span class="comment">// cookie makes a noise.</span></span><br><span class="line"><span class="comment">// cookie barks.</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="类体和方法定义"><a href="#类体和方法定义" class="headerlink" title="类体和方法定义"></a>类体和方法定义</h4><p><code>constructor</code> </p>
<p>构造函数, 一种特殊方法, 创建和初始化一个由class创建的对象. </p>
<p>构造函数可以使用<code>super</code>调用父类的构造函数.</p>
<h4 id="extends创建子类"><a href="#extends创建子类" class="headerlink" title="extends创建子类"></a><code>extends</code>创建子类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  speak () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> make a noise`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, sex) &#123;</span><br><span class="line">    <span class="comment">// 调用超类构造函数并传入name参数</span></span><br><span class="line">    <span class="comment">// 必须先super 然后才能使用this</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  speak () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span> and barks`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog1(<span class="string">'cookie'</span>, <span class="string">'girl'</span>);</span><br><span class="line">d.speak(); <span class="comment">// cookie is girl and barks</span></span><br></pre></td></tr></table></figure>



<h3 id="操作符-typeof"><a href="#操作符-typeof" class="headerlink" title="操作符 typeof"></a>操作符 typeof</h3><h4 id="判断变量数据类型"><a href="#判断变量数据类型" class="headerlink" title="判断变量数据类型"></a>判断变量数据类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="comment">// 通用数据类型</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="string">'jinling'</span> + <span class="string">'\n'</span> +  <span class="comment">// string</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="number">23</span> + <span class="string">'\n'</span> + <span class="comment">// number</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="literal">true</span> + <span class="string">'\n'</span> +  <span class="comment">// boolean</span></span><br><span class="line">	<span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] + <span class="string">'\n'</span> + <span class="comment">// object</span></span><br><span class="line">	<span class="keyword">typeof</span> &#123;<span class="attr">k1</span>:<span class="string">'v1'</span>, <span class="attr">k2</span>:<span class="string">'v2'</span>&#125; + <span class="string">'\n'</span> <span class="comment">// object</span></span><br><span class="line">  <span class="comment">// 特殊字符类型</span></span><br><span class="line">  <span class="keyword">typeof</span> <span class="literal">null</span> + <span class="string">'\n'</span> + <span class="comment">// object</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="literal">undefined</span> + <span class="string">'\n'</span> + <span class="comment">// undefined</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="literal">NaN</span> + <span class="string">'\n'</span> <span class="comment">// number</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined与null值相同,但类型不同</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>===<span class="literal">null</span>, <span class="literal">undefined</span>==<span class="literal">null</span>); <span class="comment">// false true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数组可以用 Array.isArray</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(&#123;<span class="attr">k1</span>:<span class="string">'v1'</span>, <span class="attr">k2</span>:<span class="string">'v2'</span>&#125;)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="undefined-与-null-区别"><a href="#undefined-与-null-区别" class="headerlink" title="undefined 与 null 区别"></a>undefined 与 null 区别</h4><p><code>undefined</code>  : 一般表示某个变量被声明过, 但从未被赋过值, 则默认赋值<code>undefined</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">// undefined undefined</span></span><br></pre></td></tr></table></figure>

<p><code>null</code> : 表示主动释放指向对象的引用.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 释放指向数组的引用</span></span><br></pre></td></tr></table></figure>



<h3 id="关键字-this"><a href="#关键字-this" class="headerlink" title="关键字 this"></a>关键字 this</h3><blockquote>
<p>js中this随着执行环境的变化而变化</p>
</blockquote>
<h4 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的<code>this</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	size : <span class="number">14</span>,</span><br><span class="line">	color: <span class="string">'red'</span>,</span><br><span class="line">	getColor: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'颜色是'</span> + <span class="keyword">this</span>.color</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该实例中, this指向getColor方法所在的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getColor) <span class="comment">// [Function: getColor]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getColor()) <span class="comment">// 颜色是red (加括号表示调用方法)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法中的this单独打印, 会打印出所属对象的内容</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName  : <span class="string">"John"</span>,</span><br><span class="line">  lastName   : <span class="string">"Doe"</span>,</span><br><span class="line">  id         : <span class="number">5566</span>,</span><br><span class="line">  myFunction : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.myFunction()); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  firstName: 'John',</span></span><br><span class="line"><span class="comment">  lastName: 'Doe',</span></span><br><span class="line"><span class="comment">  id: 5566,</span></span><br><span class="line"><span class="comment">  myFunction: [Function: myFunction]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="单独使用this"><a href="#单独使用this" class="headerlink" title="单独使用this"></a>单独使用<code>this</code></h4><p>无论有无严格模式, <code>this</code>始终指向全局对象. 浏览器中, 全局对象为<code>[object Window]</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 'use strict'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="函数中使用this"><a href="#函数中使用this" class="headerlink" title="函数中使用this"></a>函数中使用<code>this</code></h4><p>函数中, 默认<code>this</code>指向全局对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>严格模式下不允许默认绑定, 所以函数中的<code>this</code>为<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFunction()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li><p>避免使用 全局变量 <code>new</code> <code>===</code> <code>eval()</code></p>
</li>
<li><p>所有声明放在脚本或者函数的顶部, <strong>顶部声明, 稍后使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在顶部声明</span></span><br><span class="line"><span class="keyword">var</span> firstName, lastName, price, discount, fullPrice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍后使用</span></span><br><span class="line">firstName = <span class="string">"Bill"</span>;</span><br><span class="line">lastName = <span class="string">"Gates"</span>;</span><br><span class="line"></span><br><span class="line">price = <span class="number">19.90</span>;</span><br><span class="line">discount = <span class="number">0.10</span>;</span><br><span class="line"></span><br><span class="line">fullPrice = price * <span class="number">100</span> / discount;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明变量时同时初始化</p>
</li>
<li><p>将数值/字符串/布尔值声明为原始值而非对象, 否则会拖慢速度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">'bill'</span> <span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'bill'</span>) <span class="comment">// 对象</span></span><br><span class="line"><span class="built_in">console</span>.log(x===y); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请勿使用 new Object()</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">推荐使用</th>
<th align="center">不建议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{}</td>
<td align="center">new Object()</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">new Array()</td>
</tr>
<tr>
<td align="center">function (){}</td>
<td align="center">new Function()</td>
</tr>
<tr>
<td align="center">“”</td>
<td align="center">new String()</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">new Number()</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">new Boolean()</td>
</tr>
<tr>
<td align="center">/()/</td>
<td align="center">new RegExp()</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>意识到自动类型转换, 变量可以通过赋值改变其数据类型, 变量可包含不同的数据类型.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'hello'</span></span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为函数中的参数设置默认值, <code>undefined</code> 会破坏代码</p>
</li>
<li><p>用<code>default</code>来结束<code>switch</code>.</p>
</li>
</ol>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><blockquote>
<p>原因</p>
</blockquote>
<p>js代码中会出现错误, 由于编写代码/编译/用户输入等各种各样的原因.</p>
<blockquote>
<p>处理</p>
</blockquote>
<p>发生错误时, js引擎会停止并生成一个错误消息.</p>
<p>try与catch成对出现, finally是最后一定会执行的语句(可以没有).</p>
<p>throw抛出错误, 实际上就是抛出一个表示错误信息的字符串s, 因此可以自定义错误.</p>
<p>在catch中可以捕获s,实际上就是可以获得s的值并打印出来.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="string">''</span>) <span class="keyword">throw</span> <span class="string">'is kong'</span></span><br><span class="line">    <span class="keyword">if</span> (x === <span class="string">'1'</span>) <span class="keyword">throw</span> <span class="string">'is 1'</span></span><br><span class="line">    <span class="keyword">if</span> (x === <span class="string">'2'</span>) <span class="keyword">throw</span> <span class="string">'is 2'</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'1'</span>); <span class="comment">// is 1</span></span><br><span class="line">test(<span class="string">''</span>); <span class="comment">// is kong</span></span><br></pre></td></tr></table></figure>



<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><blockquote>
<p>操作</p>
</blockquote>
<p>设置断点, 检查变量值, 浏览器内置调试器(按下F12, 选择<code>console</code>)</p>
<blockquote>
<p><code>debugger</code>关键字</p>
</blockquote>
<p>代码会在<code>debugger</code>行停下, 并执行调试函数. 没有调试函数则不起作用.</p>
<p>与在调试工具中设置断点效果一样.</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><blockquote>
<p>原因</p>
</blockquote>
<p><code>use strict</code> </p>
<p>消除js语法的不合理之处, 保证代码安全; 增加编译效率;</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>只能放在脚本或者函数的开头</p>
<blockquote>
<p>具体内容</p>
</blockquote>
<ul>
<li>禁止使用未定义/声明的变量</li>
<li>禁止删除变量/函数</li>
<li>禁止变量重名</li>
<li>禁止使用八进制/转义字符</li>
<li>禁止对只读属性赋值</li>
<li>禁止删除不能删除的属性, 比如prototype</li>
<li>禁止变量名为eval/arguments</li>
<li>禁止使用右侧类似语句 with (Math){x = cos(2)};</li>
<li>禁止在作用域eval创建的变量被使用</li>
<li>禁止this指向全局对象</li>
</ul>
]]></content>
      <tags>
        <tag>-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Sort</title>
    <url>/2020/09/17/Sort/</url>
    <content><![CDATA[<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4>]]></content>
  </entry>
  <entry>
    <title>Linked-list</title>
    <url>/2020/09/11/Linked-list/</url>
    <content><![CDATA[<h4 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="[2] Add Two Numbers"></a>[2] Add Two Numbers</h4><blockquote>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
</blockquote>
<p>复杂的数据结构是我的超级短板. 但是也算勉强看懂了js是如何表示链表的.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 这个链表的存储结构是嵌套的, 即next指向的是嵌套的.</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义存储想关节点的变量</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> lastNode = result;</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">  <span class="keyword">let</span> val = <span class="number">0</span>; <span class="comment">// 相加之后赋给当前位置的值</span></span><br><span class="line">  <span class="comment">// 当l1或者l2任何一方有值时, 都需要进行相加</span></span><br><span class="line">  <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">    <span class="comment">// 获取两个链表的初始值</span></span><br><span class="line">    <span class="keyword">let</span> x = l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">    <span class="keyword">let</span> y = l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">    <span class="comment">// 两者相加</span></span><br><span class="line">    <span class="keyword">let</span> num = x + y + carry;</span><br><span class="line">    carry = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>); <span class="comment">// 商</span></span><br><span class="line">    val = num % <span class="number">10</span>; <span class="comment">// 相加之后赋给当前位置的值</span></span><br><span class="line">    <span class="comment">// 新建节点添加到链表末尾</span></span><br><span class="line">    lastNode.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    <span class="comment">// 最后节点位置更新</span></span><br><span class="line">    lastNode = lastNode.next;</span><br><span class="line">    <span class="comment">// 进行下一位置的加法</span></span><br><span class="line">    <span class="keyword">if</span> (l1 !== <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">    <span class="keyword">if</span> (l2 !== <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当两个加数位数都加完了</span></span><br><span class="line">  <span class="comment">// 但是仍然可能会有进位的可能</span></span><br><span class="line">  <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">    lastNode.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">示例结果</span></span><br><span class="line"><span class="comment">====result.next</span></span><br><span class="line"><span class="comment">ListNode &#123;</span></span><br><span class="line"><span class="comment">  val: 7,</span></span><br><span class="line"><span class="comment">  next: ListNode &#123;</span></span><br><span class="line"><span class="comment">    val: 0,</span></span><br><span class="line"><span class="comment">    next: ListNode &#123;</span></span><br><span class="line"><span class="comment">      val: 8,</span></span><br><span class="line"><span class="comment">      next: null</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="[21] Merge Two Sorted Lists"></a>[21] Merge Two Sorted Lists</h4><blockquote>
<p>Merge two sorted linked lists and return it as a new <strong>sorted</strong> list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<p>解题的重点在于, 一直将l1和l2的链表头作比较, 不断将较小的node加入结果链表, 直至l1或者l2为空, 说明遍历结束. 把不为空的链表剩余的部分直接接入结果列表.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理有链表为空的情况</span></span><br><span class="line">  <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> curr = res;</span><br><span class="line">  <span class="comment">// 网上的做法好简洁</span></span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">      curr.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curr.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  curr.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="[24] Swap Nodes in Pairs"></a>[24] Swap Nodes in Pairs</h4><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
</blockquote>
<p>在交换链表的时候, 第一次交换需要记住链表头.</p>
<p>确定 <code>curr</code> 之后, 只有 <code>curr.next!=null</code> 时才有交换的必要, 否则说明交换到头了, 返回 <code>head</code> 即可.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 第一次交换的时候 需要记住链表头 后面就不需要了</span></span><br><span class="line">  <span class="comment">// 只有当 curr.next 也有值的时候, 才交换</span></span><br><span class="line">  <span class="comment">// 否则就直接返回</span></span><br><span class="line">  <span class="keyword">while</span> (curr &amp;&amp; curr.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = curr.next.next;</span><br><span class="line">    <span class="keyword">let</span> nextNode = curr.next;</span><br><span class="line">    nextNode.next = curr;</span><br><span class="line">    left.next = nextNode;</span><br><span class="line">    curr.next = temp;</span><br><span class="line">    left = curr;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">      head = nextNode;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="[61] Rotate List"></a>[61] Rotate List</h4><blockquote>
<p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> * 大体思路是: </span></span><br><span class="line"><span class="comment"> * 先计算出链表的长度len, 再将k与len进行比较, </span></span><br><span class="line"><span class="comment"> * k&gt;len的话, 将k中len的整数倍减去之后, 就是最后需要移动的元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rotateRight = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算链表长度</span></span><br><span class="line">  <span class="comment">// 此时right指向最后一个元素</span></span><br><span class="line">  <span class="keyword">let</span> left = head, right = head, len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (right.next) &#123;</span><br><span class="line">    right = right.next;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span> || k == len) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取余之后是实际上需要移动的元素</span></span><br><span class="line">  <span class="keyword">let</span> num = k % len;</span><br><span class="line">  <span class="comment">// 由于在计算链表长度的时候, right已经指向链表尾部</span></span><br><span class="line">  <span class="comment">// 左右指针间隔k-1个元素</span></span><br><span class="line">  <span class="comment">// 所以左指针需要向右移动len-num-1个位置</span></span><br><span class="line">  <span class="comment">// 具体的边界条件可以在测试中验证是否正确</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - num - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    left = left.next;</span><br><span class="line">  &#125;</span><br><span class="line">  right.next = head;</span><br><span class="line">  head = left.next;</span><br><span class="line">  left.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="[23] Merge k Sorted Lists"></a>[23] Merge k Sorted Lists</h4><blockquote>
<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>
<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>
</blockquote>
<p><strong>solution1</strong> 的时间复杂度分析:</p>
<p>时间复杂度: 遍历链表+排序+遍历数组<br>    假设总node数为 $N$ , 则总时间复杂度为 $O(N)+O(NlogN)+O(N)=O(N)$<br>空间复杂度为: $O(N)$ , 主要是存储节点的数组的消耗</p>
<p><strong>solution2</strong> 的时间复杂度分析:</p>
<p>设k=lists.length, $N$ 为所有节点数, 则复杂度为=归并次数*每一次归并的时间复杂度<br>每一次归并需要遍历所有的节点, 但是不需要排序, 仅仅是大小比较, $O(N)$<br>设一共归并的次数为x, 则有 $2^x = k$ , 则 $ x = \log_2 k$ (以2为底k的对数)<br>所以总共的时间复杂度是 $\sum_0^x * O(N)=O(N\log k)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="comment">// 把链表中的节点值都拿出来放在一个数组里</span></span><br><span class="line"><span class="comment">// 然后对数组进行排序</span></span><br><span class="line"><span class="keyword">var</span> mergeKLists1 = <span class="function"><span class="keyword">function</span> (<span class="params">lists</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> len = lists.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> arr = [], l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    l = lists[i];</span><br><span class="line">    <span class="keyword">while</span> (l) &#123;</span><br><span class="line">      arr.push(l.val);</span><br><span class="line">      l = l.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 正序排列</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> curr = res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    curr.next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="comment">// 分治算法 这是一开始就想到的方法 但是不会实现🤦‍♀️</span></span><br><span class="line"><span class="comment">// 两两链表合并排序, 再将结果再合并, 直至只有一个结果</span></span><br><span class="line"><span class="comment">// 数组长度为奇数, 最后一次合并时, 是第一个与最后一个元素合并, interval*2之后会&lt;len, 继续进行最后一次合并</span></span><br><span class="line"><span class="comment">// 数组长度为奇数, 最后一次合并时, 是第一个与中间元素合并, interval*2之后会=len, 跳出循环</span></span><br><span class="line"><span class="keyword">var</span> mergeKLists = <span class="function"><span class="keyword">function</span> (<span class="params">lists</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = lists.length;</span><br><span class="line">  <span class="comment">// 没有链表返回空链表</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> interval = <span class="number">1</span>;<span class="comment">// 标志需要合并的两个链表之间的距离</span></span><br><span class="line">  <span class="comment">// 归并排序的代码更像模板</span></span><br><span class="line">  <span class="comment">// 只要两个元素之间的距离没有超过数组长度, 说明没有归并完毕</span></span><br><span class="line">  <span class="keyword">while</span> (interval &lt; len) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - interval; i = i + interval * <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// i的作用是, 找到所有需要合并的链表中的第一个</span></span><br><span class="line">      <span class="comment">// 不断地把相隔interval距离的两个链表合并</span></span><br><span class="line">      lists[i] = mergeTwoLists(lists[i], lists[i + interval])</span><br><span class="line">    &#125;</span><br><span class="line">    interval = interval * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个链表</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function">(<span class="params">l1, l2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> curr = res;</span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">      curr.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curr.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  curr.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="[25] Reverse Nodes in k-Group"></a>[25] Reverse Nodes in k-Group</h4><blockquote>
<p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
</blockquote>
<p>时间复杂度分析:</p>
<p>$O(N)$ , $N$为链表总节点数, 翻转时需要遍历所有的节点. 一共会进行$\lfloor N/k \rfloor$ 次翻转, 每一次翻转需要$O(k)$的时间.</p>
<p>空间复杂度: 常量级别.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大体思路是 每k个元素进行一次翻转</span></span><br><span class="line"><span class="comment">// 在翻转之前查看接下来的链表长度是否足够</span></span><br><span class="line"><span class="comment">// 足够则翻转 不够则停下并返回结果</span></span><br><span class="line"><span class="comment">// 翻转时注意连接前后链表的部分</span></span><br><span class="line"><span class="keyword">var</span> reverseKGroup = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在链表头节点前加一个节点</span></span><br><span class="line">  <span class="comment">// 后面翻转后的链表再与原来的链表连接要用到</span></span><br><span class="line">  <span class="keyword">let</span> hair = <span class="keyword">new</span> ListNode(<span class="literal">null</span>, head);</span><br><span class="line">  <span class="keyword">let</span> pre = hair;</span><br><span class="line">  <span class="comment">// tail需要以pre为起点, 向后移动k个位置</span></span><br><span class="line">  <span class="keyword">let</span> tail = hair, right;</span><br><span class="line">  <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">    <span class="comment">// 将 tail 移动至需要翻转的链表部分的末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      tail = tail.next;</span><br><span class="line">      <span class="comment">// 如果 tail 在向后移动但是还没有到目标位置时</span></span><br><span class="line">      <span class="comment">// 出现 tail 为 null 的情况</span></span><br><span class="line">      <span class="comment">// 说明剩余的元素已经不够翻转的数量</span></span><br><span class="line">      <span class="comment">// 直接返回现有结果即可</span></span><br><span class="line">      <span class="keyword">if</span> (!tail) <span class="keyword">return</span> hair.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// head-tail的链表部分需要翻转</span></span><br><span class="line">    <span class="comment">// 且翻转需要head和tail仍指向翻转后链表的头和尾</span></span><br><span class="line">    <span class="comment">// 保留tail的后面部分</span></span><br><span class="line">    right = tail.next;</span><br><span class="line">    [head, tail] = reverse(head, tail);</span><br><span class="line">    <span class="comment">// 进行与原链表的拼接</span></span><br><span class="line">    pre.next = head;</span><br><span class="line">    tail.next = right;</span><br><span class="line">    <span class="comment">// 改变pre head的位置</span></span><br><span class="line">    pre = tail;</span><br><span class="line">    head = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="comment">// 这里不用再初始化res来存储翻转后的结果</span></span><br><span class="line"><span class="comment">// 因为tail.next是存在的</span></span><br><span class="line"><span class="comment">// 可以看做已有的res使用</span></span><br><span class="line"><span class="comment">// 使用常数级的内存空间</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function">(<span class="params">head, tail</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = head;</span><br><span class="line">  <span class="keyword">let</span> remain = tail.next; <span class="comment">// 表示剩余不用翻转的部分</span></span><br><span class="line">  <span class="keyword">let</span> nex;</span><br><span class="line">  <span class="keyword">while</span> (p !== tail) &#123;</span><br><span class="line">    nex = p.next;</span><br><span class="line">    p.next = remain;</span><br><span class="line">    remain = p;</span><br><span class="line">    p = nex;</span><br><span class="line">  &#125;</span><br><span class="line">  tail.next = remain;</span><br><span class="line">  <span class="keyword">return</span> [tail, head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="[83] Remove Duplicates from Sorted List"></a>[83] Remove Duplicates from Sorted List</h4><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
</blockquote>
<p>思路比较简单, 由于最坏情况是遍历链表的所有节点(当所有节点的值均不相同),  时间复杂度为 $O(N)$ .</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于是排过序的链表</span></span><br><span class="line"><span class="comment">// 所以重复元素都会在一块</span></span><br><span class="line"><span class="comment">// 不断比较curr与curr.next的val是否相等</span></span><br><span class="line"><span class="comment">// 相等则跳过该重复元素,不等才改变curr的位置</span></span><br><span class="line"><span class="comment">// 直至curr遍历完链表的所有元素</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="comment">// 最后一个元素是不同元素 到达链表末尾</span></span><br><span class="line">    <span class="keyword">if</span> (!curr.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">while</span> (curr.val == curr.next.val) &#123;</span><br><span class="line">      curr.next = curr.next.next;</span><br><span class="line">      <span class="comment">// 最后一个元素是相同元素 到达链表末尾</span></span><br><span class="line">      <span class="keyword">if</span> (!curr.next) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="[82] Remove Duplicates from Sorted List II"></a>[82] Remove Duplicates from Sorted List II</h4><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p>Return the linked list sorted as well.</p>
</blockquote>
<p>遍历链表的所有节点两次,  时间复杂度为 $2*O(N) = O(N)$ .</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历两次链表</span></span><br><span class="line"><span class="comment">// 第一次按照顺序将所有不同的元素组成链表, 并给有重复元素的节点增加dup属性</span></span><br><span class="line"><span class="comment">// 第二次将有dup属性的节点删除, 返回结果</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!curr.next) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr.val == curr.next.val) &#123;</span><br><span class="line">      curr.dup = <span class="literal">true</span>;</span><br><span class="line">      curr.next = curr.next.next;</span><br><span class="line">      <span class="keyword">if</span> (!curr.next) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hair = <span class="keyword">new</span> ListNode(<span class="literal">null</span>, head);</span><br><span class="line">  <span class="keyword">let</span> pre = hair, point = head;</span><br><span class="line">  <span class="keyword">while</span> (point) &#123;</span><br><span class="line">    <span class="keyword">while</span> (point.dup) &#123;</span><br><span class="line">      point = point.next;</span><br><span class="line">      <span class="keyword">if</span> (!point) &#123;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> hair.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = point;</span><br><span class="line">    pre = point;</span><br><span class="line">    point = point.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="[142] Linked List Cycle II"></a>[142] Linked List Cycle II</h4><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>
<p><strong>Notice</strong> that you <strong>should not modify</strong> the linked list.</p>
</blockquote>
<p>这里需要证明下有环情况下, 为什么快慢指针第一次相遇之后, 快指针到链表头, 再和慢指针一起以每次一步的速度前进, 当二者相等时, 即是环的起点.</p>
<p><strong>证明</strong>:</p>
<img src="/2020/09/11/Linked-list/image.png" class="" title="image.png">

<p>我们最终需要证明a=b. 假设链表总长度为L, 环的长度为R, 快慢指针第一次相遇的节点为M, 环的开始节点为C, 其中各个点之间的距离分别为 H-&gt;C=a, C-&gt;M=c, M-&gt;C=b, H-&gt;M=s. 第一次相遇时, 假设fast已经围绕着环走了n圈, 则有:</p>
<p>由于快慢指针的速度差两倍, 所以相同时间内, 快指针走过的距离是慢指针的两倍.</p>
<p>$2s = s + nR \-&gt; s = nR \tag{1}$</p>
<p>已知慢指针走的长度为(套用$(1)$):</p>
<p>$a+c = s \-&gt; a+c=nR \-&gt; a + c = (n-1)R + R \-&gt; a = (n-1)R + (R - c) \-&gt;  a = (n-1)R +b$</p>
<p>则得出结论 $a=b$, (这个还要再想下).</p>
<p>所以fast移动到head, slow位置不变, 两个同时开始走, 每次走一步, 当走了a步时,两者相遇的点即为环的起点.</p>
<p><strong>时间复杂度</strong>:</p>
<p>可知快慢指针走的步数是一样的, 只是一个快一个慢, 慢指针最后遍历了整个链表, 走了N步, 则快指针也走了N步, 则时间复杂度为: $2*O(N)= O(N)$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用快慢指针</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 快慢指针的起始点应该一样</span></span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">    <span class="comment">// 快指针的速度是慢指针的2倍</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    <span class="comment">// 在没有环的情况下</span></span><br><span class="line">    <span class="comment">// fast指针会最先到达链表尾部, 直接返回null;</span></span><br><span class="line">    <span class="comment">// fast指针最后的位置,要不倒数第一,要不倒数第二</span></span><br><span class="line">    <span class="comment">// 与链表长度的奇偶数以及每次走的步数有关</span></span><br><span class="line">    <span class="comment">// 这里fast指针是每次走两步</span></span><br><span class="line">    <span class="keyword">if</span> (!fast.next) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    <span class="keyword">if</span> (!fast) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 说明有环 两指针第一次相遇</span></span><br><span class="line">    <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">      <span class="comment">// 快指针移动至链表头</span></span><br><span class="line">      <span class="comment">// 慢指针停在原地</span></span><br><span class="line">      fast = head;</span><br><span class="line">      <span class="comment">// 二者均以每次一步的速度继续向前走, 直至再次相遇</span></span><br><span class="line">      <span class="comment">// 这里方法需要证明</span></span><br><span class="line">      <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回的是环的起始节点的指针</span></span><br><span class="line">      <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="[138] Copy List with Random Pointer"></a>[138] Copy List with Random Pointer</h4><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> of the list.</p>
<p>The Linked List is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>
<ul>
<li><code>val</code>: an integer representing <code>Node.val</code></li>
<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) where random pointer points to, or <code>null</code> if it does not point to any node.</li>
</ul>
</blockquote>
<p><strong>时间复杂度:</strong> 遍历两遍数组 $O(N)$.</p>
<p><strong>经验/收获</strong>: </p>
<ol>
<li>一开始我的问题在于试错, 都没有搞清楚<code>random_index</code>属性是否在题目给的链表结构中存在, 我还以为有<code>random_index</code>这个属性呢, 实际上没有.  <code>random</code>数据类型仍然是指针而非number.</li>
<li>搞清楚题目是深拷贝, 不能改变原有链表结构. <strong>需要重新生成新链表</strong>.</li>
<li>收获在于知道如何使用hashMap存储链表间的 links.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求是深拷贝</span></span><br><span class="line"><span class="comment">// 就是不改变原有的链表</span></span><br><span class="line"><span class="comment">// 第一遍是copy all nodes, 使用map存储</span></span><br><span class="line"><span class="comment">// 第二遍是copy links</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// copy nodes</span></span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// map的key可以是任何对象, 不限于字符串</span></span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    map.set(curr, <span class="keyword">new</span> Node(curr.val));</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// copy links</span></span><br><span class="line">  curr = head;</span><br><span class="line">  <span class="keyword">let</span> node = map.get(curr);</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    node.next = curr.next ? map.get(curr.next) : <span class="literal">null</span>;</span><br><span class="line">    node.random = curr.random ? map.get(curr.random) : <span class="literal">null</span>;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="[92] Reverse Linked List II"></a>[92] Reverse Linked List II</h4><blockquote>
<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
</blockquote>
<p><strong>时间复杂度分析</strong>:</p>
<p>假设链表总长度为$N$, 在定位m/n节点的过程中, 一共遍历链表一次, 每次遍历至第n个节点, 最差情况遍历到链表末尾.</p>
<p>翻转时一共需要翻转 $n-m+1$ 个节点, 需要的时间是 $ O(n-m+1)$ .</p>
<p>所以时间复杂度为 $O(N)$ </p>
<p><strong>注意</strong>:</p>
<p>初始化一个节点时, hair不是空, hair.val是空. 刚开始判断pre==null就写错了, 应该是pre.val是否null.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 特殊情况</span></span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (!head.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// 当链表长度足够翻转时, 在head前添加hair节点</span></span><br><span class="line">  <span class="comment">// 为了使用pre节点, pre是pm的前一个节点</span></span><br><span class="line">  <span class="keyword">let</span> hair = <span class="keyword">new</span> ListNode(<span class="literal">null</span>, head);</span><br><span class="line">  <span class="keyword">let</span> pre = hair, curr = head;</span><br><span class="line">  <span class="comment">// 定义变量 注意需要tail指针</span></span><br><span class="line">  <span class="keyword">let</span> pm, pn, tail;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定位m节点</span></span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">    pm = head; <span class="comment">// pm直接是头节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// m-1次循环到达pm节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// pre节点也需要同时向后移动</span></span><br><span class="line">      <span class="comment">// 保证在pm前一位</span></span><br><span class="line">      curr = curr.next;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pm = curr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定位n节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  pn = curr;</span><br><span class="line">  <span class="comment">// 翻转前保留尾部数据</span></span><br><span class="line">  tail = curr.next;</span><br><span class="line">  <span class="comment">// 翻转</span></span><br><span class="line">  <span class="keyword">while</span> (pm != pn) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = pm.next;</span><br><span class="line">    pm.next = tail;</span><br><span class="line">    tail = pm;</span><br><span class="line">    pm = temp;</span><br><span class="line">    pre.next = tail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// pm==pn时还需要连接下tail</span></span><br><span class="line">  pm.next = tail;</span><br><span class="line">  <span class="comment">// 连接</span></span><br><span class="line">  pre.next = pm;</span><br><span class="line">  <span class="comment">// 这里返回hair.next即可</span></span><br><span class="line">  <span class="comment">// 不用分析pre是否为空</span></span><br><span class="line">  <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="[147] Insertion Sort List"></a>[147] Insertion Sort List</h4><blockquote>
<p>Sort a linked list using insertion sort.</p>
</blockquote>
<p>时间复杂度分析:</p>
<p>遍历链表一次, $O(N)$</p>
<p>每到链表的一个节点, 就会扫描排好序的链表部分, 时间为 $O(1)+O(2)+O(3)+…+O(N-1)$</p>
<p>则时间复杂度为: $O(1)+O(2)+…+O(N)=O((N^2+N)/2)=O(N^2)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用插入排序对链表进行排序</span></span><br><span class="line"><span class="comment">// 插入排序是: 不断将没有排序的元素加入已经排好序的部分</span></span><br><span class="line"><span class="comment">// 单向链表只能从前往后遍历</span></span><br><span class="line"><span class="comment">// 这里顺便学习了单向链表</span></span><br><span class="line"><span class="keyword">var</span> insertionSortList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!head.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// 第一个元素默认已经排好序</span></span><br><span class="line">  <span class="comment">// curr 从下一位开始</span></span><br><span class="line">  <span class="keyword">let</span> curr = head.next;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="comment">// 排好序的部分此时只有head一个元素</span></span><br><span class="line">  <span class="comment">// 末尾指向null</span></span><br><span class="line">  <span class="comment">// 与需要排序的部分分开</span></span><br><span class="line">  head.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> cn, hn;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="comment">// 保留curr的后一部分</span></span><br><span class="line">    cn = curr.next;</span><br><span class="line">    <span class="comment">// curr比有序的第一个元素小</span></span><br><span class="line">    <span class="comment">// 则直接置于有序部分的头部</span></span><br><span class="line">    <span class="keyword">if</span> (curr.val &lt;= head.val) &#123;</span><br><span class="line">      curr.next = head;</span><br><span class="line">      head = curr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// curr 比第一个有序元素大</span></span><br><span class="line">      <span class="comment">// 则需要遍历后面的有序元素</span></span><br><span class="line">      <span class="comment">// 直到找到有序排列中比curr大的元素x</span></span><br><span class="line">      <span class="comment">// 则curr插入到 x的前面</span></span><br><span class="line">      <span class="comment">// 为了保留 x 的前一个节点</span></span><br><span class="line">      <span class="comment">// 将curr.val与h.next.val进行比较, 而不是h.val</span></span><br><span class="line">      <span class="keyword">let</span> h = head;</span><br><span class="line">      <span class="keyword">while</span> (h.next &amp;&amp; curr.val &gt; h.next.val) &#123;</span><br><span class="line">        h = h.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将curr插入至 h 与 x 节点之间</span></span><br><span class="line">      hn = h.next;</span><br><span class="line">      h.next = curr;</span><br><span class="line">      curr.next = hn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// curr向后移动一位</span></span><br><span class="line">    curr = cn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="[203] Remove Linked List Elements"></a>[203] Remove Linked List Elements</h4><blockquote>
<p>Remove all elements from a linked list of integers that have value <strong><em>val\</em></strong>.</p>
</blockquote>
<p>时间复杂度: 遍历链表 $O(N)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElements = <span class="function"><span class="keyword">function</span> (<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> hair = <span class="keyword">new</span> ListNode(<span class="literal">null</span>, head);</span><br><span class="line">  <span class="keyword">let</span> pre = hair, curr = head;</span><br><span class="line">  <span class="comment">// pre的移动也是在head表示的这条链表上</span></span><br><span class="line">  <span class="comment">// pre改变的是head本身</span></span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curr.val == val) &#123;</span><br><span class="line">      pre.next = curr.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有个特殊情况需要注意</span></span><br><span class="line">  <span class="comment">// 比如 [1] 1</span></span><br><span class="line">  <span class="comment">// 此时pre还没后移到head链表上</span></span><br><span class="line">  <span class="comment">// 所以pre指向null没有改变head链表</span></span><br><span class="line">  <span class="comment">// head仍然是 [1]</span></span><br><span class="line">  <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="[206] Reverse Linked List"></a>[206] Reverse Linked List</h4><blockquote>
<p>Reverse a singly linked list.</p>
<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
</blockquote>
<p><strong>递归过程</strong>需要详细的过程分析图(<strong>TO DO</strong>).</p>
<p>两种时间复杂度均为 $O(N)$. </p>
<p>递归方法的时间复杂度分析: 遍历整个链表, 递归调用N次.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代翻转</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(1)</span></span><br><span class="line"><span class="keyword">var</span> reverseList1 = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rever = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> temp;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    temp = head.next;</span><br><span class="line">    head.next = rever.next;</span><br><span class="line">    rever.next = head;</span><br><span class="line">    head = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rever.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归翻转</span></span><br><span class="line"><span class="comment">// 需要注意的是, p是指向head的一个指针</span></span><br><span class="line"><span class="comment">// 并不是另外的链表</span></span><br><span class="line"><span class="comment">// 但是由于每一次都会生成p指针重新指向目前已经倒好序的链表</span></span><br><span class="line"><span class="comment">// 所以递归过程中的空间复杂度为O(1)+O(2)+...+O(N)=O(N)</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> p = reverseList(head.next);</span><br><span class="line">  head.next.next = head;</span><br><span class="line">  head.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="[237] Delete Node in a Linked List"></a>[237] Delete Node in a Linked List</h4><blockquote>
<p>Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p>
<p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p>
</blockquote>
<p>注意看题目条件, 时间/空间复杂度均为 $O(N)$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一时没有想起来用什么解法</span></span><br><span class="line"><span class="comment">// 因为之前删除节点都是不能改变节点自身的值</span></span><br><span class="line"><span class="comment">// 现在这个能改变了 害</span></span><br><span class="line"><span class="comment">// 这个方法令我哭笑不得, 也提醒自己注意看题目条件</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="[234] Palindrome Linked List"></a>[234] Palindrome Linked List</h4><blockquote>
<p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>
</blockquote>
<p>时间复杂度: </p>
<p>遍历链表一次, $O(N)$, 后半部分翻转链表的时候, 时间为$O(N/2)$.</p>
<p>所以时间复杂度为: $O(N)+O(N/2)=O(N)$.</p>
<p>方法:</p>
<p>判断回文链表,要求只能遍历一次链表.</p>
<p>将链表<strong>后半段翻转</strong> 再将前后部分分别比较.</p>
<p>然后还有需要注意的是: <strong>快慢指针法寻找链表中心点</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> fast = head, slow = head;</span><br><span class="line">  <span class="keyword">while</span> (fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不管链表长度是奇数还是偶数 需要进行的操作都是一样的</span></span><br><span class="line">  <span class="comment">// slow 为后半部分链表的起点</span></span><br><span class="line">  slow.next = reverse(slow.next);</span><br><span class="line">  slow = slow.next;</span><br><span class="line">  <span class="comment">// 将前后两部分链表逐个节点对值进行比较</span></span><br><span class="line">  <span class="comment">// 如果有值不等 说明不是回文</span></span><br><span class="line">  <span class="comment">// 前半部分的长度是&gt;=后半部分的</span></span><br><span class="line">  <span class="comment">// 所以当slow=null时, head=null或者head是最后一个节点</span></span><br><span class="line">  <span class="comment">// 由于回文的两种形式, 此时就可以结束比较了</span></span><br><span class="line">  <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.val != slow.val) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head = head.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> curr = head, cn, rn;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    cn = curr.next;</span><br><span class="line">    rn = res.next;</span><br><span class="line">    res.next = curr;</span><br><span class="line">    curr.next = rn;</span><br><span class="line">    curr = cn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="[160] Intersection of Two Linked Lists"></a>[160] Intersection of Two Linked Lists</h4><blockquote>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p><strong>Notes:</strong></p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Each value on each linked list is in the range <code>[1, 10^9]</code>.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
</blockquote>
<img src="/2020/09/11/Linked-list/image1.png" class="" title="image1.png">

<p>由图可知:</p>
<p>$headA = A + C$</p>
<p>$headB = B + C$</p>
<p>所以:</p>
<p>$newA = headA + headB = A + C + B + C$</p>
<p>$newB = headB + headA = B + C + A + C$</p>
<p>已知:</p>
<p>$A + C + B = B + C + A$</p>
<p>所以 <code>newA</code>与<code>newB</code>同时出发, 每次都走一步. </p>
<p><code>newA</code>走完<code>headA</code>再走完<code>B</code>,  <code>newB</code>走完<code>headB</code>再走完<code>A</code>, 如果两者有交点, 则此时会相等且不为<code>null</code>;</p>
<p>如果不相交, 则走到最后两者也相等, 但是为<code>null</code>.</p>
<p>时间复杂度:</p>
<p>假设<code>headA</code>和<code>headB</code>总共的长度为<code>N</code>, 则一共遍历了两次, 时间为$2*O(N)$, 时间复杂度为$O(N)$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路很巧妙 需要分析下 最后两个节点一定会相等</span></span><br><span class="line"><span class="comment">// 只是是地址还是null的问题</span></span><br><span class="line"><span class="comment">// 最差情况是不相交</span></span><br><span class="line"><span class="comment">// 每个链表均遍历了两遍</span></span><br><span class="line"><span class="comment">// 但是额外空间只使用了两个指针变量,为常数级</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span> (<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currA = headA, currB = headB;</span><br><span class="line">  <span class="keyword">while</span> (currA != currB) &#123;</span><br><span class="line">    currA = !currA ? headB : currA.next;</span><br><span class="line">    currB = !currB ? headA : currB.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不相交最后也会相等的 均是null</span></span><br><span class="line">  <span class="comment">// 即： 相交或者是不相交， 二者均会相等</span></span><br><span class="line">  <span class="comment">// 相等的话，返回的是及交点地址</span></span><br><span class="line">  <span class="comment">// 不相等的话，返回的是null</span></span><br><span class="line">  <span class="keyword">return</span> currA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="[328] Odd Even Linked List"></a>[328] Odd Even Linked List</h4><blockquote>
<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
</blockquote>
<p>时间复杂度: 两个指针同时遍历, 一共遍历一遍链表. $O(N)$</p>
<p>空间复杂度: 只是新建了两个指针, 改动原有链表, 没有重新生成head的copy版本. $O(1)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完全自己想的法子 太棒了</span></span><br><span class="line"><span class="comment">// 大体思路就是,用两个指针, 一个指向奇数节点, 一个指向偶数节点</span></span><br><span class="line"><span class="comment">// 遍历完head之后, 再将两个链表进行拼接</span></span><br><span class="line"><span class="keyword">var</span> oddEvenList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next || !head.next.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> oddList = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> evenList = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> odd = oddList, even = evenList;</span><br><span class="line">  <span class="comment">// 初始化第一个奇数节点</span></span><br><span class="line">  odd.next = head;</span><br><span class="line">  odd = odd.next;</span><br><span class="line">  <span class="comment">// 初始化第一个偶数节点</span></span><br><span class="line">  even.next = head.next;</span><br><span class="line">  even = even.next;</span><br><span class="line">  <span class="keyword">while</span> (even &amp;&amp; even.next) &#123;</span><br><span class="line">    odd.next = odd.next.next;</span><br><span class="line">    odd = odd.next;</span><br><span class="line">    even.next = even.next.next;</span><br><span class="line">    even = even.next;</span><br><span class="line">    <span class="comment">// 链表长度为奇数 此时 even==null</span></span><br><span class="line">    <span class="comment">// 链表长度为偶数 此时 even.next==null</span></span><br><span class="line">    <span class="comment">// 两种情况的任何一种情况都应该退出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对奇数链与偶数链进行拼接</span></span><br><span class="line">  odd.next = evenList.next;</span><br><span class="line">  <span class="keyword">return</span> oddList.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="725-Split-Linked-List-in-Parts"><a href="#725-Split-Linked-List-in-Parts" class="headerlink" title="[725] Split Linked List in Parts"></a>[725] Split Linked List in Parts</h4><blockquote>
<p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list “parts”.</p>
<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>
<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>
<p>Return a List of ListNode’s representing the linked list parts that are formed.</p>
<p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p>
</blockquote>
<p>理解题意 一共分为 k 部分 而不是长度是 k !!</p>
<p><em>时间复杂度*</em>:</p>
<p>在计算链表长度时, 遍历了一次. 后面将链表片段加入时, 又遍历了一遍.</p>
<p>所以时间复杂度为 $O(N+k)$, 在<code>k&gt;len</code>时, 需要继续向结果中加入片段.</p>
<p><strong>空间复杂度</strong>:</p>
<p>生成<code>answer</code>时res数组中包含的节点个数, <code>k&gt;len</code>, k个链表节点, 反之, len个链表节点. 所以空间复杂度为$O(max(N, k))$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> splitListToParts = <span class="function"><span class="keyword">function</span> (<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先计算root的长度</span></span><br><span class="line">  <span class="keyword">let</span> curr = root, len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    len++;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  curr = root;</span><br><span class="line">  <span class="comment">// 计算宽度</span></span><br><span class="line">  <span class="keyword">let</span> width = <span class="built_in">Math</span>.floor(len / k);</span><br><span class="line">  <span class="keyword">let</span> extra = len % k; <span class="comment">// 需要长度被加一的组数</span></span><br><span class="line">  <span class="keyword">let</span> res = []; <span class="comment">// 初始化长度为k的结果数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="comment">// 当k&lt;=len的时候,curr指向null时, for循环也就结束了</span></span><br><span class="line">    <span class="comment">// 因为组数已经达到了k组</span></span><br><span class="line">    <span class="comment">// 出现curr为null的情况时, 并且走到了这里</span></span><br><span class="line">    <span class="comment">// 说明k&gt;len</span></span><br><span class="line">    <span class="comment">// 此时只需要将null不断加入数组直至数组长度达到k</span></span><br><span class="line">    <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">      res.push(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多余没有入组的元素需要加入前面的每一个组</span></span><br><span class="line">    <span class="comment">// 因此前extra组, 每组的元素长度需要+1</span></span><br><span class="line">    <span class="keyword">let</span> l = i &lt; extra ? width + <span class="number">1</span> : width;</span><br><span class="line">    <span class="comment">// l-1是为了控制curr指向part的最后一个元素而不是下一个</span></span><br><span class="line">    <span class="comment">// 便于将该链表片段加入res</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; l - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// curr 到达part的最后一个元素      </span></span><br><span class="line">    <span class="keyword">let</span> cn = curr.next;</span><br><span class="line">    curr.next = <span class="literal">null</span>;</span><br><span class="line">    res.push(root);</span><br><span class="line">    curr = root = cn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="[445] Add Two Numbers II"></a>[445] Add Two Numbers II</h4><blockquote>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Follow up:</strong><br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
</blockquote>
<p>题目要求不能翻转链表, 于是遍历链表, 将链表中的数都存进栈中. 再通过将栈弹出, 进行相加操作.</p>
<p><strong>时间复杂度</strong>:</p>
<p>遍历两个链表, O(N). 两个栈均弹出进行相加操作, O(N). 因此时间为 $2O(N)=O(N)$</p>
<p><strong>空间复杂度</strong>:</p>
<p>使用两个栈存储数字, O(N), 相加之后得到新的结果列表的长度 O(max(m, n)) ps.是两个链表中较长的那一个Lmax, 结果链表长度可能由于进位问题会是Lmax+1, 因此空间复杂度为 $O(N)+O(max(m, n))$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能够翻转链表</span></span><br><span class="line"><span class="comment">// 使用两个栈存储数字</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将两个链表中的值分别存进两个栈中</span></span><br><span class="line">  <span class="keyword">let</span> stack1 = [], stack2 = [];</span><br><span class="line">  <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">    stack1.push(l1.val);</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">    stack2.push(l2.val);</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化变量</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>, carry = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>), rn;</span><br><span class="line">  <span class="keyword">let</span> add1, add2;</span><br><span class="line">  <span class="comment">// 当两个栈有至少一个不为空时, 都进行相加操作</span></span><br><span class="line">  <span class="comment">// 为空的那个栈的加数为 0</span></span><br><span class="line">  <span class="keyword">while</span> (stack1.length != <span class="number">0</span> || stack2.length != <span class="number">0</span>) &#123;</span><br><span class="line">    add1 = stack1.length == <span class="number">0</span> ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">    add2 = stack2.length == <span class="number">0</span> ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">    sum = add1 + add2 + carry;</span><br><span class="line">    <span class="comment">// 商是进位 大于10为1,小于10为0</span></span><br><span class="line">    carry = <span class="built_in">Math</span>.floor(sum / <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 余数是相加之后结果中的数字</span></span><br><span class="line">    num = sum % <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 将结果添加进结果列表中</span></span><br><span class="line">    rn = res.next;</span><br><span class="line">    res.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">    res.next.next = rn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当两个链表均为空时, 看是否还有进位</span></span><br><span class="line">  <span class="comment">// 有进位则添加进结果列表中</span></span><br><span class="line">  <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">    rn = res.next;</span><br><span class="line">    res.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    res.next.next = rn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Two Pointers</title>
    <url>/2020/07/30/Two-Pointers/</url>
    <content><![CDATA[<h4 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="[11] Container With Most Water"></a>[11] Container With Most Water</h4><blockquote>
<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>
</blockquote>
<h6 id="my-solution-Brute-Force"><a href="#my-solution-Brute-Force" class="headerlink" title="my solution : Brute Force"></a>my solution : Brute Force</h6><p>穷举所有面积的可能性,最后对面积进行排序,找到最大值.</p>
<p>中间一度尝试过将 <code>partArea</code> 组成数组先排序,也还是超时.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> partMaxSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> yVal = height[j] &lt; height[i] ? height[j] : height[i];</span><br><span class="line">      <span class="keyword">let</span> partArea = (j - i) * yVal;</span><br><span class="line">      partMaxSet.add(partArea);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> partMaxList = <span class="built_in">Array</span>.from(partMaxSet);</span><br><span class="line">  <span class="comment">// 数字降序排列</span></span><br><span class="line">  partMaxList.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a &#125;);</span><br><span class="line">  <span class="keyword">return</span> partMaxList[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// return Math.max.apply(null, partMaxList);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers"><a href="#Two-pointers" class="headerlink" title="Two pointers"></a>Two pointers</h6><p>采用双指针做法, 对于 S(i, j) 来说, 都是每次向里移动一步.</p>
<p>移动短板, 短板有可能变长, 面积有可能变大.</p>
<p>但是移动长板,  短板只会不变或者变小, 因为盛水的体积取决于短板, 所以面积只会不变或变小.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此算法需要证明</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> areaList = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">while</span> (j - i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">      <span class="comment">// 计算面积以短边为准</span></span><br><span class="line">      areaList.push((j - i) * height[i]);</span><br><span class="line">      <span class="comment">// 移动短边有可能获得更大面积</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      areaList.push((j - i) * height[j]);</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将可能的面积列表倒序排列,返回第一个</span></span><br><span class="line">  <span class="keyword">return</span> areaList.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Single pass.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant space is used.</li>
</ul>
<h4 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="[26] Remove Duplicates from Sorted Array"></a>[26] Remove Duplicates from Sorted Array</h4><blockquote>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
</blockquote>
<h6 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h6><p>借用 js 数组splice方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nums[j] == nums[i]) &#123;</span><br><span class="line">      nums.splice(j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers-1"><a href="#Two-pointers-1" class="headerlink" title="Two pointers"></a>Two pointers</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考双指针的方法, 优化了解法</span></span><br><span class="line"><span class="comment">// js的数组越界不会报错,只会得到 undefined 值</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="[27] Remove Element"></a>[27] Remove Element</h4><blockquote>
<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<h6 id="my-solution-1"><a href="#my-solution-1" class="headerlink" title="my solution"></a>my solution</h6><p>我自己的解法是利用了js数组操作的特性, 可以直接删除数组元素然后剩余元素位置前移的那种,比较方便,但是运行效果不咋地.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 使用 while 保证对于同一个i, 去除该位置所有与val相等的值</span></span><br><span class="line">    <span class="comment">// 不会遗漏由于删除数组元素而位置前移的新元素</span></span><br><span class="line">    <span class="keyword">while</span> (nums[i] == val) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers-2"><a href="#Two-pointers-2" class="headerlink" title="Two pointers"></a>Two pointers</h6><p>下面的解法是参考了示例解法, 双指针解法. 我觉得很精巧.</p>
<p>主要思路是, 将需要保留的元素都赋值给数组的前部分, 使用 i 标记赋值的位置.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution two pointers</span></span><br><span class="line"><span class="comment">// 只保留与val不同的元素</span></span><br><span class="line"><span class="comment">// 赋值操作比起splice的删除操作 肯定速度更快 至于额外的空间 需要看splice的实现有没有占用了</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      <span class="comment">// console.log("i=", i, " ", nums[i]);</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最差的情况应该是, 没有一个一样的, 但是遍历数组两遍而不是嵌套, 所以是 O(n).</p>
<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time complexity : O(n). Assume the array has a total of n<em>n</em> elements, both <em>i</em> and <em>j</em> traverse at most 2<em>n</em> steps.</li>
<li>Space complexity : O(1).</li>
</ul>
<h4 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="[15] 3Sum"></a>[15] 3Sum</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
</blockquote>
<p>数组排序后, 方便去除重复的元素 + 双指针移动不用嵌套且有方向可循.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 2 ：将数组排序后的双指针解法</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 将数组正序排列</span></span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 第一个数大于 0，肯定加起来和不为0了</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉重复元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> target = -nums[i];</span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">        res.push([nums[i], nums[left], nums[right]]);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 这里是否判断 left &lt; right 都没有那么重要, 因为最外面还会再判断一次</span></span><br><span class="line">        <span class="comment">// 但是加上判断可能会少做一次计算</span></span><br><span class="line">        <span class="comment">// 去掉重复元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">          right--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="[16] 3Sum Closest"></a>[16] 3Sum Closest</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
</blockquote>
<p>注意这里不是找相等, 而是保留最接近target的值, 实现方法类似.</p>
<p>与target比较, 由于一直在找最接近的, 比target小就left++, 比target大就right–, 总之就是不断靠近target.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> closest = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">let</span> diff = <span class="built_in">Math</span>.abs(closest - target);</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 由于数组是排好序的</span></span><br><span class="line">    <span class="comment">// 如果nums[i] * 3 &gt; target, 则 nums[i]+nums[i+1]+nums[i+2] 是接下来遍历的最小值</span></span><br><span class="line">    <span class="comment">// 后面差距只会越来越大</span></span><br><span class="line">    <span class="comment">// 将接下来最小值与当前最小值closest分别与target比较, 返回与target差距较小的那个值</span></span><br><span class="line">    <span class="comment">// 优化部分</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] * <span class="number">3</span> &gt; target) &#123;</span><br><span class="line">      <span class="keyword">let</span> cDiff = <span class="built_in">Math</span>.abs(closest - target);</span><br><span class="line">      <span class="keyword">let</span> tempMin = nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">let</span> tDiff = <span class="built_in">Math</span>.abs(tempMin - target);</span><br><span class="line">      <span class="keyword">return</span> cDiff &lt; tDiff ? closest : tempMin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针 遍历数组剩余元素</span></span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">      <span class="keyword">let</span> newDiff = <span class="built_in">Math</span>.abs(sum - target);</span><br><span class="line">      <span class="keyword">if</span> (newDiff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newDiff &lt; diff) &#123;</span><br><span class="line">        diff = newDiff;</span><br><span class="line">        closest = sum;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">        left++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log('closest:', closest);</span></span><br><span class="line">  <span class="keyword">return</span> closest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="[18] 4Sum"></a>[18] 4Sum</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em>in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
</blockquote>
<p>有了双指针, nSum都可解, 不过这个嵌套有点多,估计有更巧妙的解法.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> len = nums.length, res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; j &gt; i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">let</span> t = target - nums[i] - nums[j];</span><br><span class="line">      <span class="keyword">let</span> left = j + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> twoSum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (twoSum == t) &#123;</span><br><span class="line">          res.push([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">          <span class="comment">// 去重</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">            left++;</span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (twoSum &gt; t) &#123;</span><br><span class="line">          right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(res);</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="[283] Move Zeroes"></a>[283] Move Zeroes</h4><blockquote>
<p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Note</strong>:</p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
</blockquote>
<p>双指针解法, 一次成功.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution: two pointers</span></span><br><span class="line"><span class="comment">// 借鉴之前的做题经验, 这题算是完成的比较快</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> t = i; t &lt; len; t++) &#123;</span><br><span class="line">    nums[t] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(nums);</span></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="[66] Plus One"></a>[66] Plus One</h4><blockquote>
<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, increment one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
</blockquote>
<p>主要是运用数组特性.不是很难, 理解题意即可.</p>
<p>还挺多人不喜欢这道题的, 可能觉得太弱智了?…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = digits.length;</span><br><span class="line">  <span class="comment">// c 表示进位</span></span><br><span class="line">  <span class="keyword">let</span> i = len - <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有向前进位, 就 +1 结束</span></span><br><span class="line">    <span class="keyword">if</span> (digits[i] + c &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      digits[i]++;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 首位元素 +1 后有进位, 向数组头部插入 1 结束</span></span><br><span class="line">      digits[i] = <span class="number">0</span>;</span><br><span class="line">      digits.unshift(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是首位元素 +1 后有进位</span></span><br><span class="line">      <span class="comment">// 当前元素设为 0 , 继续看更高位元素</span></span><br><span class="line">      digits[i] = <span class="number">0</span>;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(digits);</span></span><br><span class="line">  <span class="keyword">return</span> digits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="[88] Merge Sorted Array"></a>[88] Merge Sorted Array</h4><blockquote>
<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em>and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is <strong>equal</strong> to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
</blockquote>
<p>我用的方法比较死板, 感觉没有什么难度. 就是分情况讨论. </p>
<p>不过用到了 js 里 Array 的特性.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 说明没有自己的元素</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums1[i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> len = nums1.length;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> j = m;</span><br><span class="line">        <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; k &lt; n) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums2[k] &gt;= nums1[i] &amp;&amp; nums2[k] &lt; nums1[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                nums1.splice(i + <span class="number">1</span>, <span class="number">0</span>, nums2[k]);</span><br><span class="line">                nums1.pop();</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums2[k] &gt;= nums1[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums1[j] = nums2[k];</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums2[k] &lt;= nums1[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums1.unshift(nums2[k]);</span><br><span class="line">                nums1.pop();</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="[80] Remove Duplicates from Sorted Array II"></a>[80] Remove Duplicates from Sorted Array II</h4><blockquote>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
</blockquote>
<p><strong>时间复杂度</strong>: 遍历整个数组 $O(N)$</p>
<p><strong>空间复杂度</strong>: 仅使用两个index: left和right标记数组元素位置, $O(1)$ </p>
<p>使用splice方法直接修改数组. (这个方法的实现原理需要了解一下 TODO)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组是排好序的</span></span><br><span class="line"><span class="comment">// 不能使用额外空间,直接修改数组</span></span><br><span class="line"><span class="comment">// 使所有元素出现次数最多不超过2次</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[right] == nums[left] &amp;&amp; right - left == <span class="number">1</span>) &#123;</span><br><span class="line">      right++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明至少是第三个相同的元素</span></span><br><span class="line">    <span class="comment">// 需要将该元素删除</span></span><br><span class="line">    <span class="keyword">if</span> (nums[right] == nums[left] &amp;&amp; right - left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      nums.splice(right, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 删除元素时会影响原数组的长度</span></span><br><span class="line">      <span class="comment">// 但是right仍然需要控制不能超过数组的边界</span></span><br><span class="line">      len = nums.length;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// right和left指向的元素不同</span></span><br><span class="line">    left = right;</span><br><span class="line">    right = right + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当right==len的时候,说明数组遍历结束</span></span><br><span class="line">  <span class="comment">// 返回当前删除重复元素后的数组长度</span></span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="[202] Happy Number"></a>[202] Happy Number</h4><blockquote>
<p>Write an algorithm to determine if a number <code>n</code> is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1. Those numbers for which this process <strong>ends in 1</strong> are happy numbers.</p>
<p>Return True if <code>n</code> is a happy number, and False if not.</p>
</blockquote>
<p>复杂度分析有点困难, 以及为什么只有循环或者归1两种结果, 而不是无穷大.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1: 快慢指针法</span></span><br><span class="line"><span class="comment">// 快慢指针找循环</span></span><br><span class="line"><span class="comment">// 在平方累加的过程中, 要不最后等于1, 要不最后陷入循环, 至于为什么不是无穷大</span></span><br><span class="line"><span class="comment">// 需要再琢磨一下</span></span><br><span class="line"><span class="keyword">var</span> isHappy1 = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 慢指针一次计算一步, 快指针一次计算两步</span></span><br><span class="line">  <span class="comment">// 如果两个指针的值一样, 说明进入循环</span></span><br><span class="line">  <span class="comment">// 否则, 快指针一定比慢指针率先到达1</span></span><br><span class="line">  <span class="comment">// 初始化快慢指针</span></span><br><span class="line">  <span class="keyword">let</span> slow = getPow(n), fast = getPow(getPow(n));</span><br><span class="line">  <span class="keyword">while</span> (fast != <span class="number">1</span> &amp;&amp; fast != slow) &#123;</span><br><span class="line">    slow = getPow(slow);</span><br><span class="line">    fast = getPow(fast);</span><br><span class="line">    fast = getPow(fast);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fast == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算某个数的各个数位上的平方</span></span><br><span class="line"><span class="keyword">var</span> getPow = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = n % <span class="number">10</span>;</span><br><span class="line">    sum += num * num;</span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n / <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution 2: 使用hashmap来判断值有无重复 聪儿判断有无循环</span></span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> res = getPow(n);</span><br><span class="line">  <span class="comment">// map中没有该计算结果</span></span><br><span class="line">  <span class="comment">// 则添加进map中</span></span><br><span class="line">  <span class="comment">// 不是undefined 说明该计算结果之前已经被塞进map中</span></span><br><span class="line">  <span class="comment">// 得到循环</span></span><br><span class="line">  <span class="keyword">while</span> (map[res] == <span class="literal">undefined</span> &amp;&amp; res != <span class="number">1</span>) &#123;</span><br><span class="line">    map[res] = <span class="string">'1'</span>;</span><br><span class="line">    res = getPow(res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Learning</title>
    <url>/2020/07/29/Vue-Learning/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
