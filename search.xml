<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Basic Knowledge</title>
    <url>/2020/09/30/Basic-Knowledge/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>数据结构是工具, 算法是通过合适的工具解决特定问题的方法.</p>
<h2 id="数据结构的存储方式"><a href="#数据结构的存储方式" class="headerlink" title="数据结构的存储方式"></a>数据结构的存储方式</h2><p>数据结构的存储方式只有两种: 数组(顺序存储)与链表(链式存储)</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>定义</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>队列/栈</td>
<td></td>
<td>需要扩容</td>
<td>更多空间存储指针</td>
</tr>
<tr>
<td>图</td>
<td>多对多</td>
<td>邻接矩阵</td>
<td>邻接表</td>
</tr>
<tr>
<td>散列表</td>
<td>通过散列函数将键映射到一个大数组里  <br />需要解决散列冲突</td>
<td>线性探查法</td>
<td>拉链法</td>
</tr>
<tr>
<td>树</td>
<td>一对多</td>
<td>堆, 完全二叉树,不需要节点指针</td>
<td>不一定是完全二叉树, 衍生出各种巧妙的设计<br /> eg. 二叉搜索树/AVL树/红黑树/区间树/B树等, 应对不同的问题.</td>
</tr>
</tbody></table>
<h2 id="数据结构的基本操作"><a href="#数据结构的基本操作" class="headerlink" title="数据结构的基本操作"></a>数据结构的基本操作</h2><p>遍历(找) + 访问(改) (具体点: 增删改查)</p>
<p>两种形式: 线性(for/while循环) &amp; 非线性(递归)</p>
<h4 id="二叉搜索树操作"><a href="#二叉搜索树操作" class="headerlink" title="二叉搜索树操作"></a>二叉搜索树操作</h4><p>二叉树算法设计: 明确一个节点要做的事, 剩下的交给框架.</p>
<p>判断 BST 的合法性/增/删/查</p>
<h5 id="判断BST合法性"><a href="#判断BST合法性" class="headerlink" title="判断BST合法性"></a>判断BST合法性</h5><h5 id="在BST中查找一个数是否存在"><a href="#在BST中查找一个数是否存在" class="headerlink" title="在BST中查找一个数是否存在"></a>在BST中查找一个数是否存在</h5><h5 id="在BST中插入一个数"><a href="#在BST中插入一个数" class="headerlink" title="在BST中插入一个数"></a>在BST中插入一个数</h5><h5 id="在BST中删除一个数"><a href="#在BST中删除一个数" class="headerlink" title="在BST中删除一个数"></a>在BST中删除一个数</h5><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1>]]></content>
  </entry>
  <entry>
    <title>Array</title>
    <url>/2020/09/21/Array/</url>
    <content><![CDATA[<h4 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="[56] Merge Intervals"></a>[56] Merge Intervals</h4><blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
</blockquote>
<p><strong>时间复杂度</strong>:</p>
<p>排序时间($O(NlogN)$) + 遍历数组($O(N)$)</p>
<p><strong>空间复杂度</strong>: 直接借用js数组特性splice对原数组进行修改, 没有使用额外的空间. 因此为$O(1)$.</p>
<p><strong>数组的sort方法</strong>:</p>
<p>当数组长度&lt;=10的时候，采用插入排序($O(N^2)$)，&gt;10的时候，采用快排($O(NlogN)$)。</p>
<p>对于长度&gt;1000的数组，采用的是快排与插入排序混合的方式进行排序.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并有交集的若干个区间</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = intervals.length</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">  <span class="comment">// 首先对区间进行排序 根据数组的第一列进行排序</span></span><br><span class="line">  <span class="comment">// 如果不排序 后面在合并区间时也会两两交换 等于排序</span></span><br><span class="line">  intervals.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 将数组中的区间进行两两合并</span></span><br><span class="line">  <span class="comment">// 如果某两个邻近区间a1 a2没有合并完成</span></span><br><span class="line">  <span class="comment">// 那么由于排序的原因 a1更不会和a3合并</span></span><br><span class="line">  <span class="keyword">let</span> preIndex = <span class="number">0</span>, currIndex = <span class="number">1</span>, mergeRes;</span><br><span class="line">  <span class="keyword">while</span> (currIndex &lt; len) &#123;</span><br><span class="line">    <span class="comment">// 判断两个区间是否能合并</span></span><br><span class="line">    <span class="comment">// 不能返回false 能则返回合并后的结果</span></span><br><span class="line">    mergeRes = isMerge(intervals[preIndex], intervals[currIndex]);</span><br><span class="line">    <span class="comment">// 不能合并</span></span><br><span class="line">    <span class="keyword">if</span> (mergeRes == <span class="literal">false</span>) &#123;</span><br><span class="line">      preIndex = currIndex;</span><br><span class="line">      currIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 进行合并</span></span><br><span class="line">      intervals[preIndex] = mergeRes;</span><br><span class="line">      intervals.splice(currIndex, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// currIndex 此时不变</span></span><br><span class="line">      len = intervals.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intervals;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isMerge = <span class="function">(<span class="params">inter1, inter2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 两个区间能合并的前提条件是 有交集</span></span><br><span class="line">  <span class="keyword">let</span> num0 = inter1[<span class="number">0</span>], num1 = inter1[<span class="number">1</span>], num2 = inter2[<span class="number">0</span>], num3 = inter2[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &gt;= num2 &amp;&amp; num1 &lt;= num3) &#123; <span class="comment">// 不是包含关系的交集</span></span><br><span class="line">    <span class="keyword">return</span> [num0, num3];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 前一个区间包含后一个区间</span></span><br><span class="line">    <span class="keyword">return</span> inter1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="[57] Insert Interval"></a>[57] Insert Interval</h4><blockquote>
<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
</blockquote>
<p><strong>时间复杂度</strong>:</p>
<p>遍历了一遍数组, 后面的判断部分时间是常数级, 因此  $O(N)$.</p>
<p>不得不说, 思路很好耶, 很巧妙利用了题目所给的条件. 比如有序, 比如区间合并, 这里的区间合并显得尤其简单.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// intervals 本身是已经排好序的</span></span><br><span class="line"><span class="keyword">var</span> insert = <span class="function"><span class="keyword">function</span> (<span class="params">intervals, newInterval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = [], right = [];</span><br><span class="line">  <span class="comment">// 逐步比较 将完全不能与当前区间合并的区间分成左右两半部分</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item[<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">      left.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (item[<span class="number">0</span>] &gt; newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">      right.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 说明剩余有可以合并的区间</span></span><br><span class="line">  <span class="comment">// 剩余的每个区间都是可以和 newInterval 合并的</span></span><br><span class="line">  <span class="comment">// 剩余的所有区间和 newInterval 最后会合并成一个区间</span></span><br><span class="line">  <span class="keyword">let</span> ll = left.length, rl = right.length, len = intervals.length;</span><br><span class="line">  <span class="keyword">let</span> s = newInterval[<span class="number">0</span>], b = newInterval[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (ll + rl != len) &#123;</span><br><span class="line">    <span class="comment">// 可以合并的区间的序号范围是 [ll, len-rl-1]</span></span><br><span class="line">    <span class="comment">// 由于中间的每一个元素均和 newInterval 有交集</span></span><br><span class="line">    <span class="comment">// 则最后会合并成一个区间 找到最后这个合并区间的最大值与最小值(即其范围)</span></span><br><span class="line">    s = <span class="built_in">Math</span>.min(intervals[ll][<span class="number">0</span>], s);</span><br><span class="line">    b = <span class="built_in">Math</span>.max(intervals[len - rl - <span class="number">1</span>][<span class="number">1</span>], b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将合并部分的区间置于左右中间</span></span><br><span class="line">  <span class="comment">// 拼接形成结果</span></span><br><span class="line">  <span class="keyword">let</span> res = left.concat([[s, b]]).concat(right);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="[169] Majority Element"></a>[169] Majority Element</h4><blockquote>
<p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 确定次数</span></span><br><span class="line">  <span class="keyword">let</span> times = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> map) &#123;</span><br><span class="line">      map[i] += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个值的出现次数更新之后, 都会判断一下是否是主要元素</span></span><br><span class="line">    <span class="comment">// 由于题目说主要元素一定存在, 因此一定会存在元素的出现次数超过规定值</span></span><br><span class="line">    <span class="keyword">if</span> (map[i] &gt; times) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="[54] Spiral Matrix"></a>[54] Spiral Matrix</h4><blockquote>
<p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p>
</blockquote>
<p><strong>时间复杂度</strong>:</p>
<p>遍历矩阵 $O(M*N)$.</p>
<p><strong>空间复杂度</strong>:</p>
<p>除了返回的结果数组, 使用的额外空间为常数级, $O(1)$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旋转矩阵</span></span><br><span class="line"><span class="comment">// 按层遍历 输出结果</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = matrix.length; <span class="comment">// 矩阵的行数</span></span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> n = matrix[<span class="number">0</span>].length; <span class="comment">// 矩阵的列数</span></span><br><span class="line">  <span class="keyword">let</span> res = []; <span class="comment">// 存储结果序列</span></span><br><span class="line">  <span class="keyword">let</span> top = <span class="number">0</span>, bottom = m - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 按照顺时针方向</span></span><br><span class="line">  <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// 添加top从左到右的一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      res.push(matrix[top][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top == bottom) <span class="keyword">break</span>; <span class="comment">// 判断结束情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加right从上到下的一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = top + <span class="number">1</span>; j &lt;= bottom; j++) &#123;</span><br><span class="line">      res.push(matrix[j][right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">break</span>; <span class="comment">// 判断结束情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加bottom从右到左的一行 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">      res.push(matrix[bottom][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加left从下到上的一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = bottom - <span class="number">1</span>; j &gt;= top + <span class="number">1</span>; j--) &#123;</span><br><span class="line">      res.push(matrix[j][left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改边界值 进入下一层</span></span><br><span class="line">    top++; left++; bottom--; right--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直接在循环中判断两个边界是否相等 就不用再另外判断奇数偶数</span></span><br><span class="line">  <span class="comment">// 然后分情况讨论了</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // m n 均是偶数 则退出循环后可以直接返回res</span></span><br><span class="line"><span class="comment">  // m n 至少有一个为奇数</span></span><br><span class="line"><span class="comment">  退出循环时则会出现 top==bottom 或者 left==right</span></span><br><span class="line"><span class="comment">  if (m % 2 != 0 || n % 2 != 0) &#123;</span></span><br><span class="line"><span class="comment">    if (top == bottom) &#123;</span></span><br><span class="line"><span class="comment">      for (let i = left; i &lt;= right; i++) &#123;</span></span><br><span class="line"><span class="comment">        res.push(matrix[top][i])</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">      for (let i = top; i &lt;= bottom; i++) &#123;</span></span><br><span class="line"><span class="comment">        res.push(matrix[i][left])</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="[59] Spiral Matrix II"></a>[59] Spiral Matrix II</h4><blockquote>
<p>Given a positive integer <em>n</em>, generate a square matrix filled with elements from 1 to <em>n</em>2 in spiral order.</p>
</blockquote>
<p>借鉴上一题的思路.</p>
<p><strong>时间复杂度</strong>: O(N*N), 遍历了整个二维数组.</p>
<p><strong>空间复杂度</strong>: O(1), 除了返回的二维结果数组, 其余为常量级.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> top = <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 注意不要使用 let arr = new Array(n).fill(new Array(n))</span></span><br><span class="line">  <span class="comment">// 这样fill填充的是同一个数组的引用, 不是多个,(坑)</span></span><br><span class="line">  <span class="comment">// 建议使用for循环初始化结果数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 按照顺时针的方向逐行逐列填充递增值</span></span><br><span class="line">  <span class="comment">// 填充完外圈再填充内圈</span></span><br><span class="line">  <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// n为奇数 最后 top==bottom left==right</span></span><br><span class="line">    <span class="comment">// 只会走下面这一个for循环 其余for循环均不满足条件</span></span><br><span class="line">    <span class="comment">// n 为偶数 最后 top+1==bottom left+1==right</span></span><br><span class="line">    <span class="comment">// 最后一个for循环不满足条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      arr[top][i] = ++val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">      arr[i][right] = ++val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">      arr[bottom][i] = ++val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = bottom - <span class="number">1</span>; i &gt;= top + <span class="number">1</span>; i--) &#123;</span><br><span class="line">      arr[i][left] = ++val;</span><br><span class="line">    &#125;</span><br><span class="line">    top++; bottom--; left++; right--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="[48] Rotate Image"></a>[48] Rotate Image</h4><blockquote>
<p>You are given an <em>n</em> x <em>n</em> 2D <code>matrix</code> representing an image, rotate the image by 90 degrees (clockwise).</p>
<p>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>
</blockquote>
<p><strong>时间复杂度</strong>:</p>
<p>双重循环 $O(N)$.</p>
<p><strong>空间复杂度</strong>:</p>
<p>O(1). 原地修改数组内容.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路就是: 旋转完外圈, 再旋转内圈</span></span><br><span class="line"><span class="comment">// 直至内圈没有可以旋转的圈</span></span><br><span class="line"><span class="comment">// 没有啥可说的, 就是不断画图, 标注坐标</span></span><br><span class="line"><span class="comment">// 找到需要交换值的四个位置坐标间的联系与规律</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = matrix.length;</span><br><span class="line">  <span class="comment">// 计算层数</span></span><br><span class="line">  <span class="keyword">let</span> levels = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> end, a, b, c, d;</span><br><span class="line">  <span class="comment">// 遍历层数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> t = <span class="number">0</span>; t &lt; levels; t++) &#123;</span><br><span class="line">    <span class="comment">// 每一层右上角节点的纵坐标值</span></span><br><span class="line">    end = n - <span class="number">1</span> - t;</span><br><span class="line">    <span class="comment">// 每一层的矩阵大小为 m*m</span></span><br><span class="line">    <span class="comment">// 则只有前m-1个元素需要移动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = t; i &lt;= end - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 需要进行交换的四个点的值</span></span><br><span class="line">      a = matrix[t][i];</span><br><span class="line">      b = matrix[i][end];</span><br><span class="line">      c = matrix[end][end - (i - t)];</span><br><span class="line">      d = matrix[end - (i - t)][t];</span><br><span class="line">      <span class="comment">// 进行交换</span></span><br><span class="line">      matrix[t][i] = d;</span><br><span class="line">      matrix[i][end] = a;</span><br><span class="line">      matrix[end][end - (i - t)] = b;</span><br><span class="line">      matrix[end - (i - t)][t] = c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Backtracking</title>
    <url>/2020/08/18/Backtracking/</url>
    <content><![CDATA[<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><h5 id="解题过程-决策树的遍历过程"><a href="#解题过程-决策树的遍历过程" class="headerlink" title="解题过程=决策树的遍历过程:"></a>解题过程=决策树的遍历过程:</h5><ol>
<li>路径: 已经做出的选择</li>
<li>选择列表: 当前可以做的选择</li>
<li>结束条件: 到达决策树底层, 无法再做选择的条件(可选列表为空等)</li>
</ol>
<h5 id="回溯算法代码框架"><a href="#回溯算法代码框架" class="headerlink" title="回溯算法代码框架:"></a>回溯算法代码框架:</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">var</span> backtrack = <span class="function">(<span class="params">路径, 选择列表</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> 满足结束条件&#123;</span><br><span class="line">    result.push(路径);</span><br><span class="line">  	<span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表&#123;</span><br><span class="line">  	<span class="comment">// 做选择</span></span><br><span class="line">  	将该选择从选择列表中移除</span><br><span class="line">    路径.push(选择)</span><br><span class="line">    backtrack(路径, 选择列表);</span><br><span class="line">  	<span class="comment">// 撤销选择</span></span><br><span class="line">    路径.pop()</span><br><span class="line">    将该选择再加入选择列表</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析:"></a>时间复杂度分析:</h5><p>递归相关的算法, 时间复杂度计算为: [递归次数]*[递归本身的时间复杂度].</p>
<h3 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h3><h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><h5 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="[51] N-Queens"></a>[51] N-Queens</h5><p>套用回溯框架即可, 每确定一个皇后位置, 将其加入已经选择的路径中, 接着进行选择.</p>
<p>学了框架之后, 思路都清楚了很多.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 皇后彼此不能相互攻击也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上</span></span><br><span class="line"><span class="keyword">var</span> solveNQueens = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化棋盘</span></span><br><span class="line">  <span class="keyword">let</span> board = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    board.push(<span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> path = [], res = []; <span class="comment">// 存储皇后的纵坐标</span></span><br><span class="line">  backtrack(board, path, res, n, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> backtrack = <span class="function">(<span class="params">board, path, res, n, depth</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// end condition</span></span><br><span class="line">  <span class="keyword">if</span> (path.length == n) &#123;</span><br><span class="line">    <span class="keyword">let</span> solution = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> col <span class="keyword">of</span> path) &#123;</span><br><span class="line">      <span class="keyword">let</span> ele = board.slice();</span><br><span class="line">      ele[col] = <span class="string">'Q'</span>;</span><br><span class="line">      solution.push(ele.join(<span class="string">''</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(solution);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// make a choice</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span> || isValid(depth, i, path)) &#123;</span><br><span class="line">      <span class="comment">// 进行选择</span></span><br><span class="line">      path.push(i);</span><br><span class="line">      backtrack(board, path, res, n, depth + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 撤销选择</span></span><br><span class="line">      path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给两个皇后的坐标 判断这两个皇后是否会互相攻击</span></span><br><span class="line"><span class="comment">// 同一横线 同一竖线 同一斜线</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function">(<span class="params">m, n, path</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 横坐标相等 纵坐标相等 横坐标坐标差值相等</span></span><br><span class="line">    <span class="keyword">if</span> (m == i || n == path[i] || <span class="built_in">Math</span>.abs(m - i) == <span class="built_in">Math</span>.abs(path[i] - n)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><h5 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="[78] Subsets"></a>[78] Subsets</h5><blockquote>
<p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
</blockquote>
<p>观察全排列/组合/子集问题，它们比较相似，且可以使用一些通用策略解决。</p>
<p>首先，它们的解空间非常大：</p>
<ul>
<li>全排列：N!。</li>
</ul>
<ul>
<li>组合：N!。</li>
</ul>
<ul>
<li>子集：2^N, 每个元素都可能存在或不存在。</li>
</ul>
<p>在它们的指数级解法中，要确保生成的结果 <strong>完整</strong> 且 <strong>无冗余</strong>，有三种常用的方法：</p>
<ol>
<li>递归</li>
<li>回溯</li>
<li>基于二进制位掩码和对应位掩码之间的映射字典生成排列/组合/子集</li>
</ol>
<p>相比前两种方法，第三种方法将每种情况都简化为二进制数，易于实现和验证。</p>
<p>此外，第三种方法具有<strong>最优的时间复杂度</strong>，可以生成按照字典顺序的输出结果。</p>
<h6 id="solution-1-字典排序（二进制排序）-子集"><a href="#solution-1-字典排序（二进制排序）-子集" class="headerlink" title="solution 1 : 字典排序（二进制排序） 子集"></a>solution 1 : 字典排序（二进制排序） 子集</h6><p>这种解法很巧妙, 由于是全排列问题, 子集的数量与数组长度有关.</p>
<p>数组中的元素, 每个只有在或者不在子集中这两种选择. 对于每一种可能, 都能用二进制来标记.</p>
<p>因此该方法的思路如下:</p>
<p>假设数组为[1, 2, 4], 则子集数量为 2^len= 2^3 = 8</p>
<p>则从 0 - 7 的二进制对应分别为 000-111</p>
<p>每一种可能都对应一种子集详情, 比如 101 对应 [1,4],  001 对应 [4].</p>
<img src="/2020/08/18/Backtracking/bitmask4.png" class="" title="bitmask4">

<p>需要注意的点是, 在将十进制转换为二进制时, 需要将二进制的位数扩充至与nums的长度相等.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> subSets = [];</span><br><span class="line">  <span class="comment">// 根据数组长度计算器其子集数量</span></span><br><span class="line">  <span class="keyword">let</span> subSetsNum = <span class="built_in">Math</span>.pow(<span class="number">2</span>, len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subSetsNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 十进制转换为二进制</span></span><br><span class="line">    <span class="comment">// 每一个二进制都唯一对应一个子集</span></span><br><span class="line">    <span class="keyword">let</span> setNoStr = i.toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (setNoStr.length &lt; len) &#123;</span><br><span class="line">      <span class="comment">//如果长度不足 len，前面添加 0</span></span><br><span class="line">      setNoStr = <span class="string">'0'</span> + setNoStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> setNoList = setNoStr.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> subSet = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (setNoList[j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        subSet.push(nums[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    subSets.push(subSet);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subSets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N×2^N)，生成所有的子集，并复制到输出列表中。</li>
<li>空间复杂度：O(N×2^N)，存储所有子集，共 n 个元素，每个元素都有可能存在或者不存在。</li>
</ul>
<h6 id="solution-2-数学归纳法"><a href="#solution-2-数学归纳法" class="headerlink" title="solution 2 : 数学归纳法"></a>solution 2 : 数学归纳法</h6><p>这个解法挺巧妙的, 每次都把新元素加进已有的所有子集, 生成新的子集, 因为每个元素只有在和不在两种情况.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> subSets = [[]];</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> subSets</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = subSets.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> ele = subSets[j].concat([nums[i]]);</span><br><span class="line">      subSets.push(ele);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subSets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:  总共添加2^N个子集, 每个子集是数组形式, 子集通过深拷贝塞进结果数组中, 拷贝耗时O(N). 因此, 总的时间复杂度是 O(N*2^N).</p>
<p>空间复杂度: 存储每个子集需要 O(N)的递归堆栈空间(不算结果集), 算上结果的话, 一共2^N个子集, 因此所需空间为 O(N*2^N).</p>
<h6 id="Solution-3-回溯解法"><a href="#Solution-3-回溯解法" class="headerlink" title="Solution 3 :  回溯解法"></a>Solution 3 :  回溯解法</h6><p>使用回溯模板. 控制start.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [], path = [];</span><br><span class="line">  helper(nums, res, path);</span><br><span class="line">  res.push([]); <span class="comment">// 添加空集</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> helper = <span class="function">(<span class="params">choice, res, path</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// end condition</span></span><br><span class="line">  <span class="comment">// 没有节点可以选择时 返回</span></span><br><span class="line">  <span class="keyword">if</span> (choice.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; choice.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    path.push(choice[i]);</span><br><span class="line">    res.push(path.slice()); <span class="comment">// 每一个节点都是子集</span></span><br><span class="line">    <span class="comment">// 对于一个没有重复元素的集合来说</span></span><br><span class="line">    <span class="comment">// 在添加元素时 直接向后作为选择列表即可</span></span><br><span class="line">    <span class="comment">// 因为前面的元素与当前元素的子集已经被先前元素添加过了</span></span><br><span class="line">    <span class="comment">// 排除已选择的数字</span></span><br><span class="line">    helper(choice.slice(i + <span class="number">1</span>), res, path);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="[90] Subsets II"></a>[90] Subsets II</h5><blockquote>
<p>Given a collection of integers that might contain duplicates, <strong><em>nums\</em></strong>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
</blockquote>
<p>思路与子集时类似, 只是需要剪枝操作, <strong>将同一层其余相同的元素除去</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsetsWithDup = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(); <span class="comment">// 排序操作 使得相同元素相邻</span></span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    recur(i, <span class="number">0</span>, len, [], res, nums);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recur = <span class="function">(<span class="params">depth, first, len, curr, res, nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (curr.length == depth) &#123;</span><br><span class="line">    res.push(curr.slice()); <span class="comment">// 将当前子集的深拷贝加入结果数组</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = first; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; first &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 一开始写成了 i&gt;0 结果总是不对 后来知道每次加元素是从 first 开始 不是 0 开始</span></span><br><span class="line">      <span class="comment">// 每次当作为起始点往数组加入元素时,不能加入与上一个元素相同的元素</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curr.push(nums[i]);</span><br><span class="line">    recur(depth, i + <span class="number">1</span>, len, curr, res, nums);</span><br><span class="line">    curr.pop(); <span class="comment">// 回溯 回到初始状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="括号问题"><a href="#括号问题" class="headerlink" title="括号问题"></a>括号问题</h4><p>两个性质:</p>
<ol>
<li>合法的括号组合中, 左括号数目=右括号数目.</li>
<li>一个合法的括号组合字符串 s, 对于任意 0&lt;=i&lt;len(s), 子串 s[0, i] 中, 左括号数目&gt;=右括号数目.</li>
</ol>
<h5 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="[22] Generate Parentheses"></a>[22] Generate Parentheses</h5><blockquote>
<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
</blockquote>
<p>对于该题题意的理解, 可以是, 现在有 <code>2n</code> 个位置, 每个位置可以放置<code>&#39;(&#39;</code>(数目为n)/<code>&#39;)&#39;</code>(数目为n), 请问一共有多少种合法的放置方式?</p>
<p>则解题思路是: <em>先得到 2^(2n) 种组合方式, 再去除不合法的部分即可.</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2020/10/21 学习回溯模板之后 很简洁</span></span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> path = [], res = [];</span><br><span class="line">  helper(path, res, n, n, n);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> helper = <span class="function">(<span class="params">path, res, n, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 左括号剩的比右括号多 不合法</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 使用次数小于0 不合法</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 左右括号都恰好用完, 得到一个合法的括号</span></span><br><span class="line">  <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">    res.push(path.join(<span class="string">''</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尝试放一个左括号</span></span><br><span class="line">  path.push(<span class="string">'('</span>); <span class="comment">// 选择</span></span><br><span class="line">  helper(path, res, n, left - <span class="number">1</span>, right);</span><br><span class="line">  path.pop(); <span class="comment">// 撤销选择</span></span><br><span class="line">  <span class="comment">// 尝试放一个右括号</span></span><br><span class="line">  path.push(<span class="string">')'</span>); <span class="comment">// 选择</span></span><br><span class="line">  helper(path, res, n, left, right - <span class="number">1</span>);</span><br><span class="line">  path.pop(); <span class="comment">// 撤销选择</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h4><h5 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="[46] Permutations"></a>[46] Permutations</h5><blockquote>
<p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>
</blockquote>
<p>时间复杂度: O(N*N!)</p>
<p>全排列一共有 N! 种可能, 实现每一种可能需要遍历整个数组即O(N)时间, 所以可得.</p>
<p>使用回溯模板. 删除已经选择的数字.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [], path = [];</span><br><span class="line">  helper(nums, res, path);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> helper = <span class="function">(<span class="params">nums, res, path</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 选择列表为空</span></span><br><span class="line">  <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">    res.push(path.slice());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    path.push(nums[i]);</span><br><span class="line">    <span class="keyword">let</span> nums_cp = nums.slice();</span><br><span class="line">    <span class="comment">// 从选择列表中删除这个选择</span></span><br><span class="line">    <span class="comment">// 排除已选择的数字</span></span><br><span class="line">    nums.splice(i, <span class="number">1</span>); </span><br><span class="line">    helper(nums, res, path);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    path.pop(); </span><br><span class="line">    nums = nums_cp; <span class="comment">// 将移除的选择重新加入选择列表</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><h5 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="[77] Combinations"></a>[77] Combinations</h5><blockquote>
<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p>You may return the answer in <strong>any order</strong>.</p>
</blockquote>
<p>使用回溯模板, 决策树的深度为 k. 将深度为k的节点均加入节点列表.</p>
<p>其实就是自己问题的一部分, 使用start排除已经做出的选择.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> combine = <span class="function">(<span class="params">n, k</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> path = [], res = [];</span><br><span class="line">  <span class="keyword">let</span> choice = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    choice.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  helper(choice, <span class="number">0</span>, path, res, k);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> helper = <span class="function">(<span class="params">choice, start, path, res, k</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.length == k) &#123;</span><br><span class="line">    res.push(path.slice());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; choice.length; i++) &#123;</span><br><span class="line">    path.push(choice[i]);</span><br><span class="line">    helper(choice, i + <span class="number">1</span>, path, res, k);</span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><h5 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="[79] Word Search"></a>[79] Word Search</h5><blockquote>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
</blockquote>
<p>回溯算法本质就是暴力穷举.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span> (<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = board.length;</span><br><span class="line">  <span class="keyword">let</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = findNeighbor(board, word, <span class="number">0</span>, i, j, &#123;&#125;);</span><br><span class="line">        <span class="keyword">if</span> (res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findNeighbor = <span class="function">(<span class="params">board, word, w, row, col, visited</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 不能在这里进行判断 因为尽管w这里表示最后一个字母</span></span><br><span class="line">  <span class="comment">// 但是却并不一定能在board里找到 需要再经过判断</span></span><br><span class="line">  <span class="comment">// if (w + 1 == word.length) return true;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择不合法则回到上一层</span></span><br><span class="line">  <span class="keyword">let</span> key = row + <span class="string">'+'</span> + col;</span><br><span class="line">  <span class="keyword">if</span> (row &gt;= board.length || row &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].length || col &lt; <span class="number">0</span></span><br><span class="line">    || visited[key] || board[row][col] != word[w]</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择列表</span></span><br><span class="line">  <span class="comment">// 对一个可能的选择都进行尝试</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 做选择</span></span><br><span class="line">  visited[key] = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 递归结束条件</span></span><br><span class="line">  <span class="comment">// 一旦word的最后一个字母也找到 则说明成功找到word</span></span><br><span class="line">  <span class="keyword">if</span> (w + <span class="number">1</span> == word.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 一旦找到目标字符串(递归返回值为true) 就直接返回 不用再进行下面的递归了 减少递归次数</span></span><br><span class="line">  <span class="keyword">let</span> r1 = findNeighbor(board, word, w + <span class="number">1</span>, row - <span class="number">1</span>, col, visited);</span><br><span class="line">  <span class="keyword">if</span> (r1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> r2 = findNeighbor(board, word, w + <span class="number">1</span>, row + <span class="number">1</span>, col, visited);</span><br><span class="line">  <span class="keyword">if</span> (r2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> r3 = findNeighbor(board, word, w + <span class="number">1</span>, row, col - <span class="number">1</span>, visited);</span><br><span class="line">  <span class="keyword">if</span> (r3) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> r4 = findNeighbor(board, word, w + <span class="number">1</span>, row, col + <span class="number">1</span>, visited);</span><br><span class="line">  <span class="keyword">if</span> (r4) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找了一圈没有找到 说明从该节点开始不是正确的选择</span></span><br><span class="line">  <span class="comment">// 则在该节点应该 撤销选择 回到上一层 在上一层转换搜索方向</span></span><br><span class="line">  visited[key] = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="[93] Restore IP Addresses"></a>[93] Restore IP Addresses</h5><blockquote>
<p>Given a string <code>s</code> containing only digits. Return all possible valid IP addresses that can be obtained from <code>s</code>. You can return them in <strong>any</strong> order.</p>
<p>A <strong>valid IP address</strong> consists of exactly four integers, each integer is between <code>0</code> and <code>255</code>, separated by single points and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are <strong>valid</strong> IP addresses and “0.011.255.245”, “192.168.1.312” and “<a href="mailto:192.168@1.1">192.168@1.1</a>“ are <strong>invalid</strong> IP addresses. </p>
</blockquote>
<p>就是大概有想法但是却实现不出来, 说明思路还不是很清楚, 需要画树状图帮助自己理解.</p>
<p>多画树状图, 理解回溯过程. 被这道题折磨好久.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 合法的url的条件:</span></span><br><span class="line"><span class="comment"> * 将字符串分为四个部分, 每个部分的数字[0,255], 不超过3位</span></span><br><span class="line"><span class="comment"> * 中间的数字不能以0开头</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="comment">// 字符串长度不够则直接返回空数组</span></span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">12</span> || len &lt; <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> ip = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  dfs(res, ip, start, s);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>res 存储合法ip</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> </span>ip 存储ip的每一段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>start 剩余需要继续递归的子串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>s </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dfs = <span class="function">(<span class="params">res, ip, start, s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在开始切割子串之前, 判断ip是否符合题意</span></span><br><span class="line">  <span class="comment">// s 已经遍历完毕且ip是四段的话, 该ip可以进结果数组了</span></span><br><span class="line">  <span class="keyword">if</span> (ip.length == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.length) &#123;</span><br><span class="line">      res.push(ip.join(<span class="string">'.'</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未遍历完s ip已经4段 该ip不合题意</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; s.length) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// s 已经遍历完了,但是ip不到四段,返回</span></span><br><span class="line">  <span class="keyword">if</span> (ip.length &lt; <span class="number">4</span> &amp;&amp; start == s.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从每个起始位置开始切割都是三个长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> l = <span class="number">1</span>; l &lt;= <span class="number">3</span>; l++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start + l &gt; s.length) <span class="keyword">return</span>; <span class="comment">// 索引超过边界</span></span><br><span class="line">    <span class="keyword">if</span> ((l == <span class="number">2</span> || l == <span class="number">3</span>) &amp;&amp; s[start] == <span class="string">'0'</span>) <span class="keyword">return</span>; <span class="comment">// 2/3子串以0开头</span></span><br><span class="line">    <span class="keyword">let</span> part = s.substring(start, start + l); <span class="comment">// 切割子串</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>(part) &gt; <span class="number">255</span>) <span class="keyword">return</span>; <span class="comment">// 子串不符合条件 这里已经l==3了 continue和return是一样的效果</span></span><br><span class="line">    <span class="comment">// part符合条件</span></span><br><span class="line">    ip.push(part.slice());</span><br><span class="line">    <span class="comment">// 下次递归的子串的起始位置是start+l</span></span><br><span class="line">    dfs(res, ip, start + l, s);</span><br><span class="line">    ip.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="473-Matchsticks-to-Square"><a href="#473-Matchsticks-to-Square" class="headerlink" title="[473] Matchsticks to Square"></a>[473] Matchsticks to Square</h5><blockquote>
<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used <strong>exactly</strong> one time.</p>
<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>
</blockquote>
<p>需要注意的是, 在采用递归方法的情况下,  这里不需要在选择位置的外面再套一层for循环去遍历火柴, 因为不存在第一根火柴找到合适位置之后, 把第一根火柴去掉, 以第二根火柴为第一根火柴, 再重新开始摆放. 只需要每根火柴摆放好之后, 去递归摆放下一根火柴即可.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用小女孩的所有火柴拼成一个正方形</span></span><br><span class="line"><span class="comment">// 回溯 使用所有的火柴 每根火柴只能用一次</span></span><br><span class="line"><span class="keyword">var</span> makesquare = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  nums.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">  helper(nums, <span class="number">0</span>, res, sum / <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> res[<span class="number">0</span>] != <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> helper = <span class="function">(<span class="params">nums, index, res, sum</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 递归结束条件 所有火柴均已放置</span></span><br><span class="line">  <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">    <span class="comment">// 找到可行解</span></span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>] == res[<span class="number">1</span>] &amp;&amp; res[<span class="number">1</span>] == res[<span class="number">2</span>] &amp;&amp; res[<span class="number">2</span>] == res[<span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每根火柴均有四个位置可以选择</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; res.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[j] + nums[index] &lt;= sum) &#123;</span><br><span class="line">      <span class="comment">// 做选择</span></span><br><span class="line">      res[j] += nums[index];</span><br><span class="line">      <span class="keyword">if</span> (helper(nums, index + <span class="number">1</span>, res, sum)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到可行解就返回 不再继续尝试</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 撤销选择</span></span><br><span class="line">      res[j] -= nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 走到这里说明 剩下的火柴怎么摆放都达不到要求</span></span><br><span class="line">  <span class="comment">// 说明上一层摆错了位置</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Search</title>
    <url>/2020/08/03/Binary-Search/</url>
    <content><![CDATA[<h3 id="二分查找-折半查找"><a href="#二分查找-折半查找" class="headerlink" title="二分查找/折半查找"></a>二分查找/折半查找</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>数列有序; </p>
<p>数列使用顺序存储结构</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>将目标元素与有序数列的中间元素比较大小, 比中间元素大, 则在数列的右半部分查找, 比中间元素小, 则在数列的左半部分查找, 如果相等, 则找到.</p>
<p>不会查找所有的元素, 查找的数据量正好符合元素的对数, 正常情况每次查找的元素都在对半减少.所以时间复杂度为 $O(log_2N)$.</p>
<img src="Binary-Search/binary-search.png" height="70%" width="70%">

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>根据要找的key的大小, 从更接近的位置进行查找.eg.1-100000找10, 肯定采取顺序查找而不是折半查找.</p>
<p>called 插值查找. 适用于数列比较大&amp;均匀的数列.</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序; 元素个数较多; 不进行频繁增删</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="普通的二分查找"><a href="#普通的二分查找" class="headerlink" title="普通的二分查找"></a>普通的二分查找</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准的二分查找模板</span></span><br><span class="line"><span class="keyword">var</span> binary_search = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>; <span class="comment">// 注意! [0, nums.length-1] 闭区间</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 停止条件: 找不到/数组为空</span></span><br><span class="line">  <span class="comment">// 找不到时是区间为空 当 left=right+1 时区间为空</span></span><br><span class="line">  <span class="comment">// 注意!</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// 防止使用 (left+right)/2 计算 mid 时溢出 </span></span><br><span class="line">    mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123; <span class="comment">// 对于已经比较过的mid 不应该在下一次进行搜索的区间内</span></span><br><span class="line">      right = mid - <span class="number">1</span>; <span class="comment">// 注意!</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>; <span class="comment">// 注意!</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="寻找左侧边界的二分查找-模板"><a href="#寻找左侧边界的二分查找-模板" class="headerlink" title="寻找左侧边界的二分查找(模板)"></a>寻找左侧边界的二分查找(模板)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search_left = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 循环停止条件是 left = right + 1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123; <span class="comment">// 关键 !!! 向左缩小区域</span></span><br><span class="line">      right = mid - <span class="number">1</span>; <span class="comment">// 探索区间为 [left, mid-1]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>; <span class="comment">// 探索区间为 [left, mid-1]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>; <span class="comment">// 探索区间为 [mid+1, right]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log('left:', left, 'mid:', mid, 'right:', right);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理数组越界情况</span></span><br><span class="line">  <span class="comment">// target&gt;所有值(left==nums.length) || target&lt;所有值(right==-1)</span></span><br><span class="line">  <span class="comment">// nums[left] != target ps.即使right == -1 left==0 nums[0]也有可能是target</span></span><br><span class="line">  <span class="keyword">if</span> (left == len || nums[left] != target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="寻找右侧边界的二分查找-模板"><a href="#寻找右侧边界的二分查找-模板" class="headerlink" title="寻找右侧边界的二分查找(模板)"></a>寻找右侧边界的二分查找(模板)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search_right = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 循环停止条件是 left = right + 1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123; <span class="comment">// 关键!!! 向右缩小区域</span></span><br><span class="line">      left = mid + <span class="number">1</span>; <span class="comment">// 探索区间为 [mid+1, right]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>; <span class="comment">// 探索区间为 [left, mid-1]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>; <span class="comment">// 探索区间为 [mid+1, right]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log('left:', left, 'mid:', mid, 'right:', right);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理数组越界情况</span></span><br><span class="line">  <span class="comment">// target&gt;所有值(left==nums.length) || target&lt;所有值(right==-1)</span></span><br><span class="line">  <span class="comment">// 即使left==len 但是 right==len-1 nums[right]也有可能是target</span></span><br><span class="line">  <span class="keyword">if</span> (nums[right] != target || right == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="[33] Search in Rotated Sorted Array"></a>[33] Search in Rotated Sorted Array</h4><blockquote>
<p>You are given an integer array <code>nums</code> sorted in ascending order, and an integer <code>target</code>.</p>
<p>Suppose that <code>nums</code> is rotated at some pivot unknown to you beforehand (i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p><em>If <code>target</code> is found in the array return its index, otherwise, return <code>-1</code>.</em></p>
</blockquote>
<ol>
<li>确定有序部分 判断target在哪个部分</li>
<li>边界 当数组两端或者中间找不到target时的情况处理</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较中间元素与最后一个元素的大小 确定有序区间</span></span><br><span class="line"><span class="comment">// 再将目标值与该区间的首尾元素比较 确定是否在该区域内</span></span><br><span class="line"><span class="comment">// 给定的nums中无重复元素</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 处理特殊情况</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/** 需要注意的是 有序区间的另外半边 </span></span><br><span class="line"><span class="comment">   * 根据其中间元素与末尾元素(right)对比</span></span><br><span class="line"><span class="comment">   * 仍然可以划分出有序区间 </span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="comment">// 处理在数组中间left==right但是nums[mid]!=target的情况</span></span><br><span class="line">    <span class="comment">// 此时也没有找到目标元素</span></span><br><span class="line">    <span class="keyword">if</span> (left == right &amp;&amp; nums[mid] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 先判断哪边是有序序列 再看目标元素是否在有序区间内</span></span><br><span class="line">    <span class="comment">// 由于没有重复元素 则不会出现 nums[mid] = nums[right] 的情况</span></span><br><span class="line">    <span class="comment">// 一定会存在升序序列</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123; <span class="comment">// 右边有序</span></span><br><span class="line">      <span class="comment">// 看目标元素是否在右侧有序区间内</span></span><br><span class="line">      <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123; <span class="comment">// 左边有序</span></span><br><span class="line">      <span class="comment">// 看目标元素是否在左侧有序区间内</span></span><br><span class="line">      <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理target&lt;min(nums)或者target&gt;max(nums) 两种情况</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="[35] Search Insert Position"></a>[35] Search Insert Position</h4><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
</blockquote>
<h6 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h6><p>我是哪里来的if-else怪物(为了边界情况, 疯狂if-else), 代码一点都不优雅, 考点应该是折半查找, 被我写成这个样子. 不说了, 我去找优雅解法去了…..</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">    end = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> mid = start + index(end - start);</span><br><span class="line">  <span class="comment">// 数组len=1</span></span><br><span class="line">  <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> start</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123; <span class="comment">// 数组len=2</span></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">      <span class="keyword">return</span> end + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == nums[start])</span><br><span class="line">      <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> end</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 数组len&gt;2</span></span><br><span class="line">    <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target:'</span> + target + <span class="string">'&lt;'</span> + <span class="string">"nums["</span> + mid + <span class="string">"]:"</span> + nums[mid]);</span><br><span class="line">        end = mid;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (target == nums[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mid = start + index(end - start);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target:'</span> + target + <span class="string">'&gt;'</span> + <span class="string">"nums["</span> + mid + <span class="string">"]:"</span> + nums[mid]);</span><br><span class="line">        start = mid;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (target == nums[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end + <span class="number">1</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mid = start + index(end - start);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(mid);</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = <span class="function">(<span class="params">gap</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (gap % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> gap / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (gap + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="solution-on-the-Internet"><a href="#solution-on-the-Internet" class="headerlink" title="solution on the Internet"></a>solution on the Internet</h6><p>参考网上的解法, 优化了一下, 感觉稍微简洁了些, 这里的mid取值是靠左的.所以一开始判断end值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (target &gt; nums[end])</span><br><span class="line">    <span class="keyword">return</span> end + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// if (target &lt; nums[start])</span></span><br><span class="line">  <span class="comment">//   return 0;</span></span><br><span class="line">  <span class="comment">// if (target == nums[start])</span></span><br><span class="line">  <span class="comment">//   return start</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">    mid = start + <span class="built_in">parseInt</span>((end - start) / <span class="number">2</span>); <span class="comment">// parseInt 直接丢弃小数部分, 保留整数部分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mid: '</span>, mid, <span class="string">' start: '</span>, start, <span class="string">' end: '</span>, end);</span><br><span class="line">    <span class="keyword">if</span> (target == nums[start])</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    <span class="keyword">if</span> (target == nums[end])</span><br><span class="line">      <span class="keyword">return</span> end;</span><br><span class="line">    <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// console.log('target &gt; mid', 'start: ', start);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      end = mid;</span><br><span class="line">      <span class="comment">// console.log('target &lt; mid', 'end: ', end);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="[81] Search in Rotated Sorted Array II"></a>[81] Search in Rotated Sorted Array II</h4><blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>This is a follow up problem to <a href="vscode-webview://5ad24d3b-f3dc-4f27-82d5-8e23615b83c1/problems/search-in-rotated-sorted-array/description/">Search in Rotated Sorted Array</a>, where <code>nums</code> may contain duplicates.</li>
<li>Would this affect the run-time complexity? How and why?</li>
</ul>
</blockquote>
<p>有重复元素的有序数组分为了两个部分, 颠倒之后的数组的第一个元素一定&gt;=第二部分的任意元素.</p>
<p>将需要搜索的部分分为三个部分, 前半个数组[left, mid)/中间元素mid/后半个数组(mid, right]</p>
<p>mid和target可能分别在左右部分, 对这两者的位置组合进行分情况讨论. 如果target在左min(left)和max(right)之间, 则直接返回false.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来没有重复元素时 判断有序数组比较好判断 直接比较大小</span></span><br><span class="line"><span class="comment">// 现在有重复元素 无法通过比较中间元素与最右元素的大小来确定哪一边数组是有序的</span></span><br><span class="line"><span class="comment">// 也就无法知道target应该在mid的哪一边</span></span><br><span class="line"><span class="comment">// eg. 1,1,2,3,1,1,1,1,1,1,1,1</span></span><br><span class="line"><span class="comment">// 普遍意义的二分查找不能使用了 但是不能使用遍历的方法(O(N))</span></span><br><span class="line"><span class="comment">// 为了O(logN)的时间复杂度必须想其他方法</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先写一个标准的二分查找</span></span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 找到目标元素</span></span><br><span class="line">    <span class="keyword">if</span> (target == nums[mid]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 看mid在哪个部分</span></span><br><span class="line">    <span class="comment">// mid in left part</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; nums[left]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target &gt; nums[mid]) &#123; <span class="comment">// target in left and &gt; mid</span></span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[left]) &#123; <span class="comment">// target in left and &lt; mid</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt;= nums[right]) &#123; <span class="comment">// target in right</span></span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// target 左右部分均不在</span></span><br><span class="line">        <span class="comment">// 考虑测试案例 [1,3,1,1,1] 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// mid in right part</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[left]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target &lt; nums[mid]) &#123; <span class="comment">// target in right and &lt; mid</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; <span class="comment">// target in right and &gt; mid</span></span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt;= nums[left]) &#123; <span class="comment">// target in left</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// target 左右部分均不在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[left]) &#123; <span class="comment">// mid in left or right</span></span><br><span class="line">      <span class="comment">// 此时不能根据nums[mid]与target的大小比较确定接下来的收缩范围</span></span><br><span class="line">      <span class="comment">// 不确定是 left=mid+1 or right=mid-1</span></span><br><span class="line">      left = left + <span class="number">1</span>; <span class="comment">// or right=right-1; 逐步缩小搜索范围</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="[153] Find Minimum in Rotated Sorted Array"></a>[153] Find Minimum in Rotated Sorted Array</h4><blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<p>总体思路: 使用二分查找, 不断寻找有序部分的最小值, 返回最小值中的最小值.</p>
<p>时间复杂度: logN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先确定有序的部分 保留其最小值x</span></span><br><span class="line"><span class="comment">// 然后再使用二分查找查找剩下无序部分中的升序部分的最小值 与x比较保留较小值</span></span><br><span class="line"><span class="keyword">var</span> findMin = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, mid = <span class="number">0</span>, min = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// 此时判断一下最小值</span></span><br><span class="line">    <span class="comment">// eg [3,4,5,0,1,2]</span></span><br><span class="line">    <span class="comment">// 最后left==right==3(index)而此时 nums[3]==0 是最小值</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">      min = <span class="built_in">Math</span>.min(nums[left], min);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123; <span class="comment">// right is ordered</span></span><br><span class="line">      min = <span class="built_in">Math</span>.min(nums[mid], min); <span class="comment">// 获取有序列表的最小值</span></span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123; <span class="comment">// left is ordered</span></span><br><span class="line">      min = <span class="built_in">Math</span>.min(nums[left], min); <span class="comment">// 获取有序列表的最小值</span></span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Tree</title>
    <url>/2020/09/27/Binary-Tree/</url>
    <content><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>每个节点最多只有两个分支的树结构, 子树分左右.</p>
<p>每层的节点数&lt;=2^(i-1), 总共的节点数</p>
<p>假设<strong>根节点的层数为1,</strong> 则一颗<strong>二叉树总共的节点数不超过2^k-1</strong>(等比数列求和公式得来)</p>
<h4 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h4><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>定义: 深度为k, 且总节点数为2^k-1的二叉树, 数的外形是严格三角形.</p>
<p>假设总结点数为n, 则树高为$log_2(n+1)$.</p>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>定义: 高度为h的二叉树,  其第0到(h-1)层的节点都满, 第h层节点不满, 且最后一层的节点都是从左往右排, 节点都在左边, 空位都在右边. Called 完全二叉树. 与满二叉数的节点一一对应.</p>
<p>性质: </p>
<p>一棵完全二叉树的节点数目为 n, 假设根节点的序号为0,  则最后一个节点的序号为n-1. </p>
<p>对于序号为i的节点, 其父节点序号为 <strong>(i-1)/2</strong> [向下取整 画图可知]. 左子节点为left = 2*i+1(前提是left&lt;=n-1), 右子节点序号为 right = 2*i+2(前提是right&lt;=n-1).</p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>按照系统化方式访问二叉树的每一个节点, 每棵二叉树都有唯一的根节点 root, 是基于树结构的处理入口.</p>
<img src="Binary-Tree/二叉树.png" width="50%" height="50%">

<blockquote>
<p>深度优先遍历</p>
</blockquote>
<h5 id="前-根-序遍历"><a href="#前-根-序遍历" class="headerlink" title="前(根)序遍历"></a>前(根)序遍历</h5><p>先访问根节点, 再访问左节点和右节点</p>
<p>ABDHEICFJKG</p>
<h5 id="中-根-序遍历"><a href="#中-根-序遍历" class="headerlink" title="中(根)序遍历"></a>中(根)序遍历</h5><p>先访问左子树, 再访问根节点, 再访问右子树</p>
<p>DHBEIAJFKCG</p>
<h5 id="后-根-序遍历"><a href="#后-根-序遍历" class="headerlink" title="后(根)序遍历"></a>后(根)序遍历</h5><p>先访问左右子树, 再访问根节点.</p>
<p>HDIEBJKFGCA</p>
<p>注意: 任意一棵树的任意一种遍历序列都无法唯一确定相应的二叉树.</p>
<blockquote>
<p>广度优先遍历</p>
</blockquote>
<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>ABCDEFGHIJK</p>
<h5 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h5><p>主要使用递归法进行理解与实现.</p>
<p>深度优先一般使用递归方法/栈结构,  广度优先遍历使用队列.</p>
<p>中序(知道左右子树的位置)+前序/后序(知道根节点的位置) + 元素不重复 –&gt; 复原二叉树结构</p>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>统计每个节点被访问的次数</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="二叉查找树-Binary-Search-Tree-BST"><a href="#二叉查找树-Binary-Search-Tree-BST" class="headerlink" title="二叉查找树(Binary Search Tree-BST)"></a>二叉查找树(Binary Search Tree-BST)</h3><p>每个节点都包含一个可比较的键以及相应的值, 且每个节点的值都&gt;=左子树中任意节点的键, &lt;右子树中任意节点的键.</p>
<p><strong>使用中序遍历可以得到一个有序数组</strong>.</p>
<p>BST使用的每个节点含有2个链接.</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript Notes</title>
    <url>/2020/09/01/JavaScript-Notes/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><h3 id="布尔值-Boolean"><a href="#布尔值-Boolean" class="headerlink" title="* 布尔值 Boolean"></a>* 布尔值 Boolean</h3><p>true/false</p>
<h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="* 字符串 String"></a>* 字符串 String</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">'hello'</span>; <span class="comment">// 字面量创建</span></span><br><span class="line"><span class="keyword">let</span> thing = <span class="number">98</span>; <span class="comment">// 任何可以转换成字符串的值</span></span><br><span class="line"><span class="comment">/* String 函数 生成或者将值转换为字符串 */</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>(thing); <span class="comment">// 将thing转换为原始字符串</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="keyword">new</span> <span class="built_in">String</span>(thing); <span class="comment">// 新建String对象, 并存储thing的字符串表示</span></span><br><span class="line"><span class="built_in">console</span>.log(s1, <span class="keyword">typeof</span> s1); <span class="comment">// hello string</span></span><br><span class="line"><span class="built_in">console</span>.log(s2, <span class="keyword">typeof</span> s2); <span class="comment">// 98 string</span></span><br><span class="line"><span class="built_in">console</span>.log(s3, <span class="keyword">typeof</span> s3); <span class="comment">// [String: '98'] object</span></span><br></pre></td></tr></table></figure>

<p>字符串一旦创建, 其内容不可被修改, 只能重新被赋值.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>;</span><br><span class="line">str[<span class="number">1</span>] = <span class="string">'*'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str, str[<span class="number">1</span>]); <span class="comment">// hello e</span></span><br><span class="line">str = <span class="string">"world"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// world</span></span><br></pre></td></tr></table></figure>



<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>length</code></p>
<p>字符串长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><code>constructor</code></p>
<p>对创建该对象的函数的引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.constructor); <span class="comment">// [Function: String]</span></span><br></pre></td></tr></table></figure>



<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><p><code>toUpperCase</code>  </p>
<p>字符串变大写</p>
<p><code>toLowerCase</code>  </p>
<p>字符串变小写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hello'</span>, t = <span class="string">'JINLING'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.toUpperCase(), s); <span class="comment">// HELLO hello</span></span><br><span class="line"><span class="built_in">console</span>.log(t.toLowerCase(), t); <span class="comment">// jinling JINLING</span></span><br></pre></td></tr></table></figure>

<p><code>trim</code></p>
<p>去除字符串两边的空白. 原字符串未改变.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"   hello   *   "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.trim(), <span class="string">', |'</span> + str + <span class="string">'|'</span>); <span class="comment">// hello   * , |   hello   *   |</span></span><br></pre></td></tr></table></figure>

<p><code>split</code> </p>
<p>根据分隔符将字符串分割为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'hel,l,o'</span>;</span><br><span class="line"><span class="comment">// 不切割 整个字符串视作数组的一个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split());  <span class="comment">// [ 'hel,l,o' ]</span></span><br><span class="line"><span class="comment">// 每个字符都是数组中的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split(<span class="string">''</span>));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment"> 'h', 'e', 'l',</span></span><br><span class="line"><span class="comment"> ',', 'l', ',',</span></span><br><span class="line"><span class="comment"> 'o'</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 以逗号分割</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split(<span class="string">','</span>), s); <span class="comment">// [ 'hel', 'l', 'o' ] hel,l,o</span></span><br></pre></td></tr></table></figure>

<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><code>indexOf</code></p>
<p>查找字符串中有无指定字符串, 有则返回下标, 没有则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"hello jinling!"</span></span><br><span class="line"><span class="keyword">let</span> res1  = s.indexOf(<span class="string">"hi"</span>);</span><br><span class="line"><span class="keyword">let</span> res2  = s.indexOf(<span class="string">"jin"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1, res2); <span class="comment">// -1 6</span></span><br></pre></td></tr></table></figure>

<p><code>includes</code></p>
<p>查找字符串是否包含指定子串, 有则返回<code>true</code>, 反之<code>false</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello jinling good"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">"hello"</span>), str.includes(<span class="string">"world"</span>)); <span class="comment">// true false</span></span><br></pre></td></tr></table></figure>

<p><code>charAt</code></p>
<p>返回字符串中对应下标的字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"hello*jinling!"</span></span><br><span class="line"><span class="keyword">let</span> ch = s.charAt(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ch); <span class="comment">// *</span></span><br></pre></td></tr></table></figure>

<h5 id="拼接-截取"><a href="#拼接-截取" class="headerlink" title="拼接/截取"></a>拼接/截取</h5><p><code>concat</code></p>
<p>拼接两个或者更多字符串, 返回新字符串, 不改变原字符串.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"hello"</span>, s2 = <span class="string">"*go"</span>, s3 = <span class="string">"*hhh"</span>;</span><br><span class="line"><span class="keyword">let</span> s = s1.concat(s2, s3);</span><br><span class="line"><span class="built_in">console</span>.log(s, s1, s2, s3) <span class="comment">// hello*go*hhh hello *go *hhh</span></span><br></pre></td></tr></table></figure>

<p><code>slice</code></p>
<p>截取字符串的片段, 不改变原字符串.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"helloWorld"</span>;</span><br><span class="line"><span class="keyword">let</span> s = str.slice(<span class="number">3</span>, <span class="number">7</span>); <span class="comment">// [起始位置, 结束位置)</span></span><br><span class="line"><span class="built_in">console</span>.log(s, str); <span class="comment">// loWo helloWorld</span></span><br></pre></td></tr></table></figure>

<p><code>substring</code></p>
<p>截取字符串的片段, 不改变原字符串.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'helloWorld'</span>;</span><br><span class="line"> <span class="comment">// [起始位置, 结束位置)</span></span><br><span class="line"><span class="built_in">console</span>.log(s.substring(<span class="number">1</span>, <span class="number">8</span>), s); <span class="comment">// elloWor helloWorld</span></span><br></pre></td></tr></table></figure>

<p><code>substr</code></p>
<p>截取指定长度的子串. (ps. ECMAscript 没有对该方法进行标准化，因此反对使用它。)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'helloWorld'</span>;</span><br><span class="line"><span class="comment">// 起始位置 截取长度</span></span><br><span class="line"><span class="built_in">console</span>.log(s.substr(<span class="number">1</span>, <span class="number">4</span>), s); <span class="comment">// ello helloWorld</span></span><br></pre></td></tr></table></figure>



<h3 id="数字-Number"><a href="#数字-Number" class="headerlink" title="* 数字 Number"></a>* 数字 Number</h3><p>数字可以是数字或者对象, Number 对象是原始数值的包装对象. JS只有一种数字类型.</p>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基础类型创建 */</span></span><br><span class="line"><span class="keyword">let</span> k = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> k); <span class="comment">// number</span></span><br><span class="line"><span class="comment">// 科学计数法</span></span><br><span class="line"><span class="keyword">let</span> t = <span class="number">123e5</span>, k = <span class="number">123e-5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> t, t, <span class="keyword">typeof</span> k, k); <span class="comment">// number 12300000 number 0.00123</span></span><br><span class="line"><span class="comment">// 八进制以0开头</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0122</span>; <span class="comment">// 数字以 0 开头, 且后面的数字都比8小, 则js解释为八进制</span></span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// 82</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0888</span>; <span class="comment">// 后面数字&gt;=8, 则依然解释为十进制</span></span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// 888</span></span><br><span class="line"><span class="comment">// 十六进制以0x开头</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0x11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对象形式创建 */</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"99"</span>), n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> m, m, <span class="keyword">typeof</span> n, n); </span><br><span class="line"><span class="comment">// object [Number: 99] object [Number: 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"kill"</span>); <span class="comment">// 不能转换为数字时</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> t, t); <span class="comment">// object [Number: NaN]</span></span><br></pre></td></tr></table></figure>

<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>返回对创建此对象的 Number 函数的引用.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor); <span class="comment">// [Function: Number]</span></span><br></pre></td></tr></table></figure>



<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><code>toString</code></p>
<p>将数字转变为字符串, 使用指定的基数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"99"</span>);</span><br><span class="line"><span class="keyword">let</span> str = t.toString();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定的基数</span></span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"10"</span>);</span><br><span class="line"><span class="keyword">let</span> str = t.toString(<span class="number">2</span>); <span class="comment">// 十进制转变为二进制</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"10"</span>);</span><br><span class="line"><span class="keyword">let</span> str = t.toString(<span class="number">8</span>); <span class="comment">// 十进制转变为八进制</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); string <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><code>valueOf</code></p>
<p>返回一个 Number 对象的基本数字值.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"99"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(t.valueOf()); <span class="comment">// 99</span></span><br></pre></td></tr></table></figure>

<p><code>isFinite</code></p>
<p>判断参数是否为无穷大</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">123</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">-1.23</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">5</span><span class="number">-2</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'123'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'Hello'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'2005/12/12'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0</span> / <span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>isNaN</code></p>
<p>使用全局函数判断<code>NaN</code>(教程推荐).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(a), <span class="built_in">isNaN</span>(<span class="number">8</span>), <span class="built_in">isNaN</span>(<span class="string">"11"</span>)); <span class="comment">// true false false</span></span><br></pre></td></tr></table></figure>



<h3 id="Symbol-ES6"><a href="#Symbol-ES6" class="headerlink" title="* Symbol (ES6)"></a>* Symbol (ES6)</h3><p>基本数据类型, ES6新增, 表示独一无二的值. 由于 ES5 对象的属性名只能是字符串, 容易造成属性名的冲突, 需要独一无二的值.</p>
<p>具有静态属性与静态方法. 模拟对象私有属性.</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>通过<code>Symbol</code>函数产生.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受字符串作为参数, 表示对Synbol实例的描述, 主要为了在控制台显示或者转为字符串时容易被区分.</span></span><br><span class="line"><span class="built_in">Symbol</span>(**description?: string | number**): symbol</span><br><span class="line"></span><br><span class="line">Description <span class="keyword">of</span> the <span class="keyword">new</span> <span class="built_in">Symbol</span> object.</span><br><span class="line"></span><br><span class="line">Returns a <span class="keyword">new</span> unique <span class="built_in">Symbol</span> value.</span><br></pre></td></tr></table></figure>

<p>每个从 Symbol 返回的symbol值都是唯一的, 尽管参数相同.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>(<span class="number">34</span>); </span><br><span class="line"><span class="comment">// Symbol 不会将'hello'转变为symbol类型, 每次创建一个新的symbol类型.</span></span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'hello'</span>); </span><br><span class="line"><span class="keyword">let</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">'hello'</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym, sym); <span class="comment">// symbol Symbol()</span></span><br><span class="line"><span class="built_in">console</span>.log(sym1 == <span class="number">34</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(sym2 == <span class="string">'hello'</span>, sym2, sym2.toString()); <span class="comment">// false Symbol(hello) 'Symbol(hello)'</span></span><br><span class="line"><span class="built_in">console</span>.log(sym2 === sym3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol</code>可以转换为<strong>字符串</strong>以及<strong>布尔值</strong>, 但是不能转换为数值.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'happy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.toString(), <span class="built_in">String</span>(s1)); <span class="comment">// Symbol(happy) Symbol(happy)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'happy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(s1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'happy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(s1)); <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure>

<p>对原始数据类型创建一个显式包装器对象从ES6开始不再被支持, 但是原有的 new Boolean/new String/new Number 由于遗留原因仍然可以被创建.</p>
<p>如果真的想创建一个Symbol包装器, 可以使用Object()函数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// symbol 是原始数据类型 不是对象</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="number">34</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">let</span> symObj = <span class="built_in">Object</span>(sym);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symObj); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<h4 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[mySymbol] = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 将对象的属性名指定为一个 Symbol 值</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'hello'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种写法 同样结果</span></span><br><span class="line">obj[mySymbol] <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>

<p>Symbol作为对象属性时, 不能使用点运算符, 只能使用方框.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[mySymbol] = <span class="string">'hello'</span>;</span><br><span class="line">obj.mySymbol = <span class="string">'hi'</span>; <span class="comment">// 相当于属性名为 'mySymbol' 字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.mySymbol); <span class="comment">// hi</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[mySymbol]); <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为对象属性, 只能使用方框</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强的对象写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s] (arg) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="null"><a href="#null" class="headerlink" title="* null"></a>* null</h3><p><code>null</code> : 表示主动释放指向对象的引用.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 释放指向数组的引用</span></span><br></pre></td></tr></table></figure>

<p>设计之初, <code>null</code> 像在java里一样, 被当成一个<strong>对象</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>可以自动转为 0 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>), <span class="number">8</span> + <span class="literal">null</span>); <span class="comment">// 0 8</span></span><br></pre></td></tr></table></figure>

<p><strong>用法: null 表示”没有对象”, 即 该处不应该有值.</strong></p>
<ol>
<li>作为函数的参数, 表示该函数的参数不是对象</li>
<li>作为对象原型链的终点</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>



<h3 id="undefined"><a href="#undefined" class="headerlink" title="* undefined"></a>* undefined</h3><p>Brendan Eich 觉得, 表示’无’的值, 最好不是对象. 其次, 由于js初版本没有错误处理机制, null 自动转为 0 不容易发现错误. 于是 Brendan Eich又设计了一个<code>undefined</code>.</p>
<p>一开始 <code>undefined</code> 被设计为表示’无’的原始值, 转为数字时为 NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>), <span class="number">8</span> + <span class="literal">undefined</span>); <span class="comment">// NaN NaN</span></span><br></pre></td></tr></table></figure>

<p><strong>用法: undefined 表示”缺少值”, 就是此处应该有一个值, 但是还没有定义.</strong></p>
<ol>
<li>变量被声明过, 但是没有赋值, 等于 undefined</li>
<li>调用函数时, 应该提供的参数没有提供, 则该参数为 undefined</li>
<li>对象没有赋值的属性, 该属性值为 undefined</li>
<li>函数没有返回值时, 默认返回 undefined.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法 1</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">// undefined undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法 2</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法 3</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法 4</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="params">()</span> =&gt;</span> &#123; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<h4 id="undefined-与-null-区别"><a href="#undefined-与-null-区别" class="headerlink" title="undefined 与 null 区别"></a>undefined 与 null 区别</h4><p>两者使用 == 时为true, === 时为false.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>, <span class="literal">undefined</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// true false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在if语句中, 两者都被转成 false</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) <span class="built_in">console</span>.log(<span class="string">'undefined if false'</span>); <span class="comment">// undefined if false</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) <span class="built_in">console</span>.log(<span class="string">'null if false'</span>); <span class="comment">// null if false</span></span><br></pre></td></tr></table></figure>



<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="* 数组 Array"></a>* 数组 Array</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = []; <span class="comment">// 字面</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 不固定长度</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// 固定长度</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr0, arr1, arr2, arr3); <span class="comment">// [] [] [ &lt;5 empty items&gt; ] [ 1, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="其他数据类型转数组"><a href="#其他数据类型转数组" class="headerlink" title="其他数据类型转数组"></a>其他数据类型转数组</h4><p>set-&gt;Array</p>
<p>Array.from(set)</p>
<p>string-&gt;Array</p>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><p><code>length</code></p>
<blockquote>
<p>计算并返回数组长度</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">// 字面</span></span><br><span class="line"><span class="built_in">console</span>.log(arr0.length); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><code>constructor</code></p>
<blockquote>
<p>返回创建该对象的函数的引用, 因为js的一切变量都是对象, 是对象就有其构造函数.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">if</span> (test.constructor==<span class="built_in">Array</span>)&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(test.constructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: function Array() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><h5 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h5><p><strong>Array.sort()</strong></p>
<blockquote>
<p>对数组元素进行排序, 默认是字符串顺序.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照字母顺序排序 默认</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'good'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'google'</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 'Bob', 'are', 'good', 'google', 'hi', 'you' ]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加比值函数, 使得能对<strong>数字进行排序</strong>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用比值函数</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">76</span>, <span class="number">91</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr); </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  0,  1, 12,  3, 34,</span></span><br><span class="line"><span class="comment">  7, 76,  9, 91</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比值函数 倒序</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">76</span>, <span class="number">91</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  91, 76, 34, 12, 9,</span></span><br><span class="line"><span class="comment">   7,  3,  1,  0</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用比值函数 正序</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">76</span>, <span class="number">91</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(arr); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">   0,  1,  3,  7, 9,</span></span><br><span class="line"><span class="comment">  12, 34, 76, 91</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.pop()</strong></p>
<blockquote>
<p>删除数组的最后一个元素并返回该元素. 空数组返回<code>undefined</code>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr0.pop(), arr0);</span><br><span class="line"><span class="comment">// output: 4 [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.pop(), arr1);</span><br><span class="line"><span class="comment">// output: undefined []</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.shift()</strong></p>
<blockquote>
<p>删除并返回数组的第一个元素</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.shift(), arr1);</span><br><span class="line"><span class="comment">// 1 [ 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.unshift()</strong></p>
<blockquote>
<p>向数组的开头添加元素并返回现有长度</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.unshift(<span class="number">9</span>), arr1);</span><br><span class="line"><span class="comment">// 6 [ 9, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.push()</strong></p>
<blockquote>
<p>向数组末尾添加元素并返回数组现有长度</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.push(<span class="number">4</span>), arr1);</span><br><span class="line"><span class="comment">// output: 4 [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.reverse()</strong></p>
<blockquote>
<p>颠倒数组中元素顺序</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.reverse(), arr1);</span><br><span class="line"><span class="comment">// output: [ 3, 2, 1 ] [ 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.splice()</strong> </p>
<blockquote>
<p>推荐使用该方法删除数组元素</p>
<p>注意: 删除的元素以数组形式返回.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">1</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>); <span class="comment">// 从数组下标为2的位置开始删除1个元素,再插入2个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 'ok', 'fine', 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不留空洞地删除元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="comment">// 从下标为3的位置开始, 删除2个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// ['fine', 'you'] 注意这里是数组形式!</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 'ok', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p><strong>delete</strong>  </p>
<p>JS运算符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr); <span class="comment">// 留下了空洞</span></span><br><span class="line"><span class="comment">// undefined [ &lt;1 empty item&gt;, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>



<h5 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h5><p><strong>Array.slice()</strong></p>
<blockquote>
<p>根据下标获取数组的一部分, 返回新数组.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.slice(<span class="number">3</span>), arr1.slice(<span class="number">2</span>,<span class="number">4</span>), arr1);</span><br><span class="line"><span class="comment">// output: [ 4, 5 ] [ 3, 4 ] [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.concat()</strong></p>
<blockquote>
<p>拼接数组成一个新数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr0.concat(arr1), arr0, arr1);</span><br><span class="line"><span class="comment">// output: [ 1, 2, 3, 4, 5, 6 ] [ 1, 2, 3, 4 ] [ 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.flat()</strong></p>
<blockquote>
<p>按照指定的深度递归遍历数组, 将所有元素与遍历到的子数组中的元素合并为一个<strong>新数组</strong>返回.</p>
<p>将数组扁平化</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 默认递归深度为1 */</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="string">'ok'</span>, <span class="string">'fine'</span>]]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.flat();</span><br><span class="line"><span class="built_in">console</span>.log(arr1, arr);</span><br><span class="line"><span class="comment">// [ 1, 2, 'ok', 'fine' ] [ 1, 2, [ 'ok', 'fine' ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除数组空项</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, , , <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat());</span><br><span class="line"><span class="comment">// [ 1, 2, null, undefined, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定递归深度 */</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [[[<span class="string">'ok'</span>, <span class="string">'fine'</span>]]]];</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">2</span>), arr.flat(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// [ 1, 2, [ 'ok', 'fine' ] ] [ 1, 2, 'ok', 'fine' ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.join()</strong>  默认使用 <code>,</code> 为分隔符</p>
<blockquote>
<p><code>toString</code> 所有 JavaScript 对象都拥有<code>toString()</code>方法</p>
<p>数组所有元素组成字符串, 可以指定分隔符.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr0.join(), arr0.toString()); <span class="comment">// 1,2,3,4  1,2,3,4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr0.join(<span class="string">'*'</span>)); <span class="comment">// 1*2*3*4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr0); <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.map()</strong></p>
<blockquote>
<p>对数组的每个元素均执行函数, 对其做一些处理, 来生成新数组. <strong>不改变原数组</strong>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.map(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> val + <span class="string">'*'</span> + index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 原数组不变</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2, arr);</span><br><span class="line"><span class="comment">// [ '1*0', '2*1', 'ok*2', 'fine*3', 'you*4', 'bye*5' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> a = arr.map(<span class="function"><span class="params">c</span> =&gt;</span> c - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [ 0, 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.filter()</strong></p>
<blockquote>
<p>对数组的每个元素均执行函数, 筛选符合条件的元素来生成新数组.<strong>不改变原数组</strong>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.filter(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2, arr);</span><br><span class="line"><span class="comment">// [ 'ok', 'fine', 'you', 'bye' ] [ 1, 2, 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.forEach()</strong></p>
<blockquote>
<p>对数组的每个元素均执行一次函数(回调函数)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 该函数的参数1为数组元素,参数2为数组元素下标,参数3为该数组本身</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  s += (val + <span class="string">'/'</span> + index + <span class="string">' '</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// 1/0 2/1 ok/2 fine/3 you/4 bye/5</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.reduce()</strong></p>
<blockquote>
<p>参数<code>total</code> 默认是数组的第一个元素, 可以设置初始值.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'bye'</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"total="</span>, total, val, index); <span class="comment">// 从index=1开始打印</span></span><br><span class="line">  <span class="keyword">return</span> total + <span class="string">'*'</span> + val;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">total= bye hi 1</span></span><br><span class="line"><span class="comment">total= bye*hi ok 2</span></span><br><span class="line"><span class="comment">total= bye*hi*ok fine 3</span></span><br><span class="line"><span class="comment">total= bye*hi*ok*fine you 4</span></span><br><span class="line"><span class="comment">total= bye*hi*ok*fine*you bye 5</span></span><br><span class="line"><span class="comment">bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置total初始值</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'bye'</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + <span class="string">'*'</span> + val;</span><br><span class="line">&#125;, <span class="string">"this is :"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// this is :*bye*hi*ok*fine*you*bye [ 'bye', 'hi', 'ok', 'fine', 'you', 'bye' ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.reduceRight()</strong></p>
<blockquote>
<p>类似于<code>Array.reduce()</code>, 只不过是从右往左遍历元素.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'bye1'</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>, <span class="string">'you'</span>, <span class="string">'bye2'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduceRight(<span class="function">(<span class="params">total, val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + <span class="string">'*'</span> + val;</span><br><span class="line">&#125;, <span class="string">"this is res:"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// this is res:*bye2*you*fine*ok*hi*bye1 [ 'bye1', 'hi', 'ok', 'fine', 'you', 'bye2' ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.every()</strong></p>
<blockquote>
<p>检查数组中的元素是否<strong>都符合条件</strong>, 都符合才返回true, 否则返回false.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有元素不符合条件 false</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.every(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// false [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有元素均符合条件 true</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.every(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'number'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// true [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.some()</strong></p>
<blockquote>
<p>检查是否<strong>有元素符合条件</strong>, 有则返回true, 没有则返回false.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有元素符合条件 true</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">'hi'</span>, <span class="string">'ok'</span>, <span class="string">'fine'</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.some(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// true [ 1, 'hi', 'ok', 'fine' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有元素均不符合条件 false</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.some(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val == <span class="string">'string'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res, arr);</span><br><span class="line"><span class="comment">// false [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.indexOf()</strong></p>
<blockquote>
<p>找到给定元素在数组中第一次出现的位置, 没有则返回-1, 找到则返回元素下标.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找不到 -1, 找到就下标</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.indexOf(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> res2 = arr.indexOf(<span class="string">'how'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1, res2); <span class="comment">// -1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素多次出现 返回第一次出现的位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>];</span><br><span class="line"><span class="keyword">let</span> res2 = arr.indexOf(<span class="string">'Bob'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定搜索位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>];</span><br><span class="line"><span class="keyword">let</span> res2 = arr.indexOf(<span class="string">'Bob'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索起始位置可以是负值</span></span><br><span class="line"><span class="comment">// 负值是从数组末尾给定位置开始搜索, 直至末尾.</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.indexOf(<span class="string">'Bob'</span>, <span class="number">-1</span>), <span class="comment">// 从倒数第一个位置开始, 搜索不到</span></span><br><span class="line">    res2 = arr.indexOf(<span class="string">'Bob'</span>, <span class="number">-2</span>); <span class="comment">// 从倒数第二个位置开始搜索, 是可以检索到的, 返回正数下标</span></span><br><span class="line"><span class="built_in">console</span>.log(res1, res2); <span class="comment">// -1 5</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.lastIndexOf()</strong></p>
<blockquote>
<p>与上一个类似, 只是从数组末尾开始检索.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出现两次Bob, 但是返回了从右往左的第一个.</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.lastIndexOf(<span class="string">'Bob'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定搜索起始位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'how'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.lastIndexOf(<span class="string">'Bob'</span>, <span class="number">-3</span>); <span class="comment">// 从倒数第三个元素开始往左搜索, 返回匹配的第一个元素的下标</span></span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.find()</strong></p>
<blockquote>
<p>返回符合条件的第一个元素</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'good'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.find(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> val.length &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// good</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.findIndex()</strong></p>
<blockquote>
<p>返回符合条件的第一个元素<strong>下标</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'Bob'</span>, <span class="string">'good'</span>, <span class="string">'are'</span>, <span class="string">'you'</span>, <span class="string">'Bob'</span>, <span class="string">'google'</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.findIndex(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> val.length &gt; <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><p>利用键本身的不可重复性</p>
<blockquote>
<p>利用ES6 Set 去重 (ES6中最常用)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简易写法</span></span><br><span class="line">[...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure>

<p>双层循环法 </p>
<blockquote>
<p>splice去重(ES5 常用)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每一个元素都向后检查有没有与自己相同的元素</span></span><br><span class="line">  <span class="comment">// 如果有 则删除第二个元素</span></span><br><span class="line">  <span class="comment">// 由于splice的特性 删除后 需要j-- 保证j指向被删除元素的下一个元素而不会遗漏元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123; <span class="comment">// 注意使用===, 因为 null === undefined 为true</span></span><br><span class="line">        arr.splice(j, <span class="number">1</span>);</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line">unique(arr1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr1:'</span>, arr1); <span class="comment">// arr1: [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 fliter+indexOf</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">val, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回符合条件的元素</span></span><br><span class="line">    <span class="comment">// 返回所有第一次出现的元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(val, <span class="number">0</span>) == index;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">undefined</span>];</span><br><span class="line"><span class="keyword">let</span> res = unique(arr1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'res:'</span>, res);</span><br><span class="line"><span class="comment">// res: [ 1, 2, 3, null, undefined ]</span></span><br></pre></td></tr></table></figure>



<h3 id="对象-Object"><a href="#对象-Object" class="headerlink" title="* 对象 Object"></a>* 对象 Object</h3><p>使用{}表示, 键必须是字符串.</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><blockquote>
<p>部署在object对象自身的方法</p>
</blockquote>
<p><code>Object.values</code> 获取对象的所有key, 输出类型为数组</p>
<p><code>Object.keys</code> 获取对象的所有value, 输出类型为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">key1</span>:<span class="string">'val1'</span>, <span class="attr">key2</span>:<span class="string">'val2'</span>, <span class="attr">key3</span>:<span class="string">'val3'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// [ 'val1', 'val2', 'val3' ]</span></span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyNames</code> 也是返回对象的所有属性名, 但是还会返回不可枚举的属性; 可枚举属性方面, 与<code>Object.keys</code>相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可枚举属性 二者不同</span></span><br><span class="line"><span class="keyword">let</span> obj1 = [<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'jinling'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj1)); <span class="comment">// [ '0', '1', '2' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj1)); <span class="comment">// [ '0', '1', '2', 'length' ] 包含不可枚举属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可枚举属性 二者相同</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">key1</span>:<span class="string">'val1'</span>, <span class="attr">key2</span>:<span class="string">'val2'</span>, <span class="attr">key3</span>:<span class="string">'val3'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// [ 'key1', 'key2', 'key3' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">// [ 'key1', 'key2', 'key3' ]</span></span><br></pre></td></tr></table></figure>



<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p><code>Object.hasOwnProperty</code>判断对象是否拥有某项属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">key1</span>:<span class="string">'val1'</span>, <span class="attr">key2</span>:<span class="string">'val2'</span>, <span class="attr">key3</span>:<span class="string">'val3'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'key2'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Map-ES6"><a href="#Map-ES6" class="headerlink" title="* Map (ES6)"></a>* Map (ES6)</h3><p>解决js对象的键只能是字符串的问题, <strong>ES6标准新增</strong>的数据类型.</p>
<h4 id="创建-添加-删除-是否包含"><a href="#创建-添加-删除-是否包含" class="headerlink" title="创建/添加/删除/是否包含"></a>创建/添加/删除/是否包含</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">90</span>], [<span class="string">'Bob'</span>, <span class="number">80</span>], [<span class="string">'Lily'</span>, <span class="number">95</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'Lily'</span>)); <span class="comment">// 95</span></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123; 'Michael' =&gt; 90, 'Bob' =&gt; 80, 'Lily' =&gt; 95 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空map, 然后添加元素</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'Michael'</span>, <span class="number">90</span>); <span class="comment">// 添加Key</span></span><br><span class="line">map.set(<span class="string">'Bob'</span>, <span class="number">80</span>);</span><br><span class="line">map.set(<span class="string">'Lily'</span>, <span class="number">95</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123; 'Michael' =&gt; 90, 'Bob' =&gt; 80, 'Lily' =&gt; 95 &#125;</span></span><br><span class="line">map.delete(<span class="string">'Lily'</span>); <span class="comment">// 删除 key</span></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123; 'Michael' =&gt; 90, 'Bob' =&gt; 80 &#125;</span></span><br><span class="line"><span class="comment">// 判断是否包含某key</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'hello'</span>), map.has(<span class="string">'Bob'</span>)); <span class="comment">// false true</span></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line"><span class="comment">// 一个key只对应一个value, 重复设置会覆盖之前的值</span></span><br><span class="line">map.set(<span class="string">'Bob'</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'Bob'</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>



<h3 id="Set-ES6"><a href="#Set-ES6" class="headerlink" title="* Set (ES6)"></a>* Set (ES6)</h3><p>一组不重复key的集合.ES6标准新增的数据类型.</p>
<h4 id="创建-添加-删除-是否包含-1"><a href="#创建-添加-删除-是否包含-1" class="headerlink" title="创建/添加/删除/是否包含"></a>创建/添加/删除/是否包含</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组作为输入</span></span><br><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set1); <span class="comment">// Set &#123; 5, 6, 7, 8 &#125; 重复元素被自动过滤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化空Set, 再添加值</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(1); // 添加元素</span><br><span class="line"><span class="keyword">set</span>.add(2);</span><br><span class="line"><span class="keyword">set</span>.add(3);</span><br><span class="line"><span class="keyword">set</span>.add(4);</span><br><span class="line">console.log(<span class="keyword">set</span>); //Set &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;</span><br><span class="line"><span class="keyword">set</span>.delete(3); // 删除元素</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span> &#125;</span><br><span class="line"><span class="keyword">set</span>.add(4); // 可以添加重复元素 但是无效</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span> &#125;</span><br><span class="line"><span class="comment">// '4' 与 4 不同</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.has('4'), <span class="keyword">set</span>.has(4)); // false true</span><br></pre></td></tr></table></figure>



<h3 id="类-Class"><a href="#类-Class" class="headerlink" title="* 类 Class"></a>* 类 Class</h3><p>特殊的函数, 由<strong>类表达式</strong>和<strong>类声明</strong>组成</p>
<h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><ol>
<li><p>类声明 带有<code>class</code>关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类需要先声明 再使用 不像函数声明会提升</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类表达式 可以具名或者匿名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello.name); <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名类</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="class"><span class="keyword">class</span> <span class="title">hello2</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello.name); <span class="comment">// hello2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传统的基于函数的类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  speak()&#123;</span><br><span class="line">    <span class="keyword">super</span>.speak();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' barks.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog(<span class="string">'cookie'</span>)</span><br><span class="line">d.speak(); </span><br><span class="line"><span class="comment">// cookie makes a noise.</span></span><br><span class="line"><span class="comment">// cookie barks.</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="类体和方法定义"><a href="#类体和方法定义" class="headerlink" title="类体和方法定义"></a>类体和方法定义</h4><p><code>constructor</code> </p>
<p>构造函数, 一种特殊方法, 创建和初始化一个由class创建的对象. </p>
<p>构造函数可以使用<code>super</code>调用父类的构造函数.</p>
<h4 id="extends创建子类"><a href="#extends创建子类" class="headerlink" title="extends创建子类"></a><code>extends</code>创建子类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  speak () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> make a noise`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog1</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, sex) &#123;</span><br><span class="line">    <span class="comment">// 调用超类构造函数并传入name参数</span></span><br><span class="line">    <span class="comment">// 必须先super 然后才能使用this</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  speak () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span> and barks`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog1(<span class="string">'cookie'</span>, <span class="string">'girl'</span>);</span><br><span class="line">d.speak(); <span class="comment">// cookie is girl and barks</span></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="* 函数"></a>* 函数</h3><p>函数定义是一个常规的绑定,  其中绑定的值是函数. </p>
<p>函数的第一种表示法.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大括号必要, 末尾建议带分号</span></span><br><span class="line"><span class="keyword">let</span> square = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数也是值的一种, 可以被赋值给多个变量/作为参数传递给函数等.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1111'</span>);</span><br><span class="line">&#125;</span><br><span class="line">func1(); <span class="comment">// 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func1 可以被绑定为其他函数</span></span><br><span class="line">func1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2222'</span>);</span><br><span class="line">&#125;</span><br><span class="line">func1 <span class="comment">// 2222</span></span><br></pre></td></tr></table></figure>

<p>没有 <code>return</code> 语句或 <code>return</code> 后面没有返回值, 函数将返回 <code>undefined</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func1()); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func2()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>每个局部作用域可以查看包含它的局部作用域, 所有局部作用域都能看见全局作用域.</p>
<h4 id="声明表示法"><a href="#声明表示法" class="headerlink" title="声明表示法"></a>声明表示法</h4><p>函数的第二种表示法.</p>
<p>声明在调用之后也能够工作, 声明在概念上被移到了作用域的顶部.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125; <span class="comment">// 不需要分号</span></span><br></pre></td></tr></table></figure>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>函数的第三种表示法. 以较简明的方式编写小型函数表达式.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两种写法相同</span></span><br><span class="line"><span class="keyword">let</span> square1 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square2 = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br></pre></td></tr></table></figure>

<h4 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h4><p>函数返回时必须跳回到调用它的位置, 所以计算机必须记住调用发生的上下文. 存储此上下文的位置是调用栈, 每次调用函数时, 当前上下文都存储在此栈的顶部.</p>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>多余参数自动忽略, 不足参数为 <code>undefined</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> square1 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square1(<span class="number">2</span>, <span class="number">7</span>, <span class="string">'helloo'</span>[<span class="number">2</span>, <span class="number">3</span>]), square1(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 2 7</span></span><br><span class="line"><span class="comment">// 2 undefined</span></span><br><span class="line"><span class="comment">// 14 NaN</span></span><br></pre></td></tr></table></figure>

<p>参数设定默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> square1 = <span class="function">(<span class="params">x, y = <span class="number">3</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(square1(<span class="number">2</span>, <span class="number">7</span>), square1(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 2 7</span></span><br><span class="line"><span class="comment">// 2 3</span></span><br><span class="line"><span class="comment">// 14 6</span></span><br></pre></td></tr></table></figure>

<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>能够读取函数局部变量的函数就是闭包. 下面例子中, <code>func2</code>函数就是闭包.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">999</span>;</span><br><span class="line">  <span class="keyword">var</span> func2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> func2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = func1();</span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>用途: 读取函数内部变量 / 让这些变量的值始终保持在内存中.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nAdd;</span><br><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">999</span>;</span><br><span class="line">  nAdd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> func2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a:'</span>,a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> func2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = func1(); <span class="comment">// 闭包函数</span></span><br><span class="line">func(); <span class="comment">// a 999</span></span><br><span class="line">nAdd();</span><br><span class="line">func(); <span class="comment">// a 1000</span></span><br></pre></td></tr></table></figure>

<p>证明了<code>func1</code>的局部变量<code>a</code>一直在内存中, 并没有在func1被调用后被自动清除. </p>
<p>因为<code>func1</code>是<code>func2</code>的父函数, 而<code>func2</code>被赋予了局部变量<code>func</code>, 导致<code>func2</code>一直在内存中, 则<code>func2</code>依赖的<code>func1</code>也一直在内存中, 不会在调用结束后, 被垃圾回收机制回收.</p>
<p>这里<code>nAdd</code>也是一个匿名函数, 也是一个闭包, 相当于一个setter, 可以在函数外部对函数内部局部变量进行操作.</p>
<p>使用闭包的注意点:</p>
<ol>
<li>闭包会使函数中的局部变量在内存中, 因此会使得内存占用过多, 不能滥用. 在退出函数前, 将不使用的局部变量全部删除.</li>
<li>闭包会在函数外部, 改变父函数内部变量的值, 注意不要随便改变.</li>
</ol>
<p>思考题:</p>
<ol>
<li><code>this</code> 在函数中而不是方法中使用时, 指向全局对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line"></span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里直接在 vscode 中执行, 所以打出来是 undefined, 可能原本是 The Window</span></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this 打印出来如下</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Object [global] &#123;</span></span><br><span class="line"><span class="comment">  global: [Circular],</span></span><br><span class="line"><span class="comment">  clearInterval: [Function: clearInterval],</span></span><br><span class="line"><span class="comment">  clearTimeout: [Function: clearTimeout],</span></span><br><span class="line"><span class="comment">  setInterval: [Function: setInterval],</span></span><br><span class="line"><span class="comment">  setTimeout: [Function: setTimeout] &#123;</span></span><br><span class="line"><span class="comment">    [Symbol(nodejs.util.promisify.custom)]: [Function]</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  queueMicrotask: [Function: queueMicrotask],</span></span><br><span class="line"><span class="comment">  clearImmediate: [Function: clearImmediate],</span></span><br><span class="line"><span class="comment">  setImmediate: [Function: setImmediate] &#123;</span></span><br><span class="line"><span class="comment">    [Symbol(nodejs.util.promisify.custom)]: [Function]</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>这里 <code>that</code> 指向整个 object.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// My Object</span></span><br></pre></td></tr></table></figure>



<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>对应于传递给函数的参数的类数组对象, 是所有非箭头函数中可用的局部变量, 可以使用它来引用函数的参数.</p>
<ol>
<li>arguments参数可以被设置</li>
<li>不是一个Array, 只是类似, 类型是 object</li>
<li>只有length和索引元素功能</li>
<li>可以被转换为真正的数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">// 2</span></span><br><span class="line">  <span class="comment">// 参数被设置</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">4</span>][<span class="number">0</span>] = <span class="string">'Mary'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">4</span>]); <span class="comment">// 3 [ 'Mary', 'hi', 'go' ]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments转换为数组</span></span><br><span class="line">  <span class="keyword">let</span> args0 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> args1 = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 - 更多信息)</span></span><br><span class="line">  <span class="comment">// 注重性能 使用被忽视的Array构造函数作为一个函数</span></span><br><span class="line">  <span class="keyword">let</span> args = (<span class="built_in">arguments</span>.length === <span class="number">1</span> ? [<span class="built_in">arguments</span>[<span class="number">0</span>]] : <span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ES6'</span>, args0, args1, <span class="string">'遍历对象构造数组'</span>, args);</span><br><span class="line">  <span class="comment">// ES6 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] 遍历对象构造数组 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ES2015</span></span><br><span class="line">  <span class="keyword">let</span> args3 = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> args4 = [...arguments];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ES5'</span>, args3, args4);</span><br><span class="line">  <span class="comment">// ES5 [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ] [ 1, 3, 3, 4, [ 'Mary', 'hi', 'go' ] ]</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">arguments</span>); <span class="comment">// object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'hello'</span>, <span class="string">'hi'</span>, <span class="string">'go'</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h4><p>计算某个<strong>原始字符串</strong>(不是String对象), 并执行其中的JS代码, 并返回结果(如果不存在, 则返回undefined). 是全局对象的一个函数属性.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">eval</span>(<span class="string">'x+2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res, <span class="built_in">eval</span>(<span class="string">'4+8'</span>)); <span class="comment">// 10 12</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'let a = 10, b = 9; console.log(a*b)'</span>); <span class="comment">// 90</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>()); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 不是字符串的话, 原封不动返回</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="number">67</span>)); <span class="comment">// 67</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="number">777</span>))); <span class="comment">// [String: '777']</span></span><br></pre></td></tr></table></figure>



<h2 id="操作符-typeof"><a href="#操作符-typeof" class="headerlink" title="操作符 typeof"></a>操作符 typeof</h2><h3 id="判断变量数据类型"><a href="#判断变量数据类型" class="headerlink" title="判断变量数据类型"></a>判断变量数据类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="comment">// 通用数据类型</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="string">'jinling'</span> + <span class="string">'\n'</span> +  <span class="comment">// string</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="number">23</span> + <span class="string">'\n'</span> + <span class="comment">// number</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="literal">true</span> + <span class="string">'\n'</span> +  <span class="comment">// boolean</span></span><br><span class="line">	<span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] + <span class="string">'\n'</span> + <span class="comment">// object</span></span><br><span class="line">	<span class="keyword">typeof</span> &#123;<span class="attr">k1</span>:<span class="string">'v1'</span>, <span class="attr">k2</span>:<span class="string">'v2'</span>&#125; + <span class="string">'\n'</span> <span class="comment">// object</span></span><br><span class="line">  <span class="comment">// 特殊字符类型</span></span><br><span class="line">  <span class="keyword">typeof</span> <span class="literal">null</span> + <span class="string">'\n'</span> + <span class="comment">// object</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="literal">undefined</span> + <span class="string">'\n'</span> + <span class="comment">// undefined</span></span><br><span class="line">	<span class="keyword">typeof</span> <span class="literal">NaN</span> + <span class="string">'\n'</span> <span class="comment">// number</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined与null值相同,但类型不同</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>===<span class="literal">null</span>, <span class="literal">undefined</span>==<span class="literal">null</span>); <span class="comment">// false true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数组可以用 Array.isArray</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(&#123;<span class="attr">k1</span>:<span class="string">'v1'</span>, <span class="attr">k2</span>:<span class="string">'v2'</span>&#125;)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>对于相同的输入, 永远有相同的输出. 没有可观察的副作用, 不依赖外部条件.</p>
<p>比如数组操作中, 对于给定的数组, slice就是纯的, splice就是不纯的.</p>
<p>纯函数可以有效降低系统复杂性, 还有很多其他的优秀特性, 例如可缓存性.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">var</span> sin = _.memorize(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Math</span>.sin(x));</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次计算的时候会稍慢一点</span></span><br><span class="line"><span class="keyword">var</span> a = sin(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次有了缓存，速度极快</span></span><br><span class="line"><span class="keyword">var</span> b = sin(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h2><p>curry: 传递给函数一部分的参数来调用它, 让他返回一个函数去处理剩下的参数.</p>
<p>就是传递一部分的参数, 形成固定模式的函数(部分参数数值已经固定), 得到已经记住参数的新函数. 这样对应固定的输入, 就得到固定的输出.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> check = <span class="function"><span class="params">x</span> =&gt;</span> (<span class="function"><span class="params">y</span> =&gt;</span> y &gt; x);</span><br><span class="line"><span class="keyword">let</span> check7 = check(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(check7(<span class="number">10</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>包菜式代码  <code>h(g(f(x)))</code> =&gt; 更优雅 函数组合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传的是g函数需要的参数</span></span><br><span class="line"><span class="comment">// 将任何两个纯函数结合在一起, 组合函数式的代码</span></span><br><span class="line"><span class="keyword">var</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> (<span class="function"><span class="params">x</span> =&gt;</span> f(g(x)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add1 = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> mul5 = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = compose(add1, mul5);</span><br><span class="line"><span class="built_in">console</span>.log(res(<span class="number">2</span>)); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> first = <span class="function"><span class="params">arr</span> =&gt;</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reverse();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> last = compose(first, reverse);</span><br><span class="line"><span class="built_in">console</span>.log(last([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="Point-Free"><a href="#Point-Free" class="headerlink" title="Point Free"></a>Point Free</h2><p>减少对不必要的中间变量的命名</p>
<h2 id="声明式与命令式代码"><a href="#声明式与命令式代码" class="headerlink" title="声明式与命令式代码"></a>声明式与命令式代码</h2><p>命令式: 写出一条一条指令让计算机执行, 一般会涉及到很多繁琐的细节.</p>
<p>声明式: 写表达式表明自己想做的事情, 而不是一步一步的指示. 隐藏细节.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; companies.length; i++)&#123;</span><br><span class="line">    CEOs.push(companies[i].CEO)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = companies.map(<span class="function"><span class="params">c</span> =&gt;</span> c.CEO);</span><br></pre></td></tr></table></figure>

<p>函数式编程一个优点就是声明式代码以及纯函数. 工作时Ï专注于业务代码, 优化时专注于函数内部.</p>
<h1 id="遍历器与-for…of"><a href="#遍历器与-for…of" class="headerlink" title="遍历器与 for…of"></a>遍历器与 for…of</h1><p>遍历器的概念</p>
<p>是用来处理可遍历数据结构的统一接口, 只要部署 iterator 接口, 就可以进行遍历操作.</p>
<p>作用: 提供统一的访问接口/数据结构的成员按照某种顺序排列/为ES6新增的<code>for...of</code>服务</p>
<p>数据结构有遍历器接口, 就称为该数据结构是可遍历的. JS中默认的遍历器接口, 即数据结构有 <code>Symbol.iterator</code> 属性, 该属性对应的函数返回一个对象, 调用对象的<code>next</code>方法, 即可返回数据结构的下一个数据..</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(it.next(), it.next(), it.next(), it.next());</span><br><span class="line"><span class="comment">// &#123; value: 3, done: false &#125; &#123; value: 4, done: false &#125; &#123; value: 5, done: false &#125; &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// done 表示是否遍历结束</span></span><br></pre></td></tr></table></figure>

<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li><p>Array</p>
</li>
<li><p>Map</p>
</li>
<li><p>Set</p>
</li>
<li><p>String</p>
</li>
<li><p>TypedArray</p>
</li>
<li><p>函数的 arguments 对象</p>
</li>
<li><p>NodeList 对象</p>
</li>
</ul>
<p>上述数据结构不用自己写遍历器函数, <code>for...of</code>循环会自动进行遍历.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr) <span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>没有遍历器函数的数据结构, 可以根据实际需求进行手动部署, 即在<code>Symbol.iterator</code>属性上手写遍历器对象生成函数.</p>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>针对数组或者对象进行模式匹配, 然后对其中的变量进行赋值. 解构目标 = 解构源.</p>
<h2 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套</span></span><br><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可忽略</span></span><br><span class="line"><span class="keyword">let</span> [a, , c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, c); <span class="comment">// 1 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余运算符</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1 [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>数组解构中, 若解构目标为可遍历对象(实现iterator接口的数据), 都可以进行解构赋值.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c, ...d] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d); <span class="comment">// h e l [ 'l', 'o' ]</span></span><br></pre></td></tr></table></figure>

<h3 id="解构默认值"><a href="#解构默认值" class="headerlink" title="解构默认值"></a>解构默认值</h3><p>解构匹配到<code>undefined</code>, 触发默认值作为返回结果.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 均匹配到 undefined</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = []; <span class="built_in">console</span>.log(a, b); <span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// b 匹配到 undefined, 触发默认值 b=a=1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>]; <span class="built_in">console</span>.log(a, b); <span class="comment">// 1 1</span></span><br><span class="line"><span class="comment">// 正常解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">9</span>]; <span class="built_in">console</span>.log(a, b); <span class="comment">// 1 9</span></span><br></pre></td></tr></table></figure>



<h2 id="对象的解构"><a href="#对象的解构" class="headerlink" title="对象的解构"></a>对象的解构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = &#123; <span class="attr">hello</span>: <span class="string">'aaa'</span>, <span class="attr">apple</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// undefined undefined</span></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: b &#125; = &#123; <span class="attr">hello</span>: <span class="string">'aaa'</span>, <span class="attr">apple</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> &#123; a &#125; = &#123; <span class="attr">hello</span>: <span class="string">'aaa'</span>, <span class="attr">apple</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正确使用 解构目标必须与key一致 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; hello, apple &#125; = &#123; <span class="attr">hello</span>: <span class="string">'aaa'</span>, <span class="attr">apple</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(hello, apple); <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">hello</span>: b &#125; = &#123; <span class="attr">hello</span>: <span class="string">'aaa'</span>, <span class="attr">apple</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// aaa</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; hello &#125; = &#123; <span class="attr">hello</span>: <span class="string">'aaa'</span>, <span class="attr">apple</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(hello); <span class="comment">// aaa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 剩余运算符 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; a, b, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest); <span class="comment">// 10 20 &#123; c: 30, d: 40 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解构默认值 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; hello = <span class="number">3</span>, apple = <span class="number">5</span> &#125; = &#123; <span class="attr">hello</span>: <span class="string">'aaa'</span>, <span class="attr">apple</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(hello, apple); <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apple 匹配到 undefined</span></span><br><span class="line"><span class="keyword">let</span> &#123; hello = <span class="number">3</span>, apple = <span class="number">5</span> &#125; = &#123; <span class="attr">hello</span>: <span class="string">'aaa'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(hello, apple); <span class="comment">// aaa 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">hello</span>: aa = <span class="number">3</span>, <span class="attr">apple</span>: bb = <span class="number">5</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(aa, bb); <span class="comment">// 3 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">hello</span>: aa = <span class="number">3</span>, <span class="attr">apple</span>: bb = <span class="number">5</span> &#125; = &#123; <span class="attr">apple</span>: <span class="string">'aaa'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(aa, bb); <span class="comment">// 3 aaa</span></span><br></pre></td></tr></table></figure>





<h1 id="关键字-this"><a href="#关键字-this" class="headerlink" title="关键字 this"></a>关键字 this</h1><p>js中<code>this</code>随着执行环境的变化而变化, 是函数运行时, 在函数体内部自动生成的一个对象, 只能在函数体内部使用. 即, <strong>this 是函数运行时所在的环境对象</strong>.</p>
<h2 id="单独使用"><a href="#单独使用" class="headerlink" title="单独使用"></a>单独使用</h2><p>无论有无严格模式, <code>this</code>始终指向全局对象. 浏览器中, 全局对象为<code>[object Window]</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 'use strict'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h2><p>函数中, 默认<code>this</code>指向全局对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"ok"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>严格模式下不允许默认绑定, 所以函数中的<code>this</code>为<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myFunction()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="函数作为对象方法"><a href="#函数作为对象方法" class="headerlink" title="函数作为对象方法"></a>函数作为对象方法</h2><p>指向上级对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	size : <span class="number">14</span>,</span><br><span class="line">	color: <span class="string">'red'</span>,</span><br><span class="line">	getColor: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'颜色是'</span> + <span class="keyword">this</span>.color</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该实例中, this指向getColor方法所在的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getColor) <span class="comment">// [Function: getColor]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getColor()) <span class="comment">// 颜色是red (加括号表示调用方法)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法中的this单独打印, 会打印出所属对象的内容</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName  : <span class="string">"John"</span>,</span><br><span class="line">  lastName   : <span class="string">"Doe"</span>,</span><br><span class="line">  id         : <span class="number">5566</span>,</span><br><span class="line">  myFunction : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.myFunction()); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  firstName: 'John',</span></span><br><span class="line"><span class="comment">  lastName: 'Doe',</span></span><br><span class="line"><span class="comment">  id: 5566,</span></span><br><span class="line"><span class="comment">  myFunction: [Function: myFunction]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="函数作为构造函数"><a href="#函数作为构造函数" class="headerlink" title="函数作为构造函数"></a>函数作为构造函数</h2><p>构造函数就是, 通过这个函数, 能够生成一个新对象. 此时, <code>this</code> 指向这个新对象.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> test();</span><br><span class="line"><span class="built_in">console</span>.log(obj.x); <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"ok"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> test();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ok 此时全局变量x的值没有变化, 说明 this 不是全局对象</span></span><br></pre></td></tr></table></figure>

<h2 id="apply调用"><a href="#apply调用" class="headerlink" title="apply调用"></a>apply调用</h2><p><code>apply()</code>是函数的一个方法, 作用是改变函数的调用对象. 第一个参数表示改变后的调用这个函数的对象, 此时 <code>this</code> 指向这个参数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">"ok"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.x = <span class="string">'hi'</span>;</span><br><span class="line">obj.method= test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为空时, 默认 obj.method 这个方法的调用者修改为 全局对象.</span></span><br><span class="line">obj.method.apply(); <span class="comment">// o.apply(); // ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 obj.method 这个方法的调用者为 obj, 则此时 obj.method 作为对象方法被调用</span></span><br><span class="line"><span class="comment">// this 指向 obj</span></span><br><span class="line">obj.method.apply(obj); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>



<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>ES6之前使用 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。</p>
<p>ES6 引入了模块化，在编译时就能确定模块的依赖关系 + 输入和输出的变量。</p>
<p>ES6 的模块化 = 导出（export） 与导入（import）两个模块。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>自动开启严格模式</p>
<p>模块中可以导入导出各种类型的变量, 如函数/对象/字符串/布尔值/类等.</p>
<p>每个模块都有自己的上下文, 模块内声明的变量都是局部变量.</p>
<p>每个模块只加载一次, 再去加载该模块, 则直接从内存中读取.</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 </p>
<p>export 命令可以出现在模块的任何位置，但必需处于模块顶层。</p>
<p>import 命令会提升到整个模块的头部，首先执行。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is"</span> + myName + <span class="string">"! I'm '"</span> + myAge + <span class="string">"years old."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">"yeah!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;</span><br><span class="line"><span class="comment">// 建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口</span></span><br><span class="line"><span class="comment">// 函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">"./test.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// My name is Tom! I'm 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(myAge);<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>

<h3 id="as-的用法"><a href="#as-的用法" class="headerlink" title="as 的用法"></a>as 的用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName <span class="keyword">as</span> exportName &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportName &#125; <span class="keyword">from</span> <span class="string">"./test.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exportName);<span class="comment">// Tom</span></span><br><span class="line"><span class="comment">// 使用 as 重新定义导出的接口名称，隐藏模块内部的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----export [test1.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----export [test2.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Jerry"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="comment">// 不同模块导出接口名称命名重复， 使用 as 重新定义变量名。</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">"./test1.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name2 &#125; <span class="keyword">from</span> <span class="string">"./test2.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2);<span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>

<h3 id="import-命令的特点"><a href="#import-命令的特点" class="headerlink" title="import 命令的特点"></a>import 命令的特点</h3><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="comment">// 相当于 import &#123; a &#125; "./xxx.js"; 只执行一次</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; b &#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="comment">// 相当于 import &#123; a, b &#125; from "./xxx.js"; 只执行一次</span></span><br></pre></td></tr></table></figure>

<h4 id="静态执行特性"><a href="#静态执行特性" class="headerlink" title="静态执行特性"></a>静态执行特性</h4><p><code>import</code> 静态执行, 不能使用表达式和变量.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="string">"f"</span> + <span class="string">"oo"</span> &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">// 表达式 error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">"methods"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"><span class="comment">// 变量 error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">"method1"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">"method2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><p>在一个文件或者模块中, export/import可以有多个, export default 仅有一个。</p>
<p>导出时不需要加{}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"My name is Tom!"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 仅有一个 不需要加&#123;&#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> c = <span class="string">"error"</span>; </span><br><span class="line"><span class="comment">// error，default 已经是对应的导出变量，不能跟着变量声明语句</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">"./xxx.js"</span>; <span class="comment">// 不需要加&#123;&#125;， 使用任意变量接收</span></span><br></pre></td></tr></table></figure>



<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol>
<li><p>避免使用 全局变量 <code>new</code> <code>===</code> <code>eval()</code></p>
</li>
<li><p>所有声明放在脚本或者函数的顶部, <strong>顶部声明, 稍后使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在顶部声明</span></span><br><span class="line"><span class="keyword">var</span> firstName, lastName, price, discount, fullPrice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍后使用</span></span><br><span class="line">firstName = <span class="string">"Bill"</span>;</span><br><span class="line">lastName = <span class="string">"Gates"</span>;</span><br><span class="line"></span><br><span class="line">price = <span class="number">19.90</span>;</span><br><span class="line">discount = <span class="number">0.10</span>;</span><br><span class="line"></span><br><span class="line">fullPrice = price * <span class="number">100</span> / discount;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明变量时同时初始化</p>
</li>
<li><p>将数值/字符串/布尔值声明为原始值而非对象, 否则会拖慢速度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">'bill'</span> <span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'bill'</span>) <span class="comment">// 对象</span></span><br><span class="line"><span class="built_in">console</span>.log(x===y); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请勿使用 new Object()</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">推荐使用</th>
<th align="center">不建议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{}</td>
<td align="center">new Object()</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">new Array()</td>
</tr>
<tr>
<td align="center">function (){}</td>
<td align="center">new Function()</td>
</tr>
<tr>
<td align="center">“”</td>
<td align="center">new String()</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">new Number()</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">new Boolean()</td>
</tr>
<tr>
<td align="center">/()/</td>
<td align="center">new RegExp()</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>意识到自动类型转换, 变量可以通过赋值改变其数据类型, 变量可包含不同的数据类型.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'hello'</span></span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为函数中的参数设置默认值, <code>undefined</code> 会破坏代码</p>
</li>
<li><p>用<code>default</code>来结束<code>switch</code>.</p>
</li>
</ol>
<h1 id="缺陷与错误"><a href="#缺陷与错误" class="headerlink" title="缺陷与错误"></a>缺陷与错误</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><blockquote>
<p>原因</p>
</blockquote>
<p>js代码中会出现错误, 由于编写代码/编译/用户输入等各种各样的原因.</p>
<blockquote>
<p>处理</p>
</blockquote>
<p>发生错误时, js引擎会停止并生成一个错误消息.</p>
<p>try与catch成对出现, finally是最后一定会执行的语句(可以没有).</p>
<p>throw抛出错误, 实际上就是抛出一个表示错误信息的字符串s, 因此可以自定义错误.</p>
<p>在catch中可以捕获s,实际上就是可以获得s的值并打印出来.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="string">''</span>) <span class="keyword">throw</span> <span class="string">'is kong'</span></span><br><span class="line">    <span class="keyword">if</span> (x === <span class="string">'1'</span>) <span class="keyword">throw</span> <span class="string">'is 1'</span></span><br><span class="line">    <span class="keyword">if</span> (x === <span class="string">'2'</span>) <span class="keyword">throw</span> <span class="string">'is 2'</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'1'</span>); <span class="comment">// is 1</span></span><br><span class="line">test(<span class="string">''</span>); <span class="comment">// is kong</span></span><br></pre></td></tr></table></figure>



<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><blockquote>
<p>操作</p>
</blockquote>
<p>设置断点, 检查变量值, 浏览器内置调试器(按下F12, 选择<code>console</code>)</p>
<blockquote>
<p><code>debugger</code>关键字</p>
</blockquote>
<p>代码会在<code>debugger</code>行停下, 并执行调试函数. 没有调试函数则不起作用.</p>
<p>与在调试工具中设置断点效果一样.</p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><blockquote>
<p>原因</p>
</blockquote>
<p><code>use strict</code> </p>
<p>消除js语法的不合理之处, 保证代码安全; 增加编译效率;</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>只能放在脚本或者函数的开头</p>
<blockquote>
<p>具体内容</p>
</blockquote>
<ul>
<li>禁止使用未定义/声明的变量</li>
<li>禁止删除变量/函数</li>
<li>禁止变量重名</li>
<li>禁止使用八进制/转义字符</li>
<li>禁止对只读属性赋值</li>
<li>禁止删除不能删除的属性, 比如prototype</li>
<li>禁止变量名为eval/arguments</li>
<li>禁止使用右侧类似语句 with (Math){x = cos(2)};</li>
<li>禁止在作用域eval创建的变量被使用</li>
<li>禁止this指向全局对象</li>
</ul>
]]></content>
      <tags>
        <tag>-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Greedy Algorithm</title>
    <url>/2020/08/03/Greedy-Algorithm/</url>
    <content><![CDATA[<h4 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="[45] Jump Game II"></a>[45] Jump Game II</h4><blockquote>
<p> Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p> Each element in the array represents your maximum jump length at that position.</p>
<p> Your goal is to reach the last index in the minimum number of jumps.</p>
</blockquote>
<p>贪心算法, 局部解得到最优解.</p>
<p>解题思路: 每次查找当前位置能够到达的位置中, 能跳到最远位置的位置A, 下次就跳到位置A, 然后再从位置A能到达的位置中, 再找能跳到最远位置的位置, 如此循环.</p>
<p>但是官方解答虽然简洁, 但是我不是看的很明白, 还是暂时先贴自己的直白解法吧.</p>
<img src="/2020/08/03/Greedy-Algorithm/45_fig1.png" class="" title="45_fig1">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于当前index, 每次在能跳到的范围内</span></span><br><span class="line"><span class="comment">// 跳到能跳到更远地方的index</span></span><br><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt;= len - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> nextPosMap = &#123; <span class="string">'index'</span>: <span class="number">0</span>, <span class="string">'maxIndex'</span>: <span class="number">0</span> + nums[<span class="number">0</span>] &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len;) &#123;</span><br><span class="line">    <span class="keyword">let</span> indexLimit = i + nums[i];</span><br><span class="line">    <span class="comment">// 在寻找下一步跳的位置时, 步数加一</span></span><br><span class="line">    step++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= indexLimit &amp;&amp; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j + nums[j] &gt; nextPosMap.maxIndex) &#123;</span><br><span class="line">        nextPosMap.index = j;</span><br><span class="line">        nextPosMap.maxIndex = j + nums[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index != i, 说明能跳到更远距离的index更新了, 这时才需要将当前节点 i 移到index</span></span><br><span class="line">    <span class="comment">// 其实肯定更新, 题目已经说了能跳到最后</span></span><br><span class="line">    <span class="comment">// 移动才算跳了一步</span></span><br><span class="line">    <span class="comment">// 同时能跳到的最远位置不要超过数组边界</span></span><br><span class="line">    <span class="comment">// 超过数组边界则表示步数已经能计算出来了 return</span></span><br><span class="line">    <span class="keyword">if</span> (nextPosMap.maxIndex &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">      i = nextPosMap.index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当最大位置能到达最后时, 返回step+1</span></span><br><span class="line">      <span class="comment">// 把跳到最后位置的一步也加上</span></span><br><span class="line">      <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="[55] Jump Game"></a>[55] Jump Game</h4><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
</blockquote>
<p>一开始尝试使用递归做法, 计算所有的可能性, 但是想也不是最好的解法, 最后很可能超时, 果不其然超时.</p>
<p>于是就去看网上解法, 这里的考点是<strong>贪心算法</strong>.</p>
<blockquote>
<p>贪心算法（又称贪婪算法）是指，在对<a href="https://baike.baidu.com/item/问题求解/6693186" target="_blank" rel="noopener">问题求解</a>时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解</p>
</blockquote>
<p>该题的大概思路是:</p>
<p>数组的第一个元素的值为 reach, 从数组的第一个元素开始, 每次计算在reach范围内的元素们所能到达的最远距离, 是否超过reach, 如果超过了, 就更新reach值为较大值. 直至reach的值超过lastIndex 返回 true.</p>
<img src="/2020/08/03/Greedy-Algorithm/largen-reach.png" class="" title="largen-reach">

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 递归超时 使用贪心算法求解</span></span><br><span class="line"><span class="comment">// 局部能够到达的最大范围, 也是全局能够到达的最大范围</span></span><br><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reach = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 需要注意的点是,这里reach的值不一定就&gt;1, 所以i不一定就从1开始</span></span><br><span class="line">  <span class="comment">// 还是从0开始能够包含所有情况, 这么写因为有个特例 [0]</span></span><br><span class="line">  <span class="comment">// 同时注意限制 i 的范围, i 是指 reach 能够到达的位置范围, 不能超过 reach</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length &amp;&amp; i &lt;= reach; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + i &gt; reach) &#123;</span><br><span class="line">      reach = nums[i] + i;</span><br><span class="line">      <span class="comment">// console.log(reach);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当能到达的范围超过数组的最后 index 时, 返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (reach &gt;= nums.length - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 能到达的元素位置都尝试了, 但是没有一个位置可以到达最后一个元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic-Programming</title>
    <url>/2020/08/04/Dynamic-Programming/</url>
    <content><![CDATA[<h4 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="[62] Unique Paths"></a>[62] Unique Paths</h4><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
</blockquote>
<h5 id="Solution-1-排列组合"><a href="#Solution-1-排列组合" class="headerlink" title="Solution 1: 排列组合"></a>Solution 1: 排列组合</h5><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p>
<p>比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。</p>
<p>所以结果= (m+n−2)!/((m−1)!*(n-1)!).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1 : 排列组合</span></span><br><span class="line"><span class="comment">// 使用数学上的排列组合计算公式</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths1 = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 起点到终点一共需要走 m-1+n-1 = m+n-2 步</span></span><br><span class="line">  <span class="comment">// 其中从总步数中选出向右的 m-1 步</span></span><br><span class="line">  <span class="keyword">return</span> jc(m + n - <span class="number">2</span>) / (jc(m - <span class="number">1</span>) * jc(n - <span class="number">1</span>))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jc = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    res = res * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Solution-2-动态规划"><a href="#Solution-2-动态规划" class="headerlink" title="Solution 2: 动态规划"></a>Solution 2: 动态规划</h5><p>关键在于写出状态转移方程.很多解法用的是数组,我这里用的是对象存储.</p>
<p>数组的空间O(mn)可优化为O(n).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 2 : 动态规划</span></span><br><span class="line"><span class="comment">// 假设到点(i,j)的所有路径数表示为 dp(i,j)</span></span><br><span class="line"><span class="comment">// 状态转移方程</span></span><br><span class="line"><span class="comment">// dp(i,j) = dp(i-1,j) + dp(i,j-1)</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths2 = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 只能向右或向下</span></span><br><span class="line">  <span class="comment">// 所以到达边界的点的方法数=1</span></span><br><span class="line">  dp[key(<span class="number">0</span>, <span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dp[key(i, <span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    dp[key(<span class="number">0</span>, j)] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 时间复杂度O(mn)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      dp[key(i, j)] = dp[key(i - <span class="number">1</span>, j)] + dp[key(i, j - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[key(m - <span class="number">1</span>, n - <span class="number">1</span>)]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key = <span class="function">(<span class="params">i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="string">'/'</span> + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="[63] Unique Paths II"></a>[63] Unique Paths II</h4><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
</blockquote>
<p>这里需要修改状态转移方程, 就是, 在计算某一点可到达的路径数时, 如果这一点有障碍, 则为0, 否则按照原来的等式计算.</p>
<p>在初始化到达边缘点的路径数时, 也要考虑障碍的情况.</p>
<p>感觉动态规划主要有两个过程, 重点还是<strong>分析清楚过程</strong>:</p>
<ol>
<li><strong>初始化数据</strong></li>
<li><strong>正确的动态规划方程</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span> (<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rowNum = obstacleGrid.length;</span><br><span class="line">  <span class="keyword">let</span> colNum = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">let</span> dp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> flag1 = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 考虑障碍的情况</span></span><br><span class="line">    <span class="comment">// 边缘一有障碍, 则后面所有点的可到达路径数均为0</span></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> t = i; t &lt; rowNum; t++) &#123;</span><br><span class="line">        dp[key(t, <span class="number">0</span>)] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flag1 = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[key(i, <span class="number">0</span>)] = (flag1 == <span class="literal">true</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> flag2 = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> t = j; t &lt; colNum; t++) &#123;</span><br><span class="line">        dp[key(<span class="number">0</span>, t)] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flag2 = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[key(<span class="number">0</span>, j)] = (flag2 == <span class="literal">true</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">      <span class="comment">// 考虑障碍的动态规划方程</span></span><br><span class="line">      <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">        dp[key(i, j)] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        dp[key(i, j)] = dp[key(i - <span class="number">1</span>, j)] + dp[key(i, j - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(dp[key(rowNum - 1, colNum - 1)]);</span></span><br><span class="line">  <span class="keyword">return</span> dp[key(rowNum - <span class="number">1</span>, colNum - <span class="number">1</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key = <span class="function">(<span class="params">i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="string">'/'</span> + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="[300] Longest Increasing Subsequence"></a>[300] Longest Increasing Subsequence</h4><blockquote>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
</blockquote>
<p><strong>动态规划</strong></p>
<p>时间复杂度:</p>
<p>遍历数组, 遍历到每个元素时, 再次遍历该元素之前的所有元素. $O(N^2)$.</p>
<p>空间复杂度:</p>
<p>使用额外数组保存每个元素的最长子串的长度. $O(N)$ .</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1: 使用动态规划 时间复杂度 O(N^2)</span></span><br><span class="line"><span class="comment">// 后一个元素的递增子串长度最大值依赖于前面每个元素的递增子串长度最大值</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="comment">// 不存在递增的子串</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// 初始化数组 保存到达每个位置的所有递增子串长度的最大值(以每个位置为终点)</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  dp.fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="number">1</span>, val = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 计算每一个位置的最长子串长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 计算过程中, 每次查找i之前的元素, 看有无比nums[i]还小的</span></span><br><span class="line">    <span class="comment">// 小的话就是dp[j]+1</span></span><br><span class="line">    <span class="comment">// 但是还要将 dp[i] 与 dp[j]+1 进行比较, 保留较大值</span></span><br><span class="line">    <span class="comment">// 则最后dp[i]是所有递增子串中最长子串的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">        val = dp[j] + <span class="number">1</span>;</span><br><span class="line">        dp[i] = val &gt; dp[i] ? val : dp[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保留dp[i]中的最大值</span></span><br><span class="line">    maxLen = maxLen &gt; dp[i] ? maxLen : dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回的是 最长的递增子串的长度</span></span><br><span class="line">  <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="[70] Climbing Stairs"></a>[70] Climbing Stairs</h4><blockquote>
<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
</blockquote>
<p><strong>时间复杂度</strong>:</p>
<p>计算每一层的方法数, $O(N)$</p>
<p><strong>空间复杂度</strong>:</p>
<p>使用数组保存到达每一层的方法数, $O(N)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 楼梯一共有n层</span></span><br><span class="line"><span class="comment">// 需要返回达到n层总共的路径数</span></span><br><span class="line"><span class="comment">// 到达每一层都有两种方式, 要不跨一步, 要不跨两步</span></span><br><span class="line"><span class="comment">// 假设到达i层的方法数为dp[i], 则dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> way = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  way.fill(<span class="number">0</span>);</span><br><span class="line">  way[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  way[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    way[i] = way[i - <span class="number">1</span>] + way[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> way[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Linked-list</title>
    <url>/2020/09/11/Linked-list/</url>
    <content><![CDATA[<h4 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="[2] Add Two Numbers"></a>[2] Add Two Numbers</h4><blockquote>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
</blockquote>
<p>复杂的数据结构是我的超级短板. 但是也算勉强看懂了js是如何表示链表的.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 这个链表的存储结构是嵌套的, 即next指向的是嵌套的.</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义存储想关节点的变量</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> lastNode = result;</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">  <span class="keyword">let</span> val = <span class="number">0</span>; <span class="comment">// 相加之后赋给当前位置的值</span></span><br><span class="line">  <span class="comment">// 当l1或者l2任何一方有值时, 都需要进行相加</span></span><br><span class="line">  <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">    <span class="comment">// 获取两个链表的初始值</span></span><br><span class="line">    <span class="keyword">let</span> x = l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">    <span class="keyword">let</span> y = l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">    <span class="comment">// 两者相加</span></span><br><span class="line">    <span class="keyword">let</span> num = x + y + carry;</span><br><span class="line">    carry = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>); <span class="comment">// 商</span></span><br><span class="line">    val = num % <span class="number">10</span>; <span class="comment">// 相加之后赋给当前位置的值</span></span><br><span class="line">    <span class="comment">// 新建节点添加到链表末尾</span></span><br><span class="line">    lastNode.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    <span class="comment">// 最后节点位置更新</span></span><br><span class="line">    lastNode = lastNode.next;</span><br><span class="line">    <span class="comment">// 进行下一位置的加法</span></span><br><span class="line">    <span class="keyword">if</span> (l1 !== <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">    <span class="keyword">if</span> (l2 !== <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当两个加数位数都加完了</span></span><br><span class="line">  <span class="comment">// 但是仍然可能会有进位的可能</span></span><br><span class="line">  <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">    lastNode.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">示例结果</span></span><br><span class="line"><span class="comment">====result.next</span></span><br><span class="line"><span class="comment">ListNode &#123;</span></span><br><span class="line"><span class="comment">  val: 7,</span></span><br><span class="line"><span class="comment">  next: ListNode &#123;</span></span><br><span class="line"><span class="comment">    val: 0,</span></span><br><span class="line"><span class="comment">    next: ListNode &#123;</span></span><br><span class="line"><span class="comment">      val: 8,</span></span><br><span class="line"><span class="comment">      next: null</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="[21] Merge Two Sorted Lists"></a>[21] Merge Two Sorted Lists</h4><blockquote>
<p>Merge two sorted linked lists and return it as a new <strong>sorted</strong> list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<p>解题的重点在于, 一直将l1和l2的链表头作比较, 不断将较小的node加入结果链表, 直至l1或者l2为空, 说明遍历结束. 把不为空的链表剩余的部分直接接入结果列表.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理有链表为空的情况</span></span><br><span class="line">  <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> curr = res;</span><br><span class="line">  <span class="comment">// 网上的做法好简洁</span></span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">      curr.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curr.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  curr.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="[24] Swap Nodes in Pairs"></a>[24] Swap Nodes in Pairs</h4><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
</blockquote>
<p>在交换链表的时候, 第一次交换需要记住链表头.</p>
<p>确定 <code>curr</code> 之后, 只有 <code>curr.next!=null</code> 时才有交换的必要, 否则说明交换到头了, 返回 <code>head</code> 即可.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 第一次交换的时候 需要记住链表头 后面就不需要了</span></span><br><span class="line">  <span class="comment">// 只有当 curr.next 也有值的时候, 才交换</span></span><br><span class="line">  <span class="comment">// 否则就直接返回</span></span><br><span class="line">  <span class="keyword">while</span> (curr &amp;&amp; curr.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = curr.next.next;</span><br><span class="line">    <span class="keyword">let</span> nextNode = curr.next;</span><br><span class="line">    nextNode.next = curr;</span><br><span class="line">    left.next = nextNode;</span><br><span class="line">    curr.next = temp;</span><br><span class="line">    left = curr;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">      head = nextNode;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="[61] Rotate List"></a>[61] Rotate List</h4><blockquote>
<p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> * 大体思路是: </span></span><br><span class="line"><span class="comment"> * 先计算出链表的长度len, 再将k与len进行比较, </span></span><br><span class="line"><span class="comment"> * k&gt;len的话, 将k中len的整数倍减去之后, 就是最后需要移动的元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rotateRight = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算链表长度</span></span><br><span class="line">  <span class="comment">// 此时right指向最后一个元素</span></span><br><span class="line">  <span class="keyword">let</span> left = head, right = head, len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (right.next) &#123;</span><br><span class="line">    right = right.next;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span> || k == len) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取余之后是实际上需要移动的元素</span></span><br><span class="line">  <span class="keyword">let</span> num = k % len;</span><br><span class="line">  <span class="comment">// 由于在计算链表长度的时候, right已经指向链表尾部</span></span><br><span class="line">  <span class="comment">// 左右指针间隔k-1个元素</span></span><br><span class="line">  <span class="comment">// 所以左指针需要向右移动len-num-1个位置</span></span><br><span class="line">  <span class="comment">// 具体的边界条件可以在测试中验证是否正确</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - num - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    left = left.next;</span><br><span class="line">  &#125;</span><br><span class="line">  right.next = head;</span><br><span class="line">  head = left.next;</span><br><span class="line">  left.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="[23] Merge k Sorted Lists"></a>[23] Merge k Sorted Lists</h4><blockquote>
<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>
<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>
</blockquote>
<p><strong>solution1</strong> 的时间复杂度分析:</p>
<p>时间复杂度: 遍历链表+排序+遍历数组<br>    假设总node数为 $N$ , 则总时间复杂度为 $O(N)+O(NlogN)+O(N)=O(N)$<br>空间复杂度为: $O(N)$ , 主要是存储节点的数组的消耗</p>
<p><strong>solution2</strong> 的时间复杂度分析:</p>
<p>设k=lists.length, $N$ 为所有节点数, 则复杂度为=归并次数*每一次归并的时间复杂度<br>每一次归并需要遍历所有的节点, 但是不需要排序, 仅仅是大小比较, $O(N)$<br>设一共归并的次数为x, 则有 $2^x = k$ , 则 $ x = \log_2 k$ (以2为底k的对数)<br>所以总共的时间复杂度是 $\sum_0^x * O(N)=O(N\log k)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="comment">// 把链表中的节点值都拿出来放在一个数组里</span></span><br><span class="line"><span class="comment">// 然后对数组进行排序</span></span><br><span class="line"><span class="keyword">var</span> mergeKLists1 = <span class="function"><span class="keyword">function</span> (<span class="params">lists</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> len = lists.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> arr = [], l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    l = lists[i];</span><br><span class="line">    <span class="keyword">while</span> (l) &#123;</span><br><span class="line">      arr.push(l.val);</span><br><span class="line">      l = l.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 正序排列</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> curr = res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    curr.next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution 2</span></span><br><span class="line"><span class="comment">// 分治算法 这是一开始就想到的方法 但是不会实现🤦‍♀️</span></span><br><span class="line"><span class="comment">// 两两链表合并排序, 再将结果再合并, 直至只有一个结果</span></span><br><span class="line"><span class="comment">// 数组长度为奇数, 最后一次合并时, 是第一个与最后一个元素合并, interval*2之后会&lt;len, 继续进行最后一次合并</span></span><br><span class="line"><span class="comment">// 数组长度为奇数, 最后一次合并时, 是第一个与中间元素合并, interval*2之后会=len, 跳出循环</span></span><br><span class="line"><span class="keyword">var</span> mergeKLists = <span class="function"><span class="keyword">function</span> (<span class="params">lists</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = lists.length;</span><br><span class="line">  <span class="comment">// 没有链表返回空链表</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> interval = <span class="number">1</span>;<span class="comment">// 标志需要合并的两个链表之间的距离</span></span><br><span class="line">  <span class="comment">// 归并排序的代码更像模板</span></span><br><span class="line">  <span class="comment">// 只要两个元素之间的距离没有超过数组长度, 说明没有归并完毕</span></span><br><span class="line">  <span class="keyword">while</span> (interval &lt; len) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - interval; i = i + interval * <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// i的作用是, 找到所有需要合并的链表中的第一个</span></span><br><span class="line">      <span class="comment">// 不断地把相隔interval距离的两个链表合并</span></span><br><span class="line">      lists[i] = mergeTwoLists(lists[i], lists[i + interval])</span><br><span class="line">    &#125;</span><br><span class="line">    interval = interval * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个链表</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function">(<span class="params">l1, l2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> curr = res;</span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">      curr.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curr.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  curr.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="[25] Reverse Nodes in k-Group"></a>[25] Reverse Nodes in k-Group</h4><blockquote>
<p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
</blockquote>
<p>时间复杂度分析:</p>
<p>$O(N)$ , $N$为链表总节点数, 翻转时需要遍历所有的节点. 一共会进行$\lfloor N/k \rfloor$ 次翻转, 每一次翻转需要$O(k)$的时间.</p>
<p>空间复杂度: 常量级别.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大体思路是 每k个元素进行一次翻转</span></span><br><span class="line"><span class="comment">// 在翻转之前查看接下来的链表长度是否足够</span></span><br><span class="line"><span class="comment">// 足够则翻转 不够则停下并返回结果</span></span><br><span class="line"><span class="comment">// 翻转时注意连接前后链表的部分</span></span><br><span class="line"><span class="keyword">var</span> reverseKGroup = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在链表头节点前加一个节点</span></span><br><span class="line">  <span class="comment">// 后面翻转后的链表再与原来的链表连接要用到</span></span><br><span class="line">  <span class="keyword">let</span> hair = <span class="keyword">new</span> ListNode(<span class="literal">null</span>, head);</span><br><span class="line">  <span class="keyword">let</span> pre = hair;</span><br><span class="line">  <span class="comment">// tail需要以pre为起点, 向后移动k个位置</span></span><br><span class="line">  <span class="keyword">let</span> tail = hair, right;</span><br><span class="line">  <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">    <span class="comment">// 将 tail 移动至需要翻转的链表部分的末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      tail = tail.next;</span><br><span class="line">      <span class="comment">// 如果 tail 在向后移动但是还没有到目标位置时</span></span><br><span class="line">      <span class="comment">// 出现 tail 为 null 的情况</span></span><br><span class="line">      <span class="comment">// 说明剩余的元素已经不够翻转的数量</span></span><br><span class="line">      <span class="comment">// 直接返回现有结果即可</span></span><br><span class="line">      <span class="keyword">if</span> (!tail) <span class="keyword">return</span> hair.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// head-tail的链表部分需要翻转</span></span><br><span class="line">    <span class="comment">// 且翻转需要head和tail仍指向翻转后链表的头和尾</span></span><br><span class="line">    <span class="comment">// 保留tail的后面部分</span></span><br><span class="line">    right = tail.next;</span><br><span class="line">    [head, tail] = reverse(head, tail);</span><br><span class="line">    <span class="comment">// 进行与原链表的拼接</span></span><br><span class="line">    pre.next = head;</span><br><span class="line">    tail.next = right;</span><br><span class="line">    <span class="comment">// 改变pre head的位置</span></span><br><span class="line">    pre = tail;</span><br><span class="line">    head = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="comment">// 这里不用再初始化res来存储翻转后的结果</span></span><br><span class="line"><span class="comment">// 因为tail.next是存在的</span></span><br><span class="line"><span class="comment">// 可以看做已有的res使用</span></span><br><span class="line"><span class="comment">// 使用常数级的内存空间</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function">(<span class="params">head, tail</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = head;</span><br><span class="line">  <span class="keyword">let</span> remain = tail.next; <span class="comment">// 表示剩余不用翻转的部分</span></span><br><span class="line">  <span class="keyword">let</span> nex;</span><br><span class="line">  <span class="keyword">while</span> (p !== tail) &#123;</span><br><span class="line">    nex = p.next;</span><br><span class="line">    p.next = remain;</span><br><span class="line">    remain = p;</span><br><span class="line">    p = nex;</span><br><span class="line">  &#125;</span><br><span class="line">  tail.next = remain;</span><br><span class="line">  <span class="keyword">return</span> [tail, head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="[83] Remove Duplicates from Sorted List"></a>[83] Remove Duplicates from Sorted List</h4><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
</blockquote>
<p>思路比较简单, 由于最坏情况是遍历链表的所有节点(当所有节点的值均不相同),  时间复杂度为 $O(N)$ .</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于是排过序的链表</span></span><br><span class="line"><span class="comment">// 所以重复元素都会在一块</span></span><br><span class="line"><span class="comment">// 不断比较curr与curr.next的val是否相等</span></span><br><span class="line"><span class="comment">// 相等则跳过该重复元素,不等才改变curr的位置</span></span><br><span class="line"><span class="comment">// 直至curr遍历完链表的所有元素</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="comment">// 最后一个元素是不同元素 到达链表末尾</span></span><br><span class="line">    <span class="keyword">if</span> (!curr.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">while</span> (curr.val == curr.next.val) &#123;</span><br><span class="line">      curr.next = curr.next.next;</span><br><span class="line">      <span class="comment">// 最后一个元素是相同元素 到达链表末尾</span></span><br><span class="line">      <span class="keyword">if</span> (!curr.next) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="[82] Remove Duplicates from Sorted List II"></a>[82] Remove Duplicates from Sorted List II</h4><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p>Return the linked list sorted as well.</p>
</blockquote>
<p>遍历链表的所有节点两次,  时间复杂度为 $2*O(N) = O(N)$ .</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历两次链表</span></span><br><span class="line"><span class="comment">// 第一次按照顺序将所有不同的元素组成链表, 并给有重复元素的节点增加dup属性</span></span><br><span class="line"><span class="comment">// 第二次将有dup属性的节点删除, 返回结果</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!curr.next) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr.val == curr.next.val) &#123;</span><br><span class="line">      curr.dup = <span class="literal">true</span>;</span><br><span class="line">      curr.next = curr.next.next;</span><br><span class="line">      <span class="keyword">if</span> (!curr.next) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hair = <span class="keyword">new</span> ListNode(<span class="literal">null</span>, head);</span><br><span class="line">  <span class="keyword">let</span> pre = hair, point = head;</span><br><span class="line">  <span class="keyword">while</span> (point) &#123;</span><br><span class="line">    <span class="keyword">while</span> (point.dup) &#123;</span><br><span class="line">      point = point.next;</span><br><span class="line">      <span class="keyword">if</span> (!point) &#123;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> hair.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = point;</span><br><span class="line">    pre = point;</span><br><span class="line">    point = point.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="[142] Linked List Cycle II"></a>[142] Linked List Cycle II</h4><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>
<p><strong>Notice</strong> that you <strong>should not modify</strong> the linked list.</p>
</blockquote>
<p>这里需要证明下有环情况下, 为什么快慢指针第一次相遇之后, 快指针到链表头, 再和慢指针一起以每次一步的速度前进, 当二者相等时, 即是环的起点.</p>
<p><strong>证明</strong>:</p>
<img src="/2020/09/11/Linked-list/image.png" class="" title="image.png">

<p>我们最终需要证明a=b. 假设链表总长度为L, 环的长度为R, 快慢指针第一次相遇的节点为M, 环的开始节点为C, 其中各个点之间的距离分别为 H-&gt;C=a, C-&gt;M=c, M-&gt;C=b, H-&gt;M=s. 第一次相遇时, 假设fast已经围绕着环走了n圈, 则有:</p>
<p>由于快慢指针的速度差两倍, 所以相同时间内, 快指针走过的距离是慢指针的两倍.</p>
<p>$2s = s + nR \-&gt; s = nR \tag{1}$</p>
<p>已知慢指针走的长度为(套用$(1)$):</p>
<p>$a+c = s \-&gt; a+c=nR \-&gt; a + c = (n-1)R + R \-&gt; a = (n-1)R + (R - c) \-&gt;  a = (n-1)R +b$</p>
<p>则得出结论 $a=b$, (这个还要再想下).</p>
<p>所以fast移动到head, slow位置不变, 两个同时开始走, 每次走一步, 当走了a步时,两者相遇的点即为环的起点.</p>
<p><strong>时间复杂度</strong>:</p>
<p>可知快慢指针走的步数是一样的, 只是一个快一个慢, 慢指针最后遍历了整个链表, 走了N步, 则快指针也走了N步, 则时间复杂度为: $2*O(N)= O(N)$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用快慢指针</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 快慢指针的起始点应该一样</span></span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">    <span class="comment">// 快指针的速度是慢指针的2倍</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    <span class="comment">// 在没有环的情况下</span></span><br><span class="line">    <span class="comment">// fast指针会最先到达链表尾部, 直接返回null;</span></span><br><span class="line">    <span class="comment">// fast指针最后的位置,要不倒数第一,要不倒数第二</span></span><br><span class="line">    <span class="comment">// 与链表长度的奇偶数以及每次走的步数有关</span></span><br><span class="line">    <span class="comment">// 这里fast指针是每次走两步</span></span><br><span class="line">    <span class="keyword">if</span> (!fast.next) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    <span class="keyword">if</span> (!fast) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 说明有环 两指针第一次相遇</span></span><br><span class="line">    <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">      <span class="comment">// 快指针移动至链表头</span></span><br><span class="line">      <span class="comment">// 慢指针停在原地</span></span><br><span class="line">      fast = head;</span><br><span class="line">      <span class="comment">// 二者均以每次一步的速度继续向前走, 直至再次相遇</span></span><br><span class="line">      <span class="comment">// 这里方法需要证明</span></span><br><span class="line">      <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回的是环的起始节点的指针</span></span><br><span class="line">      <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="[138] Copy List with Random Pointer"></a>[138] Copy List with Random Pointer</h4><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> of the list.</p>
<p>The Linked List is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>
<ul>
<li><code>val</code>: an integer representing <code>Node.val</code></li>
<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) where random pointer points to, or <code>null</code> if it does not point to any node.</li>
</ul>
</blockquote>
<p><strong>时间复杂度:</strong> 遍历两遍数组 $O(N)$.</p>
<p><strong>经验/收获</strong>: </p>
<ol>
<li>一开始我的问题在于试错, 都没有搞清楚<code>random_index</code>属性是否在题目给的链表结构中存在, 我还以为有<code>random_index</code>这个属性呢, 实际上没有.  <code>random</code>数据类型仍然是指针而非number.</li>
<li>搞清楚题目是深拷贝, 不能改变原有链表结构. <strong>需要重新生成新链表</strong>.</li>
<li>收获在于知道如何使用hashMap存储链表间的 links.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目要求是深拷贝</span></span><br><span class="line"><span class="comment">// 就是不改变原有的链表</span></span><br><span class="line"><span class="comment">// 第一遍是copy all nodes, 使用map存储</span></span><br><span class="line"><span class="comment">// 第二遍是copy links</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// copy nodes</span></span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// map的key可以是任何对象, 不限于字符串</span></span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    map.set(curr, <span class="keyword">new</span> Node(curr.val));</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// copy links</span></span><br><span class="line">  curr = head;</span><br><span class="line">  <span class="keyword">let</span> node = map.get(curr);</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    node.next = curr.next ? map.get(curr.next) : <span class="literal">null</span>;</span><br><span class="line">    node.random = curr.random ? map.get(curr.random) : <span class="literal">null</span>;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="[92] Reverse Linked List II"></a>[92] Reverse Linked List II</h4><blockquote>
<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
</blockquote>
<p><strong>时间复杂度分析</strong>:</p>
<p>假设链表总长度为$N$, 在定位m/n节点的过程中, 一共遍历链表一次, 每次遍历至第n个节点, 最差情况遍历到链表末尾.</p>
<p>翻转时一共需要翻转 $n-m+1$ 个节点, 需要的时间是 $ O(n-m+1)$ .</p>
<p>所以时间复杂度为 $O(N)$ </p>
<p><strong>注意</strong>:</p>
<p>初始化一个节点时, hair不是空, hair.val是空. 刚开始判断pre==null就写错了, 应该是pre.val是否null.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 特殊情况</span></span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (!head.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// 当链表长度足够翻转时, 在head前添加hair节点</span></span><br><span class="line">  <span class="comment">// 为了使用pre节点, pre是pm的前一个节点</span></span><br><span class="line">  <span class="keyword">let</span> hair = <span class="keyword">new</span> ListNode(<span class="literal">null</span>, head);</span><br><span class="line">  <span class="keyword">let</span> pre = hair, curr = head;</span><br><span class="line">  <span class="comment">// 定义变量 注意需要tail指针</span></span><br><span class="line">  <span class="keyword">let</span> pm, pn, tail;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定位m节点</span></span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">    pm = head; <span class="comment">// pm直接是头节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// m-1次循环到达pm节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// pre节点也需要同时向后移动</span></span><br><span class="line">      <span class="comment">// 保证在pm前一位</span></span><br><span class="line">      curr = curr.next;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pm = curr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定位n节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  pn = curr;</span><br><span class="line">  <span class="comment">// 翻转前保留尾部数据</span></span><br><span class="line">  tail = curr.next;</span><br><span class="line">  <span class="comment">// 翻转</span></span><br><span class="line">  <span class="keyword">while</span> (pm != pn) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = pm.next;</span><br><span class="line">    pm.next = tail;</span><br><span class="line">    tail = pm;</span><br><span class="line">    pm = temp;</span><br><span class="line">    pre.next = tail;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// pm==pn时还需要连接下tail</span></span><br><span class="line">  pm.next = tail;</span><br><span class="line">  <span class="comment">// 连接</span></span><br><span class="line">  pre.next = pm;</span><br><span class="line">  <span class="comment">// 这里返回hair.next即可</span></span><br><span class="line">  <span class="comment">// 不用分析pre是否为空</span></span><br><span class="line">  <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="[147] Insertion Sort List"></a>[147] Insertion Sort List</h4><blockquote>
<p>Sort a linked list using insertion sort.</p>
</blockquote>
<p>时间复杂度分析:</p>
<p>遍历链表一次, $O(N)$</p>
<p>每到链表的一个节点, 就会扫描排好序的链表部分, 时间为 $O(1)+O(2)+O(3)+…+O(N-1)$</p>
<p>则时间复杂度为: $O(1)+O(2)+…+O(N)=O((N^2+N)/2)=O(N^2)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用插入排序对链表进行排序</span></span><br><span class="line"><span class="comment">// 插入排序是: 不断将没有排序的元素加入已经排好序的部分</span></span><br><span class="line"><span class="comment">// 单向链表只能从前往后遍历</span></span><br><span class="line"><span class="comment">// 这里顺便学习了单向链表</span></span><br><span class="line"><span class="keyword">var</span> insertionSortList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!head.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// 第一个元素默认已经排好序</span></span><br><span class="line">  <span class="comment">// curr 从下一位开始</span></span><br><span class="line">  <span class="keyword">let</span> curr = head.next;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="comment">// 排好序的部分此时只有head一个元素</span></span><br><span class="line">  <span class="comment">// 末尾指向null</span></span><br><span class="line">  <span class="comment">// 与需要排序的部分分开</span></span><br><span class="line">  head.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> cn, hn;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="comment">// 保留curr的后一部分</span></span><br><span class="line">    cn = curr.next;</span><br><span class="line">    <span class="comment">// curr比有序的第一个元素小</span></span><br><span class="line">    <span class="comment">// 则直接置于有序部分的头部</span></span><br><span class="line">    <span class="keyword">if</span> (curr.val &lt;= head.val) &#123;</span><br><span class="line">      curr.next = head;</span><br><span class="line">      head = curr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// curr 比第一个有序元素大</span></span><br><span class="line">      <span class="comment">// 则需要遍历后面的有序元素</span></span><br><span class="line">      <span class="comment">// 直到找到有序排列中比curr大的元素x</span></span><br><span class="line">      <span class="comment">// 则curr插入到 x的前面</span></span><br><span class="line">      <span class="comment">// 为了保留 x 的前一个节点</span></span><br><span class="line">      <span class="comment">// 将curr.val与h.next.val进行比较, 而不是h.val</span></span><br><span class="line">      <span class="keyword">let</span> h = head;</span><br><span class="line">      <span class="keyword">while</span> (h.next &amp;&amp; curr.val &gt; h.next.val) &#123;</span><br><span class="line">        h = h.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将curr插入至 h 与 x 节点之间</span></span><br><span class="line">      hn = h.next;</span><br><span class="line">      h.next = curr;</span><br><span class="line">      curr.next = hn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// curr向后移动一位</span></span><br><span class="line">    curr = cn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="[203] Remove Linked List Elements"></a>[203] Remove Linked List Elements</h4><blockquote>
<p>Remove all elements from a linked list of integers that have value <strong><em>val\</em></strong>.</p>
</blockquote>
<p>时间复杂度: 遍历链表 $O(N)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElements = <span class="function"><span class="keyword">function</span> (<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> hair = <span class="keyword">new</span> ListNode(<span class="literal">null</span>, head);</span><br><span class="line">  <span class="keyword">let</span> pre = hair, curr = head;</span><br><span class="line">  <span class="comment">// pre的移动也是在head表示的这条链表上</span></span><br><span class="line">  <span class="comment">// pre改变的是head本身</span></span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curr.val == val) &#123;</span><br><span class="line">      pre.next = curr.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pre = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有个特殊情况需要注意</span></span><br><span class="line">  <span class="comment">// 比如 [1] 1</span></span><br><span class="line">  <span class="comment">// 此时pre还没后移到head链表上</span></span><br><span class="line">  <span class="comment">// 所以pre指向null没有改变head链表</span></span><br><span class="line">  <span class="comment">// head仍然是 [1]</span></span><br><span class="line">  <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="[206] Reverse Linked List"></a>[206] Reverse Linked List</h4><blockquote>
<p>Reverse a singly linked list.</p>
<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
</blockquote>
<p><strong>递归过程</strong>需要详细的过程分析图(<strong>TO DO</strong>).</p>
<p>两种时间复杂度均为 $O(N)$. </p>
<p>递归方法的时间复杂度分析: 遍历整个链表, 递归调用N次.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代翻转</span></span><br><span class="line"><span class="comment">// 空间复杂度 O(1)</span></span><br><span class="line"><span class="keyword">var</span> reverseList1 = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rever = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> temp;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    temp = head.next;</span><br><span class="line">    head.next = rever.next;</span><br><span class="line">    rever.next = head;</span><br><span class="line">    head = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rever.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归翻转</span></span><br><span class="line"><span class="comment">// 需要注意的是, p是指向head的一个指针</span></span><br><span class="line"><span class="comment">// 并不是另外的链表</span></span><br><span class="line"><span class="comment">// 但是由于每一次都会生成p指针重新指向目前已经倒好序的链表</span></span><br><span class="line"><span class="comment">// 所以递归过程中的空间复杂度为O(1)+O(2)+...+O(N)=O(N)</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> p = reverseList(head.next);</span><br><span class="line">  head.next.next = head;</span><br><span class="line">  head.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="[237] Delete Node in a Linked List"></a>[237] Delete Node in a Linked List</h4><blockquote>
<p>Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p>
<p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p>
</blockquote>
<p>注意看题目条件, 时间/空间复杂度均为 $O(N)$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一时没有想起来用什么解法</span></span><br><span class="line"><span class="comment">// 因为之前删除节点都是不能改变节点自身的值</span></span><br><span class="line"><span class="comment">// 现在这个能改变了 害</span></span><br><span class="line"><span class="comment">// 这个方法令我哭笑不得, 也提醒自己注意看题目条件</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="[234] Palindrome Linked List"></a>[234] Palindrome Linked List</h4><blockquote>
<p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>
</blockquote>
<p>时间复杂度: </p>
<p>遍历链表一次, $O(N)$, 后半部分翻转链表的时候, 时间为$O(N/2)$.</p>
<p>所以时间复杂度为: $O(N)+O(N/2)=O(N)$.</p>
<p>方法:</p>
<p>判断回文链表,要求只能遍历一次链表.</p>
<p>将链表<strong>后半段翻转</strong> 再将前后部分分别比较.</p>
<p>然后还有需要注意的是: <strong>快慢指针法寻找链表中心点</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> fast = head, slow = head;</span><br><span class="line">  <span class="keyword">while</span> (fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不管链表长度是奇数还是偶数 需要进行的操作都是一样的</span></span><br><span class="line">  <span class="comment">// slow 为后半部分链表的起点</span></span><br><span class="line">  slow.next = reverse(slow.next);</span><br><span class="line">  slow = slow.next;</span><br><span class="line">  <span class="comment">// 将前后两部分链表逐个节点对值进行比较</span></span><br><span class="line">  <span class="comment">// 如果有值不等 说明不是回文</span></span><br><span class="line">  <span class="comment">// 前半部分的长度是&gt;=后半部分的</span></span><br><span class="line">  <span class="comment">// 所以当slow=null时, head=null或者head是最后一个节点</span></span><br><span class="line">  <span class="comment">// 由于回文的两种形式, 此时就可以结束比较了</span></span><br><span class="line">  <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.val != slow.val) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head = head.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> curr = head, cn, rn;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    cn = curr.next;</span><br><span class="line">    rn = res.next;</span><br><span class="line">    res.next = curr;</span><br><span class="line">    curr.next = rn;</span><br><span class="line">    curr = cn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="[160] Intersection of Two Linked Lists"></a>[160] Intersection of Two Linked Lists</h4><blockquote>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p><strong>Notes:</strong></p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Each value on each linked list is in the range <code>[1, 10^9]</code>.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
</blockquote>
<img src="/2020/09/11/Linked-list/image1.png" class="" title="image1.png">

<p>由图可知:</p>
<p>$headA = A + C$</p>
<p>$headB = B + C$</p>
<p>所以:</p>
<p>$newA = headA + headB = A + C + B + C$</p>
<p>$newB = headB + headA = B + C + A + C$</p>
<p>已知:</p>
<p>$A + C + B = B + C + A$</p>
<p>所以 <code>newA</code>与<code>newB</code>同时出发, 每次都走一步. </p>
<p><code>newA</code>走完<code>headA</code>再走完<code>B</code>,  <code>newB</code>走完<code>headB</code>再走完<code>A</code>, 如果两者有交点, 则此时会相等且不为<code>null</code>;</p>
<p>如果不相交, 则走到最后两者也相等, 但是为<code>null</code>.</p>
<p>时间复杂度:</p>
<p>假设<code>headA</code>和<code>headB</code>总共的长度为<code>N</code>, 则一共遍历了两次, 时间为$2*O(N)$, 时间复杂度为$O(N)$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路很巧妙 需要分析下 最后两个节点一定会相等</span></span><br><span class="line"><span class="comment">// 只是是地址还是null的问题</span></span><br><span class="line"><span class="comment">// 最差情况是不相交</span></span><br><span class="line"><span class="comment">// 每个链表均遍历了两遍</span></span><br><span class="line"><span class="comment">// 但是额外空间只使用了两个指针变量,为常数级</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span> (<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currA = headA, currB = headB;</span><br><span class="line">  <span class="keyword">while</span> (currA != currB) &#123;</span><br><span class="line">    currA = !currA ? headB : currA.next;</span><br><span class="line">    currB = !currB ? headA : currB.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不相交最后也会相等的 均是null</span></span><br><span class="line">  <span class="comment">// 即： 相交或者是不相交， 二者均会相等</span></span><br><span class="line">  <span class="comment">// 相等的话，返回的是及交点地址</span></span><br><span class="line">  <span class="comment">// 不相等的话，返回的是null</span></span><br><span class="line">  <span class="keyword">return</span> currA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="[328] Odd Even Linked List"></a>[328] Odd Even Linked List</h4><blockquote>
<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
</blockquote>
<p>时间复杂度: 两个指针同时遍历, 一共遍历一遍链表. $O(N)$</p>
<p>空间复杂度: 只是新建了两个指针, 改动原有链表, 没有重新生成head的copy版本. $O(1)$</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完全自己想的法子 太棒了</span></span><br><span class="line"><span class="comment">// 大体思路就是,用两个指针, 一个指向奇数节点, 一个指向偶数节点</span></span><br><span class="line"><span class="comment">// 遍历完head之后, 再将两个链表进行拼接</span></span><br><span class="line"><span class="keyword">var</span> oddEvenList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next || !head.next.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> oddList = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> evenList = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">let</span> odd = oddList, even = evenList;</span><br><span class="line">  <span class="comment">// 初始化第一个奇数节点</span></span><br><span class="line">  odd.next = head;</span><br><span class="line">  odd = odd.next;</span><br><span class="line">  <span class="comment">// 初始化第一个偶数节点</span></span><br><span class="line">  even.next = head.next;</span><br><span class="line">  even = even.next;</span><br><span class="line">  <span class="keyword">while</span> (even &amp;&amp; even.next) &#123;</span><br><span class="line">    odd.next = odd.next.next;</span><br><span class="line">    odd = odd.next;</span><br><span class="line">    even.next = even.next.next;</span><br><span class="line">    even = even.next;</span><br><span class="line">    <span class="comment">// 链表长度为奇数 此时 even==null</span></span><br><span class="line">    <span class="comment">// 链表长度为偶数 此时 even.next==null</span></span><br><span class="line">    <span class="comment">// 两种情况的任何一种情况都应该退出循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对奇数链与偶数链进行拼接</span></span><br><span class="line">  odd.next = evenList.next;</span><br><span class="line">  <span class="keyword">return</span> oddList.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="725-Split-Linked-List-in-Parts"><a href="#725-Split-Linked-List-in-Parts" class="headerlink" title="[725] Split Linked List in Parts"></a>[725] Split Linked List in Parts</h4><blockquote>
<p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list “parts”.</p>
<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>
<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>
<p>Return a List of ListNode’s representing the linked list parts that are formed.</p>
<p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p>
</blockquote>
<p>理解题意 一共分为 k 部分 而不是长度是 k !!</p>
<p><em>时间复杂度*</em>:</p>
<p>在计算链表长度时, 遍历了一次. 后面将链表片段加入时, 又遍历了一遍.</p>
<p>所以时间复杂度为 $O(N+k)$, 在<code>k&gt;len</code>时, 需要继续向结果中加入片段.</p>
<p><strong>空间复杂度</strong>:</p>
<p>生成<code>answer</code>时res数组中包含的节点个数, <code>k&gt;len</code>, k个链表节点, 反之, len个链表节点. 所以空间复杂度为$O(max(N, k))$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> splitListToParts = <span class="function"><span class="keyword">function</span> (<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先计算root的长度</span></span><br><span class="line">  <span class="keyword">let</span> curr = root, len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    len++;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  curr = root;</span><br><span class="line">  <span class="comment">// 计算宽度</span></span><br><span class="line">  <span class="keyword">let</span> width = <span class="built_in">Math</span>.floor(len / k);</span><br><span class="line">  <span class="keyword">let</span> extra = len % k; <span class="comment">// 需要长度被加一的组数</span></span><br><span class="line">  <span class="keyword">let</span> res = []; <span class="comment">// 初始化长度为k的结果数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="comment">// 当k&lt;=len的时候,curr指向null时, for循环也就结束了</span></span><br><span class="line">    <span class="comment">// 因为组数已经达到了k组</span></span><br><span class="line">    <span class="comment">// 出现curr为null的情况时, 并且走到了这里</span></span><br><span class="line">    <span class="comment">// 说明k&gt;len</span></span><br><span class="line">    <span class="comment">// 此时只需要将null不断加入数组直至数组长度达到k</span></span><br><span class="line">    <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">      res.push(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多余没有入组的元素需要加入前面的每一个组</span></span><br><span class="line">    <span class="comment">// 因此前extra组, 每组的元素长度需要+1</span></span><br><span class="line">    <span class="keyword">let</span> l = i &lt; extra ? width + <span class="number">1</span> : width;</span><br><span class="line">    <span class="comment">// l-1是为了控制curr指向part的最后一个元素而不是下一个</span></span><br><span class="line">    <span class="comment">// 便于将该链表片段加入res</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; l - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// curr 到达part的最后一个元素      </span></span><br><span class="line">    <span class="keyword">let</span> cn = curr.next;</span><br><span class="line">    curr.next = <span class="literal">null</span>;</span><br><span class="line">    res.push(root);</span><br><span class="line">    curr = root = cn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="[445] Add Two Numbers II"></a>[445] Add Two Numbers II</h4><blockquote>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Follow up:</strong><br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
</blockquote>
<p>题目要求不能翻转链表, 于是遍历链表, 将链表中的数都存进栈中. 再通过将栈弹出, 进行相加操作.</p>
<p><strong>时间复杂度</strong>:</p>
<p>遍历两个链表, O(N). 两个栈均弹出进行相加操作, O(N). 因此时间为 $2O(N)=O(N)$</p>
<p><strong>空间复杂度</strong>:</p>
<p>使用两个栈存储数字, O(N), 相加之后得到新的结果列表的长度 O(max(m, n)) ps.是两个链表中较长的那一个Lmax, 结果链表长度可能由于进位问题会是Lmax+1, 因此空间复杂度为 $O(N)+O(max(m, n))$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能够翻转链表</span></span><br><span class="line"><span class="comment">// 使用两个栈存储数字</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将两个链表中的值分别存进两个栈中</span></span><br><span class="line">  <span class="keyword">let</span> stack1 = [], stack2 = [];</span><br><span class="line">  <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">    stack1.push(l1.val);</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">    stack2.push(l2.val);</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化变量</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>, carry = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="literal">null</span>), rn;</span><br><span class="line">  <span class="keyword">let</span> add1, add2;</span><br><span class="line">  <span class="comment">// 当两个栈有至少一个不为空时, 都进行相加操作</span></span><br><span class="line">  <span class="comment">// 为空的那个栈的加数为 0</span></span><br><span class="line">  <span class="keyword">while</span> (stack1.length != <span class="number">0</span> || stack2.length != <span class="number">0</span>) &#123;</span><br><span class="line">    add1 = stack1.length == <span class="number">0</span> ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">    add2 = stack2.length == <span class="number">0</span> ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">    sum = add1 + add2 + carry;</span><br><span class="line">    <span class="comment">// 商是进位 大于10为1,小于10为0</span></span><br><span class="line">    carry = <span class="built_in">Math</span>.floor(sum / <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 余数是相加之后结果中的数字</span></span><br><span class="line">    num = sum % <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 将结果添加进结果列表中</span></span><br><span class="line">    rn = res.next;</span><br><span class="line">    res.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">    res.next.next = rn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当两个链表均为空时, 看是否还有进位</span></span><br><span class="line">  <span class="comment">// 有进位则添加进结果列表中</span></span><br><span class="line">  <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">    rn = res.next;</span><br><span class="line">    res.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    res.next.next = rn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







]]></content>
  </entry>
  <entry>
    <title>Sort</title>
    <url>/2020/09/17/Sort/</url>
    <content><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>时间复杂度: n^2</p>
<p>平均空间复杂度: 常数</p>
<p>最快: 正序</p>
<p>最慢: 倒序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="comment">// 不断比较移动给定范围的最大值 直至最大值在数组的末尾</span></span><br><span class="line"><span class="keyword">var</span> bubble = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = arr.length;</span><br><span class="line">  <span class="keyword">let</span> bigger;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// 为了限制内部循环的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="comment">// 不断将更大的值 放在后面</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">        bigger = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = bigger;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>不断找到最小的元素与对应的位置进行交换.</p>
<p>平均时间复杂度: n^2</p>
<p>空间复杂度: 常数</p>
<p>最快: 正序</p>
<p>最慢: 倒序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="keyword">var</span> selection = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = arr.length, minIndex;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exchange minIndex and i</span></span><br><span class="line">    <span class="comment">// 最小值有更新</span></span><br><span class="line">    <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">      arr[i] = arr[minIndex];</span><br><span class="line">      arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>类似于插扑克牌, 假设前n-1个是排好序的, 将第n个元素插入前面的有序数列中, 使得这n个数也是排好顺序的.</p>
<p>平均时间复杂度: n^2</p>
<p>空间复杂度: 常数</p>
<p>最快: 正序 O(n)</p>
<p>最慢: 倒序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">var</span> insertion = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = arr.length, temp;</span><br><span class="line">  <span class="comment">// 标记前多少元素是有序的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 将有序数列的后一个元素加入进来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>对于基本有序的数据序列, 使用插入排序会更高效.</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分治思想, 将多个已有序的子序列合并, 得到完全有序的序列(多路归并).</p>
<p>自上而下的递归/自下而上的迭代.(递归均可用迭代重写)</p>
<p>平均时间复杂度: Ο(nlogn) </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="comment">// 直接对原数组进行修改排序</span></span><br><span class="line"><span class="keyword">var</span> mergeSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> n = arr.length;</span><br><span class="line">  <span class="comment">// 递归结束条件</span></span><br><span class="line">  <span class="comment">// 数组只有一个元素 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>),</span><br><span class="line">    leftArr = arr.slice(<span class="number">0</span>, mid),</span><br><span class="line">    rightArr = arr.slice(mid);</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(leftArr), mergeSort(rightArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function">(<span class="params">leftArr, rightArr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (leftArr.length &amp;&amp; rightArr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftArr[<span class="number">0</span>] &lt;= rightArr[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(leftArr.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(rightArr.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (leftArr.length) &#123;</span><br><span class="line">    result.push(leftArr.shift());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (rightArr.length) &#123;</span><br><span class="line">    result.push(rightArr.shift());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>分治思想, 是处理大数据最快的排序算法之一.</p>
<p>步骤:</p>
<ol>
<li>从数组中选中一个基准</li>
<li>比基准小的放在基准左边, 比基准大的放在基准右边. 所有元素结束之后, 该基准处于数列中间位置, called partition (分区操作).</li>
<li>递归地将基准左边与基准右边的子数列再进行排序.</li>
</ol>
<p>平均时间复杂度:  Ο(nlogn) </p>
<p>空间复杂度: Ο(logn) </p>
<p>最慢: O(N^2)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="keyword">var</span> quickSort = <span class="function">(<span class="params">arr, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> partitionIndex = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// left==right 则数组不需要做排序操作 直接返回即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分区</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="function">(<span class="params">arr, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pivot = left, <span class="comment">// 随机选择基准值</span></span><br><span class="line">    index = pivot + <span class="number">1</span>; <span class="comment">// 标记第一个可以交换的位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">    <span class="comment">// 比基准值小的元素 与index位置的元素进行交换</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i != index) swap(arr, i, index);</span><br><span class="line">      index++; <span class="comment">// 下一个可以交换的位置往后移</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 所有小于基准值的在左边 大于基准值的在右边</span></span><br><span class="line">  <span class="comment">// index 指向第一个大于基准值的元素</span></span><br><span class="line">  <span class="comment">// 将基准值交换到中间</span></span><br><span class="line">  swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 返回基准值的最新位置</span></span><br><span class="line">  <span class="comment">// 为下一轮划分分区做准备</span></span><br><span class="line">  <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="keyword">var</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3>]]></content>
  </entry>
  <entry>
    <title>Two Pointers</title>
    <url>/2020/07/30/Two-Pointers/</url>
    <content><![CDATA[<h4 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="[11] Container With Most Water"></a>[11] Container With Most Water</h4><blockquote>
<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>
</blockquote>
<h6 id="my-solution-Brute-Force"><a href="#my-solution-Brute-Force" class="headerlink" title="my solution : Brute Force"></a>my solution : Brute Force</h6><p>穷举所有面积的可能性,最后对面积进行排序,找到最大值.</p>
<p>中间一度尝试过将 <code>partArea</code> 组成数组先排序,也还是超时.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> partMaxSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> yVal = height[j] &lt; height[i] ? height[j] : height[i];</span><br><span class="line">      <span class="keyword">let</span> partArea = (j - i) * yVal;</span><br><span class="line">      partMaxSet.add(partArea);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> partMaxList = <span class="built_in">Array</span>.from(partMaxSet);</span><br><span class="line">  <span class="comment">// 数字降序排列</span></span><br><span class="line">  partMaxList.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a &#125;);</span><br><span class="line">  <span class="keyword">return</span> partMaxList[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// return Math.max.apply(null, partMaxList);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers"><a href="#Two-pointers" class="headerlink" title="Two pointers"></a>Two pointers</h6><p>采用双指针做法, 对于 S(i, j) 来说, 都是每次向里移动一步.</p>
<p>移动短板, 短板有可能变长, 面积有可能变大.</p>
<p>但是移动长板,  短板只会不变或者变小, 因为盛水的体积取决于短板, 所以面积只会不变或变小.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此算法需要证明</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> areaList = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">while</span> (j - i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">      <span class="comment">// 计算面积以短边为准</span></span><br><span class="line">      areaList.push((j - i) * height[i]);</span><br><span class="line">      <span class="comment">// 移动短边有可能获得更大面积</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      areaList.push((j - i) * height[j]);</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将可能的面积列表倒序排列,返回第一个</span></span><br><span class="line">  <span class="keyword">return</span> areaList.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : O(n)<em>O</em>(<em>n</em>). Single pass.</li>
<li>Space complexity : O(1)<em>O</em>(1). Constant space is used.</li>
</ul>
<h4 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="[26] Remove Duplicates from Sorted Array"></a>[26] Remove Duplicates from Sorted Array</h4><blockquote>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
</blockquote>
<h6 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h6><p>借用 js 数组splice方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nums[j] == nums[i]) &#123;</span><br><span class="line">      nums.splice(j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers-1"><a href="#Two-pointers-1" class="headerlink" title="Two pointers"></a>Two pointers</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考双指针的方法, 优化了解法</span></span><br><span class="line"><span class="comment">// js的数组越界不会报错,只会得到 undefined 值</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="[27] Remove Element"></a>[27] Remove Element</h4><blockquote>
<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<h6 id="my-solution-1"><a href="#my-solution-1" class="headerlink" title="my solution"></a>my solution</h6><p>我自己的解法是利用了js数组操作的特性, 可以直接删除数组元素然后剩余元素位置前移的那种,比较方便,但是运行效果不咋地.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 使用 while 保证对于同一个i, 去除该位置所有与val相等的值</span></span><br><span class="line">    <span class="comment">// 不会遗漏由于删除数组元素而位置前移的新元素</span></span><br><span class="line">    <span class="keyword">while</span> (nums[i] == val) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="Two-pointers-2"><a href="#Two-pointers-2" class="headerlink" title="Two pointers"></a>Two pointers</h6><p>下面的解法是参考了示例解法, 双指针解法. 我觉得很精巧.</p>
<p>主要思路是, 将需要保留的元素都赋值给数组的前部分, 使用 i 标记赋值的位置.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution two pointers</span></span><br><span class="line"><span class="comment">// 只保留与val不同的元素</span></span><br><span class="line"><span class="comment">// 赋值操作比起splice的删除操作 肯定速度更快 至于额外的空间 需要看splice的实现有没有占用了</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      <span class="comment">// console.log("i=", i, " ", nums[i]);</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最差的情况应该是, 没有一个一样的, 但是遍历数组两遍而不是嵌套, 所以是 O(n).</p>
<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time complexity : O(n). Assume the array has a total of n<em>n</em> elements, both <em>i</em> and <em>j</em> traverse at most 2<em>n</em> steps.</li>
<li>Space complexity : O(1).</li>
</ul>
<h4 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="[15] 3Sum"></a>[15] 3Sum</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
</blockquote>
<p>数组排序后, 方便去除重复的元素 + 双指针移动不用嵌套且有方向可循.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 2 ：将数组排序后的双指针解法</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 将数组正序排列</span></span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 第一个数大于 0，肯定加起来和不为0了</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉重复元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> target = -nums[i];</span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">        res.push([nums[i], nums[left], nums[right]]);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 这里是否判断 left &lt; right 都没有那么重要, 因为最外面还会再判断一次</span></span><br><span class="line">        <span class="comment">// 但是加上判断可能会少做一次计算</span></span><br><span class="line">        <span class="comment">// 去掉重复元素</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">          right--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="[16] 3Sum Closest"></a>[16] 3Sum Closest</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
</blockquote>
<p>注意这里不是找相等, 而是保留最接近target的值, 实现方法类似.</p>
<p>与target比较, 由于一直在找最接近的, 比target小就left++, 比target大就right–, 总之就是不断靠近target.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> closest = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">let</span> diff = <span class="built_in">Math</span>.abs(closest - target);</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 由于数组是排好序的</span></span><br><span class="line">    <span class="comment">// 如果nums[i] * 3 &gt; target, 则 nums[i]+nums[i+1]+nums[i+2] 是接下来遍历的最小值</span></span><br><span class="line">    <span class="comment">// 后面差距只会越来越大</span></span><br><span class="line">    <span class="comment">// 将接下来最小值与当前最小值closest分别与target比较, 返回与target差距较小的那个值</span></span><br><span class="line">    <span class="comment">// 优化部分</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] * <span class="number">3</span> &gt; target) &#123;</span><br><span class="line">      <span class="keyword">let</span> cDiff = <span class="built_in">Math</span>.abs(closest - target);</span><br><span class="line">      <span class="keyword">let</span> tempMin = nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">let</span> tDiff = <span class="built_in">Math</span>.abs(tempMin - target);</span><br><span class="line">      <span class="keyword">return</span> cDiff &lt; tDiff ? closest : tempMin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针 遍历数组剩余元素</span></span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">      <span class="keyword">let</span> newDiff = <span class="built_in">Math</span>.abs(sum - target);</span><br><span class="line">      <span class="keyword">if</span> (newDiff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newDiff &lt; diff) &#123;</span><br><span class="line">        diff = newDiff;</span><br><span class="line">        closest = sum;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">        left++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log('closest:', closest);</span></span><br><span class="line">  <span class="keyword">return</span> closest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="[18] 4Sum"></a>[18] 4Sum</h4><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em>in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
</blockquote>
<p>有了双指针, nSum都可解, 不过这个嵌套有点多,估计有更巧妙的解法.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fourSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> len = nums.length, res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nums[j] == nums[j - <span class="number">1</span>] &amp;&amp; j &gt; i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">let</span> t = target - nums[i] - nums[j];</span><br><span class="line">      <span class="keyword">let</span> left = j + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> twoSum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (twoSum == t) &#123;</span><br><span class="line">          res.push([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">          <span class="comment">// 去重</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">            left++;</span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (twoSum &gt; t) &#123;</span><br><span class="line">          right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(res);</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="[283] Move Zeroes"></a>[283] Move Zeroes</h4><blockquote>
<p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Note</strong>:</p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
</blockquote>
<p>双指针解法, 一次成功.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution: two pointers</span></span><br><span class="line"><span class="comment">// 借鉴之前的做题经验, 这题算是完成的比较快</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> t = i; t &lt; len; t++) &#123;</span><br><span class="line">    nums[t] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(nums);</span></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="[66] Plus One"></a>[66] Plus One</h4><blockquote>
<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, increment one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
</blockquote>
<p>主要是运用数组特性.不是很难, 理解题意即可.</p>
<p>还挺多人不喜欢这道题的, 可能觉得太弱智了?…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = digits.length;</span><br><span class="line">  <span class="comment">// c 表示进位</span></span><br><span class="line">  <span class="keyword">let</span> i = len - <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有向前进位, 就 +1 结束</span></span><br><span class="line">    <span class="keyword">if</span> (digits[i] + c &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      digits[i]++;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 首位元素 +1 后有进位, 向数组头部插入 1 结束</span></span><br><span class="line">      digits[i] = <span class="number">0</span>;</span><br><span class="line">      digits.unshift(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是首位元素 +1 后有进位</span></span><br><span class="line">      <span class="comment">// 当前元素设为 0 , 继续看更高位元素</span></span><br><span class="line">      digits[i] = <span class="number">0</span>;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(digits);</span></span><br><span class="line">  <span class="keyword">return</span> digits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="[88] Merge Sorted Array"></a>[88] Merge Sorted Array</h4><blockquote>
<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em>and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is <strong>equal</strong> to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
</blockquote>
<p>我用的方法比较死板, 感觉没有什么难度. 就是分情况讨论. </p>
<p>不过用到了 js 里 Array 的特性.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 说明没有自己的元素</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums1[i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> len = nums1.length;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> j = m;</span><br><span class="line">        <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; k &lt; n) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums2[k] &gt;= nums1[i] &amp;&amp; nums2[k] &lt; nums1[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                nums1.splice(i + <span class="number">1</span>, <span class="number">0</span>, nums2[k]);</span><br><span class="line">                nums1.pop();</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums2[k] &gt;= nums1[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums1[j] = nums2[k];</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums2[k] &lt;= nums1[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums1.unshift(nums2[k]);</span><br><span class="line">                nums1.pop();</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="[80] Remove Duplicates from Sorted Array II"></a>[80] Remove Duplicates from Sorted Array II</h4><blockquote>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
</blockquote>
<p><strong>时间复杂度</strong>: 遍历整个数组 $O(N)$</p>
<p><strong>空间复杂度</strong>: 仅使用两个index: left和right标记数组元素位置, $O(1)$ </p>
<p>使用splice方法直接修改数组. (这个方法的实现原理需要了解一下 TODO)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组是排好序的</span></span><br><span class="line"><span class="comment">// 不能使用额外空间,直接修改数组</span></span><br><span class="line"><span class="comment">// 使所有元素出现次数最多不超过2次</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[right] == nums[left] &amp;&amp; right - left == <span class="number">1</span>) &#123;</span><br><span class="line">      right++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明至少是第三个相同的元素</span></span><br><span class="line">    <span class="comment">// 需要将该元素删除</span></span><br><span class="line">    <span class="keyword">if</span> (nums[right] == nums[left] &amp;&amp; right - left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      nums.splice(right, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 删除元素时会影响原数组的长度</span></span><br><span class="line">      <span class="comment">// 但是right仍然需要控制不能超过数组的边界</span></span><br><span class="line">      len = nums.length;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// right和left指向的元素不同</span></span><br><span class="line">    left = right;</span><br><span class="line">    right = right + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当right==len的时候,说明数组遍历结束</span></span><br><span class="line">  <span class="comment">// 返回当前删除重复元素后的数组长度</span></span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="[202] Happy Number"></a>[202] Happy Number</h4><blockquote>
<p>Write an algorithm to determine if a number <code>n</code> is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1. Those numbers for which this process <strong>ends in 1</strong> are happy numbers.</p>
<p>Return True if <code>n</code> is a happy number, and False if not.</p>
</blockquote>
<p>复杂度分析有点困难, 以及为什么只有循环或者归1两种结果, 而不是无穷大.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// solution 1: 快慢指针法</span></span><br><span class="line"><span class="comment">// 快慢指针找循环</span></span><br><span class="line"><span class="comment">// 在平方累加的过程中, 要不最后等于1, 要不最后陷入循环, 至于为什么不是无穷大</span></span><br><span class="line"><span class="comment">// 需要再琢磨一下</span></span><br><span class="line"><span class="keyword">var</span> isHappy1 = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 慢指针一次计算一步, 快指针一次计算两步</span></span><br><span class="line">  <span class="comment">// 如果两个指针的值一样, 说明进入循环</span></span><br><span class="line">  <span class="comment">// 否则, 快指针一定比慢指针率先到达1</span></span><br><span class="line">  <span class="comment">// 初始化快慢指针</span></span><br><span class="line">  <span class="keyword">let</span> slow = getPow(n), fast = getPow(getPow(n));</span><br><span class="line">  <span class="keyword">while</span> (fast != <span class="number">1</span> &amp;&amp; fast != slow) &#123;</span><br><span class="line">    slow = getPow(slow);</span><br><span class="line">    fast = getPow(fast);</span><br><span class="line">    fast = getPow(fast);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fast == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算某个数的各个数位上的平方</span></span><br><span class="line"><span class="keyword">var</span> getPow = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = n % <span class="number">10</span>;</span><br><span class="line">    sum += num * num;</span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n / <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution 2: 使用hashmap来判断值有无重复 聪儿判断有无循环</span></span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> res = getPow(n);</span><br><span class="line">  <span class="comment">// map中没有该计算结果</span></span><br><span class="line">  <span class="comment">// 则添加进map中</span></span><br><span class="line">  <span class="comment">// 不是undefined 说明该计算结果之前已经被塞进map中</span></span><br><span class="line">  <span class="comment">// 得到循环</span></span><br><span class="line">  <span class="keyword">while</span> (map[res] == <span class="literal">undefined</span> &amp;&amp; res != <span class="number">1</span>) &#123;</span><br><span class="line">    map[res] = <span class="string">'1'</span>;</span><br><span class="line">    res = getPow(res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>String</title>
    <url>/2020/08/17/String/</url>
    <content><![CDATA[<h4 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="[43] Multiply Strings"></a>[43] Multiply Strings</h4><blockquote>
<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
</blockquote>
<p>算法答题思路就是模拟乘法累加的过程. </p>
<p>需要注意的是, js大数相加会丢失精度, 所以谨慎使用.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// js大数相加容易丢失精度, 有安全范围, 不行</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 整个算法的过程模拟乘法的计算过程</span></span><br><span class="line"><span class="comment"> * 用一个数组来存储每一步计算的结果</span></span><br><span class="line"><span class="comment"> * 时间复杂度: n^2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> multiply = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 有一个参数为0,则结果为0</span></span><br><span class="line">  <span class="keyword">if</span> (num1 == <span class="string">'0'</span> || num2 == <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">let</span> len1 = num1.length,</span><br><span class="line">    len2 = num2.length,</span><br><span class="line">    len = len1 + len2;</span><br><span class="line">  <span class="comment">// 数组存储计算结果 长度暂时为两个字符串长度之和</span></span><br><span class="line">  <span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="comment">// 初始化结果数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    resArr[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环反过来的原因是: 每次都是先拿因数1的每一位与因数2的同一位相乘</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">let</span> n2 = <span class="built_in">parseInt</span>(num2[j]);</span><br><span class="line">    <span class="comment">// 计算结果放置的位置</span></span><br><span class="line">    <span class="keyword">let</span> pos = len - len2 + j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> n1 = <span class="built_in">parseInt</span>(num1[i]);</span><br><span class="line">      <span class="keyword">let</span> res = n1 * n2;</span><br><span class="line">      addNext(res, resArr, pos, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 数位升高一位, 结果放置也要对应往左一位</span></span><br><span class="line">      pos--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 去除结果数组最左边的 0</span></span><br><span class="line">  <span class="keyword">while</span> (resArr[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">    resArr.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resArr.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag 为 1 表示要与当前位置数值相加</span></span><br><span class="line"><span class="comment">// 为 0 则表示不用相加</span></span><br><span class="line"><span class="keyword">var</span> addNext = <span class="function">(<span class="params">num, resArr, pos, flag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> posNum = num % <span class="number">10</span>, <span class="comment">// 取余数 置于当前位置</span></span><br><span class="line">    addNum = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>); <span class="comment">// floor 向下取整</span></span><br><span class="line"></span><br><span class="line">  resArr[pos] = (flag == <span class="number">1</span>) ? resArr[pos] + posNum : posNum;</span><br><span class="line">  resArr[pos - <span class="number">1</span>] += addNum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (resArr[pos] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 与当前数值相加之后, 数值大于10, 则当前仍然需要进位</span></span><br><span class="line">    <span class="comment">// 但是不需要再与当前位置数值相加了</span></span><br><span class="line">    addNext(resArr[pos], resArr, pos, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进位最多只会等于 10</span></span><br><span class="line">  <span class="keyword">if</span> (resArr[pos - <span class="number">1</span>] == <span class="number">10</span>) &#123;</span><br><span class="line">    addNext(resArr[pos - <span class="number">1</span>], resArr, pos - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="[13] Roman to Integer"></a>[13] Roman to Integer</h4><blockquote>
<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>
<p>时间复杂度: 遍历整个字符串, $O(N)$</p>
<p>空间复杂度: 常数级别.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 罗马数字一共三种情况</span></span><br><span class="line"><span class="comment">// 百位数字&gt;十位数字&gt;个位数字</span></span><br><span class="line"><span class="comment">// 出现左侧数字比右侧数字小, 只会在某一个数位内部</span></span><br><span class="line"><span class="keyword">var</span> romanToInt = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从左往右遍历</span></span><br><span class="line">  <span class="keyword">let</span> pre = getVal(s[<span class="number">0</span>]), sum = <span class="number">0</span>, num;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    num = getVal(s[i]);</span><br><span class="line">    <span class="comment">// 前一个数字不小于后一个数字, 加上pre</span></span><br><span class="line">    <span class="comment">// 反之, 说明pre是某一数位内部的需要减去的数字, 则减去pre</span></span><br><span class="line">    <span class="comment">// 左侧的被减去的数字只出现一次或者不出现, 不会出现两次</span></span><br><span class="line">    <span class="keyword">if</span> (pre &gt;= num) &#123;</span><br><span class="line">      sum += pre;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sum -= pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新pre的值</span></span><br><span class="line">    pre = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一位不会再比右边哪个元素小了</span></span><br><span class="line">  <span class="comment">// 所以需要将最后一位加上</span></span><br><span class="line">  sum += getVal(s[len - <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getVal = <span class="function">(<span class="params">ch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="[12] Integer to Roman"></a>[12] Integer to Roman</h4><blockquote>
<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
</blockquote>
<p>主要是不同数位的数字转换, 需要对数位进行分情况讨论. 不同数位的相同数字, 对应使用的罗马字符也不同.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要思路就是, 逐步整除, 然后对商进行对应数位的转换</span></span><br><span class="line"><span class="keyword">var</span> intToRoman = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = [<span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> n, res = <span class="string">''</span>; <span class="comment">// res需要初始化 否则res+=操作时, 由于res的值为udefined, 会在结果头部留一个udefined</span></span><br><span class="line">  <span class="comment">// 从千位除到个位</span></span><br><span class="line">  <span class="comment">// 注意 用let i in items时, typeof i = string</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 得到商</span></span><br><span class="line">    n = <span class="built_in">Math</span>.floor(num / items[i]);</span><br><span class="line">    <span class="comment">// 根据数位以及商的大小确定对应的罗马数字</span></span><br><span class="line">    <span class="comment">// 并对每一步得到的罗马数字进行拼接</span></span><br><span class="line">    <span class="comment">// 使用索引顺便标记数位</span></span><br><span class="line">    res += toRoman(i, n);</span><br><span class="line">    <span class="comment">// 后一轮需要被整除的数是当前一轮整除后得到的余数</span></span><br><span class="line">    num = num % items[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toRoman = <span class="function">(<span class="params">type, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sma = <span class="string">''</span>, mid = <span class="string">''</span>, top = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 数位不同 相同数字的表达方法不同</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 千位</span></span><br><span class="line">      sma = <span class="string">'M'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 百位</span></span><br><span class="line">      sma = <span class="string">'C'</span>; mid = <span class="string">'D'</span>; top = <span class="string">'M'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 十位</span></span><br><span class="line">      sma = <span class="string">'X'</span>; mid = <span class="string">'L'</span>; top = <span class="string">'C'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 个位</span></span><br><span class="line">      sma = <span class="string">'I'</span>; mid = <span class="string">'V'</span>; top = <span class="string">'X'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> roman = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 根据 n 的大小, 转换成对应的罗马数字</span></span><br><span class="line">  <span class="comment">// 千位不会超过3</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">3</span>) &#123; <span class="comment">// [0,3]</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">      roman += sma;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">4</span> || n == <span class="number">9</span>) &#123; <span class="comment">// 4/9</span></span><br><span class="line">    roman = n == <span class="number">4</span> ? sma + mid : sma + top;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// [5, 8]</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    roman = mid;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; n - <span class="number">5</span>) &#123;</span><br><span class="line">      roman += sma;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> roman;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="[49] Group Anagrams"></a>[49] Group Anagrams</h4><blockquote>
<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串按照构成分组</span></span><br><span class="line"><span class="comment">// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为字典的key</span></span><br><span class="line"><span class="comment">// 相同key的就将元素index加入key对应的数组[]</span></span><br><span class="line"><span class="comment">// 将字符串按照构成分组</span></span><br><span class="line"><span class="comment">// 我的思路是: 将每个字符串按照字符拆分,然后排序,然后作为map的key</span></span><br><span class="line"><span class="comment">// 相同key的就将元素index加入key对应的数组[]</span></span><br><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = strs.length;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> [strs];</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;, key;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 对每个字符串的字符拆分-排序-重组为string</span></span><br><span class="line">    <span class="comment">// 以至于相同字母组成的str的key会一致</span></span><br><span class="line">    key = strs[i].split(<span class="string">''</span>).sort().toString();</span><br><span class="line">    <span class="comment">// 看map是否存在</span></span><br><span class="line">    <span class="comment">// 不存在生成[]</span></span><br><span class="line">    <span class="comment">// 存在往[]里push元素</span></span><br><span class="line">    <span class="keyword">if</span> (map[key] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      map[key] = [i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map[key].push(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// map中value是数组, 包含字母组成相同的一组字符串的index</span></span><br><span class="line">  <span class="comment">// 遍历每一个数组, 将index替换为strs里对应的str</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> map) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; map[k].length; i++) &#123;</span><br><span class="line">      map[k][i] = strs[map[k][i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直接返回对象的values, 所有value被添加进[]并返回</span></span><br><span class="line">  <span class="comment">// 本来是又新创建了个数组来存储结果, 这样直接返回values更节省空间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.values(map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="[67] Add Binary"></a>[67] Add Binary</h4><blockquote>
<p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p>
</blockquote>
<p>时间复杂度:</p>
<p>假设两个串的长度分别为M/N, 则时间复杂度为 $O(max(M, N))$.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addBinary = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = a.length - <span class="number">1</span>, j = b.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> num, carry = <span class="literal">false</span>, sum = <span class="string">''</span>, charA, charB;</span><br><span class="line">  <span class="keyword">while</span> (a[i] || b[j]) &#123;</span><br><span class="line">    <span class="comment">// 考虑到两个串长度不一致时的处理</span></span><br><span class="line">    charA = (a[i] == <span class="literal">undefined</span>) ? <span class="string">'0'</span> : a[i];</span><br><span class="line">    charB = (b[j] == <span class="literal">undefined</span>) ? <span class="string">'0'</span> : b[j];</span><br><span class="line">    <span class="comment">// 由于二进制不是十进制加法, 所以需要对相加结果进行分类讨论</span></span><br><span class="line">    <span class="keyword">if</span> (charA == charB) &#123;</span><br><span class="line">      num = carry ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">      carry = charA == <span class="string">'1'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      num = carry ? <span class="string">'0'</span> : <span class="string">'1'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = num + sum;</span><br><span class="line">    i--;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果两数的每一位均已对应相加完成, 但是还有进位, 需要把进位也加入结果中</span></span><br><span class="line">  sum = carry ? <span class="string">'1'</span> + sum : sum;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="[28] Implement strStr()"></a>[28] Implement strStr()</h4><blockquote>
<p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strStr()</a>.</p>
<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>
</blockquote>
<p>时间复杂度: </p>
<p>设source长度为N, target长度为M, 最差的情况是: 一直遍历到最后的部分才知道是否有和target匹配的部分. O((N-M)*M). 不用遍历到source的最后一个元素, 只要剩余部分的长度不足M, 即可退出遍历.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直观想法 使用双重循环 </span></span><br><span class="line"><span class="comment">// 最外层循环是对源字符串的遍历</span></span><br><span class="line"><span class="comment">// 需要考虑源字符串剩余长度不够匹配目标字符串的情况</span></span><br><span class="line"><span class="comment">// 建议使用source target这类有意义的变量命名</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span> (<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 目标串为'' 默认出现位置是0</span></span><br><span class="line">  <span class="keyword">if</span> (needle == <span class="string">''</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 源串为''(这里needle不为'') 则找不到</span></span><br><span class="line">  <span class="keyword">if</span> (haystack == <span class="string">''</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack[i] == needle[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isEqual(haystack, needle, i))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isEqual = <span class="function">(<span class="params">haystack, needle, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理源字符串需要比较的串长度小于needle的长度的情况</span></span><br><span class="line">  <span class="keyword">if</span> (haystack.length - i &lt; needle.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; needle.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle[j] != haystack[i])</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Vue Learning</title>
    <url>/2020/07/29/Vue-Learning/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
